<!DOCTYPE HTML>
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<main role="main">
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span><a id="line.1">// ASM: a very small and fast Java bytecode manipulation framework</a>
<span class="sourceLineNo">002</span><a id="line.2">// Copyright (c) 2000-2011 INRIA, France Telecom</a>
<span class="sourceLineNo">003</span><a id="line.3">// All rights reserved.</a>
<span class="sourceLineNo">004</span><a id="line.4">//</a>
<span class="sourceLineNo">005</span><a id="line.5">// Redistribution and use in source and binary forms, with or without</a>
<span class="sourceLineNo">006</span><a id="line.6">// modification, are permitted provided that the following conditions</a>
<span class="sourceLineNo">007</span><a id="line.7">// are met:</a>
<span class="sourceLineNo">008</span><a id="line.8">// 1. Redistributions of source code must retain the above copyright</a>
<span class="sourceLineNo">009</span><a id="line.9">//    notice, this list of conditions and the following disclaimer.</a>
<span class="sourceLineNo">010</span><a id="line.10">// 2. Redistributions in binary form must reproduce the above copyright</a>
<span class="sourceLineNo">011</span><a id="line.11">//    notice, this list of conditions and the following disclaimer in the</a>
<span class="sourceLineNo">012</span><a id="line.12">//    documentation and/or other materials provided with the distribution.</a>
<span class="sourceLineNo">013</span><a id="line.13">// 3. Neither the name of the copyright holders nor the names of its</a>
<span class="sourceLineNo">014</span><a id="line.14">//    contributors may be used to endorse or promote products derived from</a>
<span class="sourceLineNo">015</span><a id="line.15">//    this software without specific prior written permission.</a>
<span class="sourceLineNo">016</span><a id="line.16">//</a>
<span class="sourceLineNo">017</span><a id="line.17">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</a>
<span class="sourceLineNo">018</span><a id="line.18">// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<span class="sourceLineNo">019</span><a id="line.19">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<span class="sourceLineNo">020</span><a id="line.20">// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</a>
<span class="sourceLineNo">021</span><a id="line.21">// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<span class="sourceLineNo">022</span><a id="line.22">// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<span class="sourceLineNo">023</span><a id="line.23">// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<span class="sourceLineNo">024</span><a id="line.24">// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<span class="sourceLineNo">025</span><a id="line.25">// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<span class="sourceLineNo">026</span><a id="line.26">// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</a>
<span class="sourceLineNo">027</span><a id="line.27">// THE POSSIBILITY OF SUCH DAMAGE.</a>
<span class="sourceLineNo">028</span><a id="line.28">package clojure.asm;</a>
<span class="sourceLineNo">029</span><a id="line.29"></a>
<span class="sourceLineNo">030</span><a id="line.30">/**</a>
<span class="sourceLineNo">031</span><a id="line.31"> * A {@link MethodVisitor} that generates a corresponding 'method_info' structure, as defined in the</a>
<span class="sourceLineNo">032</span><a id="line.32"> * Java Virtual Machine Specification (JVMS).</a>
<span class="sourceLineNo">033</span><a id="line.33"> *</a>
<span class="sourceLineNo">034</span><a id="line.34"> * @see &lt;a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.6"&gt;JVMS</a>
<span class="sourceLineNo">035</span><a id="line.35"> *     4.6&lt;/a&gt;</a>
<span class="sourceLineNo">036</span><a id="line.36"> * @author Eric Bruneton</a>
<span class="sourceLineNo">037</span><a id="line.37"> * @author Eugene Kuleshov</a>
<span class="sourceLineNo">038</span><a id="line.38"> */</a>
<span class="sourceLineNo">039</span><a id="line.39">final class MethodWriter extends MethodVisitor {</a>
<span class="sourceLineNo">040</span><a id="line.40"></a>
<span class="sourceLineNo">041</span><a id="line.41">  /** Indicates that nothing must be computed. */</a>
<span class="sourceLineNo">042</span><a id="line.42">  static final int COMPUTE_NOTHING = 0;</a>
<span class="sourceLineNo">043</span><a id="line.43"></a>
<span class="sourceLineNo">044</span><a id="line.44">  /**</a>
<span class="sourceLineNo">045</span><a id="line.45">   * Indicates that the maximum stack size and the maximum number of local variables must be</a>
<span class="sourceLineNo">046</span><a id="line.46">   * computed, from scratch.</a>
<span class="sourceLineNo">047</span><a id="line.47">   */</a>
<span class="sourceLineNo">048</span><a id="line.48">  static final int COMPUTE_MAX_STACK_AND_LOCAL = 1;</a>
<span class="sourceLineNo">049</span><a id="line.49"></a>
<span class="sourceLineNo">050</span><a id="line.50">  /**</a>
<span class="sourceLineNo">051</span><a id="line.51">   * Indicates that the maximum stack size and the maximum number of local variables must be</a>
<span class="sourceLineNo">052</span><a id="line.52">   * computed, from the existing stack map frames. This can be done more efficiently than with the</a>
<span class="sourceLineNo">053</span><a id="line.53">   * control flow graph algorithm used for {@link #COMPUTE_MAX_STACK_AND_LOCAL}, by using a linear</a>
<span class="sourceLineNo">054</span><a id="line.54">   * scan of the bytecode instructions.</a>
<span class="sourceLineNo">055</span><a id="line.55">   */</a>
<span class="sourceLineNo">056</span><a id="line.56">  static final int COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES = 2;</a>
<span class="sourceLineNo">057</span><a id="line.57"></a>
<span class="sourceLineNo">058</span><a id="line.58">  /**</a>
<span class="sourceLineNo">059</span><a id="line.59">   * Indicates that the stack map frames of type F_INSERT must be computed. The other frames are not</a>
<span class="sourceLineNo">060</span><a id="line.60">   * computed. They should all be of type F_NEW and should be sufficient to compute the content of</a>
<span class="sourceLineNo">061</span><a id="line.61">   * the F_INSERT frames, together with the bytecode instructions between a F_NEW and a F_INSERT</a>
<span class="sourceLineNo">062</span><a id="line.62">   * frame - and without any knowledge of the type hierarchy (by definition of F_INSERT).</a>
<span class="sourceLineNo">063</span><a id="line.63">   */</a>
<span class="sourceLineNo">064</span><a id="line.64">  static final int COMPUTE_INSERTED_FRAMES = 3;</a>
<span class="sourceLineNo">065</span><a id="line.65"></a>
<span class="sourceLineNo">066</span><a id="line.66">  /**</a>
<span class="sourceLineNo">067</span><a id="line.67">   * Indicates that all the stack map frames must be computed. In this case the maximum stack size</a>
<span class="sourceLineNo">068</span><a id="line.68">   * and the maximum number of local variables is also computed.</a>
<span class="sourceLineNo">069</span><a id="line.69">   */</a>
<span class="sourceLineNo">070</span><a id="line.70">  static final int COMPUTE_ALL_FRAMES = 4;</a>
<span class="sourceLineNo">071</span><a id="line.71"></a>
<span class="sourceLineNo">072</span><a id="line.72">  /** Indicates that {@link #STACK_SIZE_DELTA} is not applicable (not constant or never used). */</a>
<span class="sourceLineNo">073</span><a id="line.73">  private static final int NA = 0;</a>
<span class="sourceLineNo">074</span><a id="line.74"></a>
<span class="sourceLineNo">075</span><a id="line.75">  /**</a>
<span class="sourceLineNo">076</span><a id="line.76">   * The stack size variation corresponding to each JVM opcode. The stack size variation for opcode</a>
<span class="sourceLineNo">077</span><a id="line.77">   * 'o' is given by the array element at index 'o'.</a>
<span class="sourceLineNo">078</span><a id="line.78">   *</a>
<span class="sourceLineNo">079</span><a id="line.79">   * @see &lt;a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html"&gt;JVMS 6&lt;/a&gt;</a>
<span class="sourceLineNo">080</span><a id="line.80">   */</a>
<span class="sourceLineNo">081</span><a id="line.81">  private static final int[] STACK_SIZE_DELTA = {</a>
<span class="sourceLineNo">082</span><a id="line.82">    0, // nop = 0 (0x0)</a>
<span class="sourceLineNo">083</span><a id="line.83">    1, // aconst_null = 1 (0x1)</a>
<span class="sourceLineNo">084</span><a id="line.84">    1, // iconst_m1 = 2 (0x2)</a>
<span class="sourceLineNo">085</span><a id="line.85">    1, // iconst_0 = 3 (0x3)</a>
<span class="sourceLineNo">086</span><a id="line.86">    1, // iconst_1 = 4 (0x4)</a>
<span class="sourceLineNo">087</span><a id="line.87">    1, // iconst_2 = 5 (0x5)</a>
<span class="sourceLineNo">088</span><a id="line.88">    1, // iconst_3 = 6 (0x6)</a>
<span class="sourceLineNo">089</span><a id="line.89">    1, // iconst_4 = 7 (0x7)</a>
<span class="sourceLineNo">090</span><a id="line.90">    1, // iconst_5 = 8 (0x8)</a>
<span class="sourceLineNo">091</span><a id="line.91">    2, // lconst_0 = 9 (0x9)</a>
<span class="sourceLineNo">092</span><a id="line.92">    2, // lconst_1 = 10 (0xa)</a>
<span class="sourceLineNo">093</span><a id="line.93">    1, // fconst_0 = 11 (0xb)</a>
<span class="sourceLineNo">094</span><a id="line.94">    1, // fconst_1 = 12 (0xc)</a>
<span class="sourceLineNo">095</span><a id="line.95">    1, // fconst_2 = 13 (0xd)</a>
<span class="sourceLineNo">096</span><a id="line.96">    2, // dconst_0 = 14 (0xe)</a>
<span class="sourceLineNo">097</span><a id="line.97">    2, // dconst_1 = 15 (0xf)</a>
<span class="sourceLineNo">098</span><a id="line.98">    1, // bipush = 16 (0x10)</a>
<span class="sourceLineNo">099</span><a id="line.99">    1, // sipush = 17 (0x11)</a>
<span class="sourceLineNo">100</span><a id="line.100">    1, // ldc = 18 (0x12)</a>
<span class="sourceLineNo">101</span><a id="line.101">    NA, // ldc_w = 19 (0x13)</a>
<span class="sourceLineNo">102</span><a id="line.102">    NA, // ldc2_w = 20 (0x14)</a>
<span class="sourceLineNo">103</span><a id="line.103">    1, // iload = 21 (0x15)</a>
<span class="sourceLineNo">104</span><a id="line.104">    2, // lload = 22 (0x16)</a>
<span class="sourceLineNo">105</span><a id="line.105">    1, // fload = 23 (0x17)</a>
<span class="sourceLineNo">106</span><a id="line.106">    2, // dload = 24 (0x18)</a>
<span class="sourceLineNo">107</span><a id="line.107">    1, // aload = 25 (0x19)</a>
<span class="sourceLineNo">108</span><a id="line.108">    NA, // iload_0 = 26 (0x1a)</a>
<span class="sourceLineNo">109</span><a id="line.109">    NA, // iload_1 = 27 (0x1b)</a>
<span class="sourceLineNo">110</span><a id="line.110">    NA, // iload_2 = 28 (0x1c)</a>
<span class="sourceLineNo">111</span><a id="line.111">    NA, // iload_3 = 29 (0x1d)</a>
<span class="sourceLineNo">112</span><a id="line.112">    NA, // lload_0 = 30 (0x1e)</a>
<span class="sourceLineNo">113</span><a id="line.113">    NA, // lload_1 = 31 (0x1f)</a>
<span class="sourceLineNo">114</span><a id="line.114">    NA, // lload_2 = 32 (0x20)</a>
<span class="sourceLineNo">115</span><a id="line.115">    NA, // lload_3 = 33 (0x21)</a>
<span class="sourceLineNo">116</span><a id="line.116">    NA, // fload_0 = 34 (0x22)</a>
<span class="sourceLineNo">117</span><a id="line.117">    NA, // fload_1 = 35 (0x23)</a>
<span class="sourceLineNo">118</span><a id="line.118">    NA, // fload_2 = 36 (0x24)</a>
<span class="sourceLineNo">119</span><a id="line.119">    NA, // fload_3 = 37 (0x25)</a>
<span class="sourceLineNo">120</span><a id="line.120">    NA, // dload_0 = 38 (0x26)</a>
<span class="sourceLineNo">121</span><a id="line.121">    NA, // dload_1 = 39 (0x27)</a>
<span class="sourceLineNo">122</span><a id="line.122">    NA, // dload_2 = 40 (0x28)</a>
<span class="sourceLineNo">123</span><a id="line.123">    NA, // dload_3 = 41 (0x29)</a>
<span class="sourceLineNo">124</span><a id="line.124">    NA, // aload_0 = 42 (0x2a)</a>
<span class="sourceLineNo">125</span><a id="line.125">    NA, // aload_1 = 43 (0x2b)</a>
<span class="sourceLineNo">126</span><a id="line.126">    NA, // aload_2 = 44 (0x2c)</a>
<span class="sourceLineNo">127</span><a id="line.127">    NA, // aload_3 = 45 (0x2d)</a>
<span class="sourceLineNo">128</span><a id="line.128">    -1, // iaload = 46 (0x2e)</a>
<span class="sourceLineNo">129</span><a id="line.129">    0, // laload = 47 (0x2f)</a>
<span class="sourceLineNo">130</span><a id="line.130">    -1, // faload = 48 (0x30)</a>
<span class="sourceLineNo">131</span><a id="line.131">    0, // daload = 49 (0x31)</a>
<span class="sourceLineNo">132</span><a id="line.132">    -1, // aaload = 50 (0x32)</a>
<span class="sourceLineNo">133</span><a id="line.133">    -1, // baload = 51 (0x33)</a>
<span class="sourceLineNo">134</span><a id="line.134">    -1, // caload = 52 (0x34)</a>
<span class="sourceLineNo">135</span><a id="line.135">    -1, // saload = 53 (0x35)</a>
<span class="sourceLineNo">136</span><a id="line.136">    -1, // istore = 54 (0x36)</a>
<span class="sourceLineNo">137</span><a id="line.137">    -2, // lstore = 55 (0x37)</a>
<span class="sourceLineNo">138</span><a id="line.138">    -1, // fstore = 56 (0x38)</a>
<span class="sourceLineNo">139</span><a id="line.139">    -2, // dstore = 57 (0x39)</a>
<span class="sourceLineNo">140</span><a id="line.140">    -1, // astore = 58 (0x3a)</a>
<span class="sourceLineNo">141</span><a id="line.141">    NA, // istore_0 = 59 (0x3b)</a>
<span class="sourceLineNo">142</span><a id="line.142">    NA, // istore_1 = 60 (0x3c)</a>
<span class="sourceLineNo">143</span><a id="line.143">    NA, // istore_2 = 61 (0x3d)</a>
<span class="sourceLineNo">144</span><a id="line.144">    NA, // istore_3 = 62 (0x3e)</a>
<span class="sourceLineNo">145</span><a id="line.145">    NA, // lstore_0 = 63 (0x3f)</a>
<span class="sourceLineNo">146</span><a id="line.146">    NA, // lstore_1 = 64 (0x40)</a>
<span class="sourceLineNo">147</span><a id="line.147">    NA, // lstore_2 = 65 (0x41)</a>
<span class="sourceLineNo">148</span><a id="line.148">    NA, // lstore_3 = 66 (0x42)</a>
<span class="sourceLineNo">149</span><a id="line.149">    NA, // fstore_0 = 67 (0x43)</a>
<span class="sourceLineNo">150</span><a id="line.150">    NA, // fstore_1 = 68 (0x44)</a>
<span class="sourceLineNo">151</span><a id="line.151">    NA, // fstore_2 = 69 (0x45)</a>
<span class="sourceLineNo">152</span><a id="line.152">    NA, // fstore_3 = 70 (0x46)</a>
<span class="sourceLineNo">153</span><a id="line.153">    NA, // dstore_0 = 71 (0x47)</a>
<span class="sourceLineNo">154</span><a id="line.154">    NA, // dstore_1 = 72 (0x48)</a>
<span class="sourceLineNo">155</span><a id="line.155">    NA, // dstore_2 = 73 (0x49)</a>
<span class="sourceLineNo">156</span><a id="line.156">    NA, // dstore_3 = 74 (0x4a)</a>
<span class="sourceLineNo">157</span><a id="line.157">    NA, // astore_0 = 75 (0x4b)</a>
<span class="sourceLineNo">158</span><a id="line.158">    NA, // astore_1 = 76 (0x4c)</a>
<span class="sourceLineNo">159</span><a id="line.159">    NA, // astore_2 = 77 (0x4d)</a>
<span class="sourceLineNo">160</span><a id="line.160">    NA, // astore_3 = 78 (0x4e)</a>
<span class="sourceLineNo">161</span><a id="line.161">    -3, // iastore = 79 (0x4f)</a>
<span class="sourceLineNo">162</span><a id="line.162">    -4, // lastore = 80 (0x50)</a>
<span class="sourceLineNo">163</span><a id="line.163">    -3, // fastore = 81 (0x51)</a>
<span class="sourceLineNo">164</span><a id="line.164">    -4, // dastore = 82 (0x52)</a>
<span class="sourceLineNo">165</span><a id="line.165">    -3, // aastore = 83 (0x53)</a>
<span class="sourceLineNo">166</span><a id="line.166">    -3, // bastore = 84 (0x54)</a>
<span class="sourceLineNo">167</span><a id="line.167">    -3, // castore = 85 (0x55)</a>
<span class="sourceLineNo">168</span><a id="line.168">    -3, // sastore = 86 (0x56)</a>
<span class="sourceLineNo">169</span><a id="line.169">    -1, // pop = 87 (0x57)</a>
<span class="sourceLineNo">170</span><a id="line.170">    -2, // pop2 = 88 (0x58)</a>
<span class="sourceLineNo">171</span><a id="line.171">    1, // dup = 89 (0x59)</a>
<span class="sourceLineNo">172</span><a id="line.172">    1, // dup_x1 = 90 (0x5a)</a>
<span class="sourceLineNo">173</span><a id="line.173">    1, // dup_x2 = 91 (0x5b)</a>
<span class="sourceLineNo">174</span><a id="line.174">    2, // dup2 = 92 (0x5c)</a>
<span class="sourceLineNo">175</span><a id="line.175">    2, // dup2_x1 = 93 (0x5d)</a>
<span class="sourceLineNo">176</span><a id="line.176">    2, // dup2_x2 = 94 (0x5e)</a>
<span class="sourceLineNo">177</span><a id="line.177">    0, // swap = 95 (0x5f)</a>
<span class="sourceLineNo">178</span><a id="line.178">    -1, // iadd = 96 (0x60)</a>
<span class="sourceLineNo">179</span><a id="line.179">    -2, // ladd = 97 (0x61)</a>
<span class="sourceLineNo">180</span><a id="line.180">    -1, // fadd = 98 (0x62)</a>
<span class="sourceLineNo">181</span><a id="line.181">    -2, // dadd = 99 (0x63)</a>
<span class="sourceLineNo">182</span><a id="line.182">    -1, // isub = 100 (0x64)</a>
<span class="sourceLineNo">183</span><a id="line.183">    -2, // lsub = 101 (0x65)</a>
<span class="sourceLineNo">184</span><a id="line.184">    -1, // fsub = 102 (0x66)</a>
<span class="sourceLineNo">185</span><a id="line.185">    -2, // dsub = 103 (0x67)</a>
<span class="sourceLineNo">186</span><a id="line.186">    -1, // imul = 104 (0x68)</a>
<span class="sourceLineNo">187</span><a id="line.187">    -2, // lmul = 105 (0x69)</a>
<span class="sourceLineNo">188</span><a id="line.188">    -1, // fmul = 106 (0x6a)</a>
<span class="sourceLineNo">189</span><a id="line.189">    -2, // dmul = 107 (0x6b)</a>
<span class="sourceLineNo">190</span><a id="line.190">    -1, // idiv = 108 (0x6c)</a>
<span class="sourceLineNo">191</span><a id="line.191">    -2, // ldiv = 109 (0x6d)</a>
<span class="sourceLineNo">192</span><a id="line.192">    -1, // fdiv = 110 (0x6e)</a>
<span class="sourceLineNo">193</span><a id="line.193">    -2, // ddiv = 111 (0x6f)</a>
<span class="sourceLineNo">194</span><a id="line.194">    -1, // irem = 112 (0x70)</a>
<span class="sourceLineNo">195</span><a id="line.195">    -2, // lrem = 113 (0x71)</a>
<span class="sourceLineNo">196</span><a id="line.196">    -1, // frem = 114 (0x72)</a>
<span class="sourceLineNo">197</span><a id="line.197">    -2, // drem = 115 (0x73)</a>
<span class="sourceLineNo">198</span><a id="line.198">    0, // ineg = 116 (0x74)</a>
<span class="sourceLineNo">199</span><a id="line.199">    0, // lneg = 117 (0x75)</a>
<span class="sourceLineNo">200</span><a id="line.200">    0, // fneg = 118 (0x76)</a>
<span class="sourceLineNo">201</span><a id="line.201">    0, // dneg = 119 (0x77)</a>
<span class="sourceLineNo">202</span><a id="line.202">    -1, // ishl = 120 (0x78)</a>
<span class="sourceLineNo">203</span><a id="line.203">    -1, // lshl = 121 (0x79)</a>
<span class="sourceLineNo">204</span><a id="line.204">    -1, // ishr = 122 (0x7a)</a>
<span class="sourceLineNo">205</span><a id="line.205">    -1, // lshr = 123 (0x7b)</a>
<span class="sourceLineNo">206</span><a id="line.206">    -1, // iushr = 124 (0x7c)</a>
<span class="sourceLineNo">207</span><a id="line.207">    -1, // lushr = 125 (0x7d)</a>
<span class="sourceLineNo">208</span><a id="line.208">    -1, // iand = 126 (0x7e)</a>
<span class="sourceLineNo">209</span><a id="line.209">    -2, // land = 127 (0x7f)</a>
<span class="sourceLineNo">210</span><a id="line.210">    -1, // ior = 128 (0x80)</a>
<span class="sourceLineNo">211</span><a id="line.211">    -2, // lor = 129 (0x81)</a>
<span class="sourceLineNo">212</span><a id="line.212">    -1, // ixor = 130 (0x82)</a>
<span class="sourceLineNo">213</span><a id="line.213">    -2, // lxor = 131 (0x83)</a>
<span class="sourceLineNo">214</span><a id="line.214">    0, // iinc = 132 (0x84)</a>
<span class="sourceLineNo">215</span><a id="line.215">    1, // i2l = 133 (0x85)</a>
<span class="sourceLineNo">216</span><a id="line.216">    0, // i2f = 134 (0x86)</a>
<span class="sourceLineNo">217</span><a id="line.217">    1, // i2d = 135 (0x87)</a>
<span class="sourceLineNo">218</span><a id="line.218">    -1, // l2i = 136 (0x88)</a>
<span class="sourceLineNo">219</span><a id="line.219">    -1, // l2f = 137 (0x89)</a>
<span class="sourceLineNo">220</span><a id="line.220">    0, // l2d = 138 (0x8a)</a>
<span class="sourceLineNo">221</span><a id="line.221">    0, // f2i = 139 (0x8b)</a>
<span class="sourceLineNo">222</span><a id="line.222">    1, // f2l = 140 (0x8c)</a>
<span class="sourceLineNo">223</span><a id="line.223">    1, // f2d = 141 (0x8d)</a>
<span class="sourceLineNo">224</span><a id="line.224">    -1, // d2i = 142 (0x8e)</a>
<span class="sourceLineNo">225</span><a id="line.225">    0, // d2l = 143 (0x8f)</a>
<span class="sourceLineNo">226</span><a id="line.226">    -1, // d2f = 144 (0x90)</a>
<span class="sourceLineNo">227</span><a id="line.227">    0, // i2b = 145 (0x91)</a>
<span class="sourceLineNo">228</span><a id="line.228">    0, // i2c = 146 (0x92)</a>
<span class="sourceLineNo">229</span><a id="line.229">    0, // i2s = 147 (0x93)</a>
<span class="sourceLineNo">230</span><a id="line.230">    -3, // lcmp = 148 (0x94)</a>
<span class="sourceLineNo">231</span><a id="line.231">    -1, // fcmpl = 149 (0x95)</a>
<span class="sourceLineNo">232</span><a id="line.232">    -1, // fcmpg = 150 (0x96)</a>
<span class="sourceLineNo">233</span><a id="line.233">    -3, // dcmpl = 151 (0x97)</a>
<span class="sourceLineNo">234</span><a id="line.234">    -3, // dcmpg = 152 (0x98)</a>
<span class="sourceLineNo">235</span><a id="line.235">    -1, // ifeq = 153 (0x99)</a>
<span class="sourceLineNo">236</span><a id="line.236">    -1, // ifne = 154 (0x9a)</a>
<span class="sourceLineNo">237</span><a id="line.237">    -1, // iflt = 155 (0x9b)</a>
<span class="sourceLineNo">238</span><a id="line.238">    -1, // ifge = 156 (0x9c)</a>
<span class="sourceLineNo">239</span><a id="line.239">    -1, // ifgt = 157 (0x9d)</a>
<span class="sourceLineNo">240</span><a id="line.240">    -1, // ifle = 158 (0x9e)</a>
<span class="sourceLineNo">241</span><a id="line.241">    -2, // if_icmpeq = 159 (0x9f)</a>
<span class="sourceLineNo">242</span><a id="line.242">    -2, // if_icmpne = 160 (0xa0)</a>
<span class="sourceLineNo">243</span><a id="line.243">    -2, // if_icmplt = 161 (0xa1)</a>
<span class="sourceLineNo">244</span><a id="line.244">    -2, // if_icmpge = 162 (0xa2)</a>
<span class="sourceLineNo">245</span><a id="line.245">    -2, // if_icmpgt = 163 (0xa3)</a>
<span class="sourceLineNo">246</span><a id="line.246">    -2, // if_icmple = 164 (0xa4)</a>
<span class="sourceLineNo">247</span><a id="line.247">    -2, // if_acmpeq = 165 (0xa5)</a>
<span class="sourceLineNo">248</span><a id="line.248">    -2, // if_acmpne = 166 (0xa6)</a>
<span class="sourceLineNo">249</span><a id="line.249">    0, // goto = 167 (0xa7)</a>
<span class="sourceLineNo">250</span><a id="line.250">    1, // jsr = 168 (0xa8)</a>
<span class="sourceLineNo">251</span><a id="line.251">    0, // ret = 169 (0xa9)</a>
<span class="sourceLineNo">252</span><a id="line.252">    -1, // tableswitch = 170 (0xaa)</a>
<span class="sourceLineNo">253</span><a id="line.253">    -1, // lookupswitch = 171 (0xab)</a>
<span class="sourceLineNo">254</span><a id="line.254">    -1, // ireturn = 172 (0xac)</a>
<span class="sourceLineNo">255</span><a id="line.255">    -2, // lreturn = 173 (0xad)</a>
<span class="sourceLineNo">256</span><a id="line.256">    -1, // freturn = 174 (0xae)</a>
<span class="sourceLineNo">257</span><a id="line.257">    -2, // dreturn = 175 (0xaf)</a>
<span class="sourceLineNo">258</span><a id="line.258">    -1, // areturn = 176 (0xb0)</a>
<span class="sourceLineNo">259</span><a id="line.259">    0, // return = 177 (0xb1)</a>
<span class="sourceLineNo">260</span><a id="line.260">    NA, // getstatic = 178 (0xb2)</a>
<span class="sourceLineNo">261</span><a id="line.261">    NA, // putstatic = 179 (0xb3)</a>
<span class="sourceLineNo">262</span><a id="line.262">    NA, // getfield = 180 (0xb4)</a>
<span class="sourceLineNo">263</span><a id="line.263">    NA, // putfield = 181 (0xb5)</a>
<span class="sourceLineNo">264</span><a id="line.264">    NA, // invokevirtual = 182 (0xb6)</a>
<span class="sourceLineNo">265</span><a id="line.265">    NA, // invokespecial = 183 (0xb7)</a>
<span class="sourceLineNo">266</span><a id="line.266">    NA, // invokestatic = 184 (0xb8)</a>
<span class="sourceLineNo">267</span><a id="line.267">    NA, // invokeinterface = 185 (0xb9)</a>
<span class="sourceLineNo">268</span><a id="line.268">    NA, // invokedynamic = 186 (0xba)</a>
<span class="sourceLineNo">269</span><a id="line.269">    1, // new = 187 (0xbb)</a>
<span class="sourceLineNo">270</span><a id="line.270">    0, // newarray = 188 (0xbc)</a>
<span class="sourceLineNo">271</span><a id="line.271">    0, // anewarray = 189 (0xbd)</a>
<span class="sourceLineNo">272</span><a id="line.272">    0, // arraylength = 190 (0xbe)</a>
<span class="sourceLineNo">273</span><a id="line.273">    NA, // athrow = 191 (0xbf)</a>
<span class="sourceLineNo">274</span><a id="line.274">    0, // checkcast = 192 (0xc0)</a>
<span class="sourceLineNo">275</span><a id="line.275">    0, // instanceof = 193 (0xc1)</a>
<span class="sourceLineNo">276</span><a id="line.276">    -1, // monitorenter = 194 (0xc2)</a>
<span class="sourceLineNo">277</span><a id="line.277">    -1, // monitorexit = 195 (0xc3)</a>
<span class="sourceLineNo">278</span><a id="line.278">    NA, // wide = 196 (0xc4)</a>
<span class="sourceLineNo">279</span><a id="line.279">    NA, // multianewarray = 197 (0xc5)</a>
<span class="sourceLineNo">280</span><a id="line.280">    -1, // ifnull = 198 (0xc6)</a>
<span class="sourceLineNo">281</span><a id="line.281">    -1, // ifnonnull = 199 (0xc7)</a>
<span class="sourceLineNo">282</span><a id="line.282">    NA, // goto_w = 200 (0xc8)</a>
<span class="sourceLineNo">283</span><a id="line.283">    NA // jsr_w = 201 (0xc9)</a>
<span class="sourceLineNo">284</span><a id="line.284">  };</a>
<span class="sourceLineNo">285</span><a id="line.285"></a>
<span class="sourceLineNo">286</span><a id="line.286">  /** Where the constants used in this MethodWriter must be stored. */</a>
<span class="sourceLineNo">287</span><a id="line.287">  private final SymbolTable symbolTable;</a>
<span class="sourceLineNo">288</span><a id="line.288"></a>
<span class="sourceLineNo">289</span><a id="line.289">  // Note: fields are ordered as in the method_info structure, and those related to attributes are</a>
<span class="sourceLineNo">290</span><a id="line.290">  // ordered as in Section 4.7 of the JVMS.</a>
<span class="sourceLineNo">291</span><a id="line.291"></a>
<span class="sourceLineNo">292</span><a id="line.292">  /**</a>
<span class="sourceLineNo">293</span><a id="line.293">   * The access_flags field of the method_info JVMS structure. This field can contain ASM specific</a>
<span class="sourceLineNo">294</span><a id="line.294">   * access flags, such as {@link Opcodes#ACC_DEPRECATED}, which are removed when generating the</a>
<span class="sourceLineNo">295</span><a id="line.295">   * ClassFile structure.</a>
<span class="sourceLineNo">296</span><a id="line.296">   */</a>
<span class="sourceLineNo">297</span><a id="line.297">  private final int accessFlags;</a>
<span class="sourceLineNo">298</span><a id="line.298"></a>
<span class="sourceLineNo">299</span><a id="line.299">  /** The name_index field of the method_info JVMS structure. */</a>
<span class="sourceLineNo">300</span><a id="line.300">  private final int nameIndex;</a>
<span class="sourceLineNo">301</span><a id="line.301"></a>
<span class="sourceLineNo">302</span><a id="line.302">  /** The descriptor_index field of the method_info JVMS structure. */</a>
<span class="sourceLineNo">303</span><a id="line.303">  private final int descriptorIndex;</a>
<span class="sourceLineNo">304</span><a id="line.304"></a>
<span class="sourceLineNo">305</span><a id="line.305">  /** The descriptor of this method. */</a>
<span class="sourceLineNo">306</span><a id="line.306">  private final String descriptor;</a>
<span class="sourceLineNo">307</span><a id="line.307"></a>
<span class="sourceLineNo">308</span><a id="line.308">  // Code attribute fields and sub attributes:</a>
<span class="sourceLineNo">309</span><a id="line.309"></a>
<span class="sourceLineNo">310</span><a id="line.310">  /** The max_stack field of the Code attribute. */</a>
<span class="sourceLineNo">311</span><a id="line.311">  private int maxStack;</a>
<span class="sourceLineNo">312</span><a id="line.312"></a>
<span class="sourceLineNo">313</span><a id="line.313">  /** The max_locals field of the Code attribute. */</a>
<span class="sourceLineNo">314</span><a id="line.314">  private int maxLocals;</a>
<span class="sourceLineNo">315</span><a id="line.315"></a>
<span class="sourceLineNo">316</span><a id="line.316">  /** The 'code' field of the Code attribute. */</a>
<span class="sourceLineNo">317</span><a id="line.317">  private final ByteVector code = new ByteVector();</a>
<span class="sourceLineNo">318</span><a id="line.318"></a>
<span class="sourceLineNo">319</span><a id="line.319">  /**</a>
<span class="sourceLineNo">320</span><a id="line.320">   * The first element in the exception handler list (used to generate the exception_table of the</a>
<span class="sourceLineNo">321</span><a id="line.321">   * Code attribute). The next ones can be accessed with the {@link Handler#nextHandler} field. May</a>
<span class="sourceLineNo">322</span><a id="line.322">   * be &lt;tt&gt;null&lt;/tt&gt;.</a>
<span class="sourceLineNo">323</span><a id="line.323">   */</a>
<span class="sourceLineNo">324</span><a id="line.324">  private Handler firstHandler;</a>
<span class="sourceLineNo">325</span><a id="line.325"></a>
<span class="sourceLineNo">326</span><a id="line.326">  /**</a>
<span class="sourceLineNo">327</span><a id="line.327">   * The last element in the exception handler list (used to generate the exception_table of the</a>
<span class="sourceLineNo">328</span><a id="line.328">   * Code attribute). The next ones can be accessed with the {@link Handler#nextHandler} field. May</a>
<span class="sourceLineNo">329</span><a id="line.329">   * be &lt;tt&gt;null&lt;/tt&gt;.</a>
<span class="sourceLineNo">330</span><a id="line.330">   */</a>
<span class="sourceLineNo">331</span><a id="line.331">  private Handler lastHandler;</a>
<span class="sourceLineNo">332</span><a id="line.332"></a>
<span class="sourceLineNo">333</span><a id="line.333">  /** The line_number_table_length field of the LineNumberTable code attribute. */</a>
<span class="sourceLineNo">334</span><a id="line.334">  private int lineNumberTableLength;</a>
<span class="sourceLineNo">335</span><a id="line.335"></a>
<span class="sourceLineNo">336</span><a id="line.336">  /** The line_number_table array of the LineNumberTable code attribute, or &lt;tt&gt;null&lt;/tt&gt;. */</a>
<span class="sourceLineNo">337</span><a id="line.337">  private ByteVector lineNumberTable;</a>
<span class="sourceLineNo">338</span><a id="line.338"></a>
<span class="sourceLineNo">339</span><a id="line.339">  /** The local_variable_table_length field of the LocalVariableTable code attribute. */</a>
<span class="sourceLineNo">340</span><a id="line.340">  private int localVariableTableLength;</a>
<span class="sourceLineNo">341</span><a id="line.341"></a>
<span class="sourceLineNo">342</span><a id="line.342">  /** The local_variable_table array of the LocalVariableTable code attribute, or &lt;tt&gt;null&lt;/tt&gt;. */</a>
<span class="sourceLineNo">343</span><a id="line.343">  private ByteVector localVariableTable;</a>
<span class="sourceLineNo">344</span><a id="line.344"></a>
<span class="sourceLineNo">345</span><a id="line.345">  /** The local_variable_type_table_length field of the LocalVariableTypeTable code attribute. */</a>
<span class="sourceLineNo">346</span><a id="line.346">  private int localVariableTypeTableLength;</a>
<span class="sourceLineNo">347</span><a id="line.347"></a>
<span class="sourceLineNo">348</span><a id="line.348">  /**</a>
<span class="sourceLineNo">349</span><a id="line.349">   * The local_variable_type_table array of the LocalVariableTypeTable code attribute, or</a>
<span class="sourceLineNo">350</span><a id="line.350">   * &lt;tt&gt;null&lt;/tt&gt;.</a>
<span class="sourceLineNo">351</span><a id="line.351">   */</a>
<span class="sourceLineNo">352</span><a id="line.352">  private ByteVector localVariableTypeTable;</a>
<span class="sourceLineNo">353</span><a id="line.353"></a>
<span class="sourceLineNo">354</span><a id="line.354">  /** The number_of_entries field of the StackMapTable code attribute. */</a>
<span class="sourceLineNo">355</span><a id="line.355">  private int stackMapTableNumberOfEntries;</a>
<span class="sourceLineNo">356</span><a id="line.356"></a>
<span class="sourceLineNo">357</span><a id="line.357">  /** The 'entries' array of the StackMapTable code attribute. */</a>
<span class="sourceLineNo">358</span><a id="line.358">  private ByteVector stackMapTableEntries;</a>
<span class="sourceLineNo">359</span><a id="line.359"></a>
<span class="sourceLineNo">360</span><a id="line.360">  /**</a>
<span class="sourceLineNo">361</span><a id="line.361">   * The last runtime visible type annotation of the Code attribute. The previous ones can be</a>
<span class="sourceLineNo">362</span><a id="line.362">   * accessed with the {@link AnnotationWriter#previousAnnotation} field. May be &lt;tt&gt;null&lt;/tt&gt;.</a>
<span class="sourceLineNo">363</span><a id="line.363">   */</a>
<span class="sourceLineNo">364</span><a id="line.364">  private AnnotationWriter lastCodeRuntimeVisibleTypeAnnotation;</a>
<span class="sourceLineNo">365</span><a id="line.365"></a>
<span class="sourceLineNo">366</span><a id="line.366">  /**</a>
<span class="sourceLineNo">367</span><a id="line.367">   * The last runtime invisible type annotation of the Code attribute. The previous ones can be</a>
<span class="sourceLineNo">368</span><a id="line.368">   * accessed with the {@link AnnotationWriter#previousAnnotation} field. May be &lt;tt&gt;null&lt;/tt&gt;.</a>
<span class="sourceLineNo">369</span><a id="line.369">   */</a>
<span class="sourceLineNo">370</span><a id="line.370">  private AnnotationWriter lastCodeRuntimeInvisibleTypeAnnotation;</a>
<span class="sourceLineNo">371</span><a id="line.371"></a>
<span class="sourceLineNo">372</span><a id="line.372">  /**</a>
<span class="sourceLineNo">373</span><a id="line.373">   * The first non standard attribute of the Code attribute. The next ones can be accessed with the</a>
<span class="sourceLineNo">374</span><a id="line.374">   * {@link Attribute#nextAttribute} field. May be &lt;tt&gt;null&lt;/tt&gt;.</a>
<span class="sourceLineNo">375</span><a id="line.375">   *</a>
<span class="sourceLineNo">376</span><a id="line.376">   * &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt;: this list stores the attributes in the &lt;i&gt;reverse&lt;/i&gt; order of their visit.</a>
<span class="sourceLineNo">377</span><a id="line.377">   * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link</a>
<span class="sourceLineNo">378</span><a id="line.378">   * #putMethodInfo} method writes the attributes in the order defined by this list, i.e. in the</a>
<span class="sourceLineNo">379</span><a id="line.379">   * reverse order specified by the user.</a>
<span class="sourceLineNo">380</span><a id="line.380">   */</a>
<span class="sourceLineNo">381</span><a id="line.381">  private Attribute firstCodeAttribute;</a>
<span class="sourceLineNo">382</span><a id="line.382"></a>
<span class="sourceLineNo">383</span><a id="line.383">  // Other method_info attributes:</a>
<span class="sourceLineNo">384</span><a id="line.384"></a>
<span class="sourceLineNo">385</span><a id="line.385">  /** The number_of_exceptions field of the Exceptions attribute. */</a>
<span class="sourceLineNo">386</span><a id="line.386">  private final int numberOfExceptions;</a>
<span class="sourceLineNo">387</span><a id="line.387"></a>
<span class="sourceLineNo">388</span><a id="line.388">  /** The exception_index_table array of the Exceptions attribute, or &lt;tt&gt;null&lt;/tt&gt;. */</a>
<span class="sourceLineNo">389</span><a id="line.389">  private final int[] exceptionIndexTable;</a>
<span class="sourceLineNo">390</span><a id="line.390"></a>
<span class="sourceLineNo">391</span><a id="line.391">  /** The signature_index field of the Signature attribute. */</a>
<span class="sourceLineNo">392</span><a id="line.392">  private final int signatureIndex;</a>
<span class="sourceLineNo">393</span><a id="line.393"></a>
<span class="sourceLineNo">394</span><a id="line.394">  /**</a>
<span class="sourceLineNo">395</span><a id="line.395">   * The last runtime visible annotation of this method. The previous ones can be accessed with the</a>
<span class="sourceLineNo">396</span><a id="line.396">   * {@link AnnotationWriter#previousAnnotation} field. May be &lt;tt&gt;null&lt;/tt&gt;.</a>
<span class="sourceLineNo">397</span><a id="line.397">   */</a>
<span class="sourceLineNo">398</span><a id="line.398">  private AnnotationWriter lastRuntimeVisibleAnnotation;</a>
<span class="sourceLineNo">399</span><a id="line.399"></a>
<span class="sourceLineNo">400</span><a id="line.400">  /**</a>
<span class="sourceLineNo">401</span><a id="line.401">   * The last runtime invisible annotation of this method. The previous ones can be accessed with</a>
<span class="sourceLineNo">402</span><a id="line.402">   * the {@link AnnotationWriter#previousAnnotation} field. May be &lt;tt&gt;null&lt;/tt&gt;.</a>
<span class="sourceLineNo">403</span><a id="line.403">   */</a>
<span class="sourceLineNo">404</span><a id="line.404">  private AnnotationWriter lastRuntimeInvisibleAnnotation;</a>
<span class="sourceLineNo">405</span><a id="line.405"></a>
<span class="sourceLineNo">406</span><a id="line.406">  /** The number of method parameters that can have runtime visible annotations, or 0. */</a>
<span class="sourceLineNo">407</span><a id="line.407">  private int visibleAnnotableParameterCount;</a>
<span class="sourceLineNo">408</span><a id="line.408"></a>
<span class="sourceLineNo">409</span><a id="line.409">  /**</a>
<span class="sourceLineNo">410</span><a id="line.410">   * The runtime visible parameter annotations of this method. Each array element contains the last</a>
<span class="sourceLineNo">411</span><a id="line.411">   * annotation of a parameter (which can be &lt;tt&gt;null&lt;/tt&gt; - the previous ones can be accessed with</a>
<span class="sourceLineNo">412</span><a id="line.412">   * the {@link AnnotationWriter#previousAnnotation} field). May be &lt;tt&gt;null&lt;/tt&gt;.</a>
<span class="sourceLineNo">413</span><a id="line.413">   */</a>
<span class="sourceLineNo">414</span><a id="line.414">  private AnnotationWriter[] lastRuntimeVisibleParameterAnnotations;</a>
<span class="sourceLineNo">415</span><a id="line.415"></a>
<span class="sourceLineNo">416</span><a id="line.416">  /** The number of method parameters that can have runtime visible annotations, or 0. */</a>
<span class="sourceLineNo">417</span><a id="line.417">  private int invisibleAnnotableParameterCount;</a>
<span class="sourceLineNo">418</span><a id="line.418"></a>
<span class="sourceLineNo">419</span><a id="line.419">  /**</a>
<span class="sourceLineNo">420</span><a id="line.420">   * The runtime invisible parameter annotations of this method. Each array element contains the</a>
<span class="sourceLineNo">421</span><a id="line.421">   * last annotation of a parameter (which can be &lt;tt&gt;null&lt;/tt&gt; - the previous ones can be accessed</a>
<span class="sourceLineNo">422</span><a id="line.422">   * with the {@link AnnotationWriter#previousAnnotation} field). May be &lt;tt&gt;null&lt;/tt&gt;.</a>
<span class="sourceLineNo">423</span><a id="line.423">   */</a>
<span class="sourceLineNo">424</span><a id="line.424">  private AnnotationWriter[] lastRuntimeInvisibleParameterAnnotations;</a>
<span class="sourceLineNo">425</span><a id="line.425"></a>
<span class="sourceLineNo">426</span><a id="line.426">  /**</a>
<span class="sourceLineNo">427</span><a id="line.427">   * The last runtime visible type annotation of this method. The previous ones can be accessed with</a>
<span class="sourceLineNo">428</span><a id="line.428">   * the {@link AnnotationWriter#previousAnnotation} field. May be &lt;tt&gt;null&lt;/tt&gt;.</a>
<span class="sourceLineNo">429</span><a id="line.429">   */</a>
<span class="sourceLineNo">430</span><a id="line.430">  private AnnotationWriter lastRuntimeVisibleTypeAnnotation;</a>
<span class="sourceLineNo">431</span><a id="line.431"></a>
<span class="sourceLineNo">432</span><a id="line.432">  /**</a>
<span class="sourceLineNo">433</span><a id="line.433">   * The last runtime invisible type annotation of this method. The previous ones can be accessed</a>
<span class="sourceLineNo">434</span><a id="line.434">   * with the {@link AnnotationWriter#previousAnnotation} field. May be &lt;tt&gt;null&lt;/tt&gt;.</a>
<span class="sourceLineNo">435</span><a id="line.435">   */</a>
<span class="sourceLineNo">436</span><a id="line.436">  private AnnotationWriter lastRuntimeInvisibleTypeAnnotation;</a>
<span class="sourceLineNo">437</span><a id="line.437"></a>
<span class="sourceLineNo">438</span><a id="line.438">  /** The default_value field of the AnnotationDefault attribute, or &lt;tt&gt;null&lt;/tt&gt;. */</a>
<span class="sourceLineNo">439</span><a id="line.439">  private ByteVector defaultValue;</a>
<span class="sourceLineNo">440</span><a id="line.440"></a>
<span class="sourceLineNo">441</span><a id="line.441">  /** The parameters_count field of the MethodParameters attribute. */</a>
<span class="sourceLineNo">442</span><a id="line.442">  private int parametersCount;</a>
<span class="sourceLineNo">443</span><a id="line.443"></a>
<span class="sourceLineNo">444</span><a id="line.444">  /** The 'parameters' array of the MethodParameters attribute, or &lt;tt&gt;null&lt;/tt&gt;. */</a>
<span class="sourceLineNo">445</span><a id="line.445">  private ByteVector parameters;</a>
<span class="sourceLineNo">446</span><a id="line.446"></a>
<span class="sourceLineNo">447</span><a id="line.447">  /**</a>
<span class="sourceLineNo">448</span><a id="line.448">   * The first non standard attribute of this method. The next ones can be accessed with the {@link</a>
<span class="sourceLineNo">449</span><a id="line.449">   * Attribute#nextAttribute} field. May be &lt;tt&gt;null&lt;/tt&gt;.</a>
<span class="sourceLineNo">450</span><a id="line.450">   *</a>
<span class="sourceLineNo">451</span><a id="line.451">   * &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt;: this list stores the attributes in the &lt;i&gt;reverse&lt;/i&gt; order of their visit.</a>
<span class="sourceLineNo">452</span><a id="line.452">   * firstAttribute is actually the last attribute visited in {@link #visitAttribute}. The {@link</a>
<span class="sourceLineNo">453</span><a id="line.453">   * #putMethodInfo} method writes the attributes in the order defined by this list, i.e. in the</a>
<span class="sourceLineNo">454</span><a id="line.454">   * reverse order specified by the user.</a>
<span class="sourceLineNo">455</span><a id="line.455">   */</a>
<span class="sourceLineNo">456</span><a id="line.456">  private Attribute firstAttribute;</a>
<span class="sourceLineNo">457</span><a id="line.457"></a>
<span class="sourceLineNo">458</span><a id="line.458">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">459</span><a id="line.459">  // Fields used to compute the maximum stack size and number of locals, and the stack map frames</a>
<span class="sourceLineNo">460</span><a id="line.460">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">461</span><a id="line.461"></a>
<span class="sourceLineNo">462</span><a id="line.462">  /**</a>
<span class="sourceLineNo">463</span><a id="line.463">   * Indicates what must be computed. Must be one of {@link #COMPUTE_ALL_FRAMES}, {@link</a>
<span class="sourceLineNo">464</span><a id="line.464">   * #COMPUTE_INSERTED_FRAMES}, {@link #COMPUTE_MAX_STACK_AND_LOCAL} or {@link #COMPUTE_NOTHING}.</a>
<span class="sourceLineNo">465</span><a id="line.465">   */</a>
<span class="sourceLineNo">466</span><a id="line.466">  private final int compute;</a>
<span class="sourceLineNo">467</span><a id="line.467"></a>
<span class="sourceLineNo">468</span><a id="line.468">  /**</a>
<span class="sourceLineNo">469</span><a id="line.469">   * The first basic block of the method. The next ones (in bytecode offset order) can be accessed</a>
<span class="sourceLineNo">470</span><a id="line.470">   * with the {@link Label#nextBasicBlock} field.</a>
<span class="sourceLineNo">471</span><a id="line.471">   */</a>
<span class="sourceLineNo">472</span><a id="line.472">  private Label firstBasicBlock;</a>
<span class="sourceLineNo">473</span><a id="line.473"></a>
<span class="sourceLineNo">474</span><a id="line.474">  /**</a>
<span class="sourceLineNo">475</span><a id="line.475">   * The last basic block of the method (in bytecode offset order). This field is updated each time</a>
<span class="sourceLineNo">476</span><a id="line.476">   * a basic block is encountered, and is used to append it at the end of the basic block list.</a>
<span class="sourceLineNo">477</span><a id="line.477">   */</a>
<span class="sourceLineNo">478</span><a id="line.478">  private Label lastBasicBlock;</a>
<span class="sourceLineNo">479</span><a id="line.479"></a>
<span class="sourceLineNo">480</span><a id="line.480">  /**</a>
<span class="sourceLineNo">481</span><a id="line.481">   * The current basic block, i.e. the basic block of the last visited instruction. When {@link</a>
<span class="sourceLineNo">482</span><a id="line.482">   * #compute} is equal to {@link #COMPUTE_MAX_STACK_AND_LOCAL} or {@link #COMPUTE_ALL_FRAMES}, this</a>
<span class="sourceLineNo">483</span><a id="line.483">   * field is &lt;tt&gt;null&lt;/tt&gt; for unreachable code. When {@link #compute} is equal to {@link</a>
<span class="sourceLineNo">484</span><a id="line.484">   * #COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES} or {@link #COMPUTE_INSERTED_FRAMES}, this field stays</a>
<span class="sourceLineNo">485</span><a id="line.485">   * unchanged throughout the whole method (i.e. the whole code is seen as a single basic block;</a>
<span class="sourceLineNo">486</span><a id="line.486">   * indeed, the existing frames are sufficient by hypothesis to compute any intermediate frame -</a>
<span class="sourceLineNo">487</span><a id="line.487">   * and the maximum stack size as well - without using any control flow graph).</a>
<span class="sourceLineNo">488</span><a id="line.488">   */</a>
<span class="sourceLineNo">489</span><a id="line.489">  private Label currentBasicBlock;</a>
<span class="sourceLineNo">490</span><a id="line.490"></a>
<span class="sourceLineNo">491</span><a id="line.491">  /**</a>
<span class="sourceLineNo">492</span><a id="line.492">   * The relative stack size after the last visited instruction. This size is relative to the</a>
<span class="sourceLineNo">493</span><a id="line.493">   * beginning of {@link #currentBasicBlock}, i.e. the true stack size after the last visited</a>
<span class="sourceLineNo">494</span><a id="line.494">   * instruction is equal to the {@link Label#inputStackSize} of the current basic block plus {@link</a>
<span class="sourceLineNo">495</span><a id="line.495">   * #relativeStackSize}. When {@link #compute} is equal to {@link</a>
<span class="sourceLineNo">496</span><a id="line.496">   * #COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link #currentBasicBlock} is always the start of</a>
<span class="sourceLineNo">497</span><a id="line.497">   * the method, so this relative size is also equal to the absolute stack size after the last</a>
<span class="sourceLineNo">498</span><a id="line.498">   * visited instruction.</a>
<span class="sourceLineNo">499</span><a id="line.499">   */</a>
<span class="sourceLineNo">500</span><a id="line.500">  private int relativeStackSize;</a>
<span class="sourceLineNo">501</span><a id="line.501"></a>
<span class="sourceLineNo">502</span><a id="line.502">  /**</a>
<span class="sourceLineNo">503</span><a id="line.503">   * The maximum relative stack size after the last visited instruction. This size is relative to</a>
<span class="sourceLineNo">504</span><a id="line.504">   * the beginning of {@link #currentBasicBlock}, i.e. the true maximum stack size after the last</a>
<span class="sourceLineNo">505</span><a id="line.505">   * visited instruction is equal to the {@link Label#inputStackSize} of the current basic block</a>
<span class="sourceLineNo">506</span><a id="line.506">   * plus {@link #maxRelativeStackSize}.When {@link #compute} is equal to {@link</a>
<span class="sourceLineNo">507</span><a id="line.507">   * #COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link #currentBasicBlock} is always the start of</a>
<span class="sourceLineNo">508</span><a id="line.508">   * the method, so this relative size is also equal to the absolute maximum stack size after the</a>
<span class="sourceLineNo">509</span><a id="line.509">   * last visited instruction.</a>
<span class="sourceLineNo">510</span><a id="line.510">   */</a>
<span class="sourceLineNo">511</span><a id="line.511">  private int maxRelativeStackSize;</a>
<span class="sourceLineNo">512</span><a id="line.512"></a>
<span class="sourceLineNo">513</span><a id="line.513">  /** The number of local variables in the last visited stack map frame. */</a>
<span class="sourceLineNo">514</span><a id="line.514">  private int currentLocals;</a>
<span class="sourceLineNo">515</span><a id="line.515"></a>
<span class="sourceLineNo">516</span><a id="line.516">  /** The bytecode offset of the last frame that was written in {@link #stackMapTableEntries}. */</a>
<span class="sourceLineNo">517</span><a id="line.517">  private int previousFrameOffset;</a>
<span class="sourceLineNo">518</span><a id="line.518"></a>
<span class="sourceLineNo">519</span><a id="line.519">  /**</a>
<span class="sourceLineNo">520</span><a id="line.520">   * The last frame that was written in {@link #stackMapTableEntries}. This field has the same</a>
<span class="sourceLineNo">521</span><a id="line.521">   * format as {@link #currentFrame}.</a>
<span class="sourceLineNo">522</span><a id="line.522">   */</a>
<span class="sourceLineNo">523</span><a id="line.523">  private int[] previousFrame;</a>
<span class="sourceLineNo">524</span><a id="line.524"></a>
<span class="sourceLineNo">525</span><a id="line.525">  /**</a>
<span class="sourceLineNo">526</span><a id="line.526">   * The current stack map frame. The first element contains the bytecode offset of the instruction</a>
<span class="sourceLineNo">527</span><a id="line.527">   * to which the frame corresponds, the second element is the number of locals and the third one is</a>
<span class="sourceLineNo">528</span><a id="line.528">   * the number of stack elements. The local variables start at index 3 and are followed by the</a>
<span class="sourceLineNo">529</span><a id="line.529">   * operand stack elements. In summary frame[0] = offset, frame[1] = nLocal, frame[2] = nStack,</a>
<span class="sourceLineNo">530</span><a id="line.530">   * frame[3] = nLocal. Local variables and operand stack entries contain abstract types, as defined</a>
<span class="sourceLineNo">531</span><a id="line.531">   * in {@link Frame}, but restricted to {@link Frame#CONSTANT_KIND}, {@link Frame#REFERENCE_KIND}</a>
<span class="sourceLineNo">532</span><a id="line.532">   * or {@link Frame#UNINITIALIZED_KIND} abstract types. Long and double types use only one array</a>
<span class="sourceLineNo">533</span><a id="line.533">   * entry.</a>
<span class="sourceLineNo">534</span><a id="line.534">   */</a>
<span class="sourceLineNo">535</span><a id="line.535">  private int[] currentFrame;</a>
<span class="sourceLineNo">536</span><a id="line.536"></a>
<span class="sourceLineNo">537</span><a id="line.537">  /** Whether this method contains subroutines. */</a>
<span class="sourceLineNo">538</span><a id="line.538">  private boolean hasSubroutines;</a>
<span class="sourceLineNo">539</span><a id="line.539"></a>
<span class="sourceLineNo">540</span><a id="line.540">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">541</span><a id="line.541">  // Other miscellaneous status fields</a>
<span class="sourceLineNo">542</span><a id="line.542">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">543</span><a id="line.543"></a>
<span class="sourceLineNo">544</span><a id="line.544">  /** Whether the bytecode of this method contains ASM specific instructions. */</a>
<span class="sourceLineNo">545</span><a id="line.545">  private boolean hasAsmInstructions;</a>
<span class="sourceLineNo">546</span><a id="line.546"></a>
<span class="sourceLineNo">547</span><a id="line.547">  /**</a>
<span class="sourceLineNo">548</span><a id="line.548">   * The start offset of the last visited instruction. Used to set the offset field of type</a>
<span class="sourceLineNo">549</span><a id="line.549">   * annotations of type 'offset_target' (see &lt;a</a>
<span class="sourceLineNo">550</span><a id="line.550">   * href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.1"&gt;JVMS</a>
<span class="sourceLineNo">551</span><a id="line.551">   * 4.7.20.1&lt;/a&gt;).</a>
<span class="sourceLineNo">552</span><a id="line.552">   */</a>
<span class="sourceLineNo">553</span><a id="line.553">  private int lastBytecodeOffset;</a>
<span class="sourceLineNo">554</span><a id="line.554"></a>
<span class="sourceLineNo">555</span><a id="line.555">  /**</a>
<span class="sourceLineNo">556</span><a id="line.556">   * The offset in bytes in {@link SymbolTable#getSource} from which the method_info for this method</a>
<span class="sourceLineNo">557</span><a id="line.557">   * (excluding its first 6 bytes) must be copied, or 0.</a>
<span class="sourceLineNo">558</span><a id="line.558">   */</a>
<span class="sourceLineNo">559</span><a id="line.559">  private int sourceOffset;</a>
<span class="sourceLineNo">560</span><a id="line.560"></a>
<span class="sourceLineNo">561</span><a id="line.561">  /**</a>
<span class="sourceLineNo">562</span><a id="line.562">   * The length in bytes in {@link SymbolTable#getSource} which must be copied to get the</a>
<span class="sourceLineNo">563</span><a id="line.563">   * method_info for this method (excluding its first 6 bytes for access_flags, name_index and</a>
<span class="sourceLineNo">564</span><a id="line.564">   * descriptor_index).</a>
<span class="sourceLineNo">565</span><a id="line.565">   */</a>
<span class="sourceLineNo">566</span><a id="line.566">  private int sourceLength;</a>
<span class="sourceLineNo">567</span><a id="line.567"></a>
<span class="sourceLineNo">568</span><a id="line.568">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">569</span><a id="line.569">  // Constructor and accessors</a>
<span class="sourceLineNo">570</span><a id="line.570">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">571</span><a id="line.571"></a>
<span class="sourceLineNo">572</span><a id="line.572">  /**</a>
<span class="sourceLineNo">573</span><a id="line.573">   * Constructs a new {@link MethodWriter}.</a>
<span class="sourceLineNo">574</span><a id="line.574">   *</a>
<span class="sourceLineNo">575</span><a id="line.575">   * @param symbolTable where the constants used in this AnnotationWriter must be stored.</a>
<span class="sourceLineNo">576</span><a id="line.576">   * @param access the method's access flags (see {@link Opcodes}).</a>
<span class="sourceLineNo">577</span><a id="line.577">   * @param name the method's name.</a>
<span class="sourceLineNo">578</span><a id="line.578">   * @param descriptor the method's descriptor (see {@link Type}).</a>
<span class="sourceLineNo">579</span><a id="line.579">   * @param signature the method's signature. May be &lt;tt&gt;null&lt;/tt&gt;.</a>
<span class="sourceLineNo">580</span><a id="line.580">   * @param exceptions the internal names of the method's exceptions. May be &lt;tt&gt;null&lt;/tt&gt;.</a>
<span class="sourceLineNo">581</span><a id="line.581">   * @param compute indicates what must be computed (see #compute).</a>
<span class="sourceLineNo">582</span><a id="line.582">   */</a>
<span class="sourceLineNo">583</span><a id="line.583">  MethodWriter(</a>
<span class="sourceLineNo">584</span><a id="line.584">      final SymbolTable symbolTable,</a>
<span class="sourceLineNo">585</span><a id="line.585">      final int access,</a>
<span class="sourceLineNo">586</span><a id="line.586">      final String name,</a>
<span class="sourceLineNo">587</span><a id="line.587">      final String descriptor,</a>
<span class="sourceLineNo">588</span><a id="line.588">      final String signature,</a>
<span class="sourceLineNo">589</span><a id="line.589">      final String[] exceptions,</a>
<span class="sourceLineNo">590</span><a id="line.590">      final int compute) {</a>
<span class="sourceLineNo">591</span><a id="line.591">    super(Opcodes.ASM6);</a>
<span class="sourceLineNo">592</span><a id="line.592">    this.symbolTable = symbolTable;</a>
<span class="sourceLineNo">593</span><a id="line.593">    this.accessFlags = "&lt;init&gt;".equals(name) ? access | Constants.ACC_CONSTRUCTOR : access;</a>
<span class="sourceLineNo">594</span><a id="line.594">    this.nameIndex = symbolTable.addConstantUtf8(name);</a>
<span class="sourceLineNo">595</span><a id="line.595">    this.descriptorIndex = symbolTable.addConstantUtf8(descriptor);</a>
<span class="sourceLineNo">596</span><a id="line.596">    this.descriptor = descriptor;</a>
<span class="sourceLineNo">597</span><a id="line.597">    this.signatureIndex = signature == null ? 0 : symbolTable.addConstantUtf8(signature);</a>
<span class="sourceLineNo">598</span><a id="line.598">    if (exceptions != null &amp;&amp; exceptions.length &gt; 0) {</a>
<span class="sourceLineNo">599</span><a id="line.599">      numberOfExceptions = exceptions.length;</a>
<span class="sourceLineNo">600</span><a id="line.600">      this.exceptionIndexTable = new int[numberOfExceptions];</a>
<span class="sourceLineNo">601</span><a id="line.601">      for (int i = 0; i &lt; numberOfExceptions; ++i) {</a>
<span class="sourceLineNo">602</span><a id="line.602">        this.exceptionIndexTable[i] = symbolTable.addConstantClass(exceptions[i]).index;</a>
<span class="sourceLineNo">603</span><a id="line.603">      }</a>
<span class="sourceLineNo">604</span><a id="line.604">    } else {</a>
<span class="sourceLineNo">605</span><a id="line.605">      numberOfExceptions = 0;</a>
<span class="sourceLineNo">606</span><a id="line.606">      this.exceptionIndexTable = null;</a>
<span class="sourceLineNo">607</span><a id="line.607">    }</a>
<span class="sourceLineNo">608</span><a id="line.608">    this.compute = compute;</a>
<span class="sourceLineNo">609</span><a id="line.609">    if (compute != COMPUTE_NOTHING) {</a>
<span class="sourceLineNo">610</span><a id="line.610">      // Update maxLocals and currentLocals.</a>
<span class="sourceLineNo">611</span><a id="line.611">      int argumentsSize = Type.getArgumentsAndReturnSizes(descriptor) &gt;&gt; 2;</a>
<span class="sourceLineNo">612</span><a id="line.612">      if ((access &amp; Opcodes.ACC_STATIC) != 0) {</a>
<span class="sourceLineNo">613</span><a id="line.613">        --argumentsSize;</a>
<span class="sourceLineNo">614</span><a id="line.614">      }</a>
<span class="sourceLineNo">615</span><a id="line.615">      maxLocals = argumentsSize;</a>
<span class="sourceLineNo">616</span><a id="line.616">      currentLocals = argumentsSize;</a>
<span class="sourceLineNo">617</span><a id="line.617">      // Create and visit the label for the first basic block.</a>
<span class="sourceLineNo">618</span><a id="line.618">      firstBasicBlock = new Label();</a>
<span class="sourceLineNo">619</span><a id="line.619">      visitLabel(firstBasicBlock);</a>
<span class="sourceLineNo">620</span><a id="line.620">    }</a>
<span class="sourceLineNo">621</span><a id="line.621">  }</a>
<span class="sourceLineNo">622</span><a id="line.622"></a>
<span class="sourceLineNo">623</span><a id="line.623">  boolean hasFrames() {</a>
<span class="sourceLineNo">624</span><a id="line.624">    return stackMapTableNumberOfEntries &gt; 0;</a>
<span class="sourceLineNo">625</span><a id="line.625">  }</a>
<span class="sourceLineNo">626</span><a id="line.626"></a>
<span class="sourceLineNo">627</span><a id="line.627">  boolean hasAsmInstructions() {</a>
<span class="sourceLineNo">628</span><a id="line.628">    return hasAsmInstructions;</a>
<span class="sourceLineNo">629</span><a id="line.629">  }</a>
<span class="sourceLineNo">630</span><a id="line.630"></a>
<span class="sourceLineNo">631</span><a id="line.631">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">632</span><a id="line.632">  // Implementation of the MethodVisitor abstract class</a>
<span class="sourceLineNo">633</span><a id="line.633">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">634</span><a id="line.634"></a>
<span class="sourceLineNo">635</span><a id="line.635">  @Override</a>
<span class="sourceLineNo">636</span><a id="line.636">  public void visitParameter(final String name, final int access) {</a>
<span class="sourceLineNo">637</span><a id="line.637">    if (parameters == null) {</a>
<span class="sourceLineNo">638</span><a id="line.638">      parameters = new ByteVector();</a>
<span class="sourceLineNo">639</span><a id="line.639">    }</a>
<span class="sourceLineNo">640</span><a id="line.640">    ++parametersCount;</a>
<span class="sourceLineNo">641</span><a id="line.641">    parameters.putShort((name == null) ? 0 : symbolTable.addConstantUtf8(name)).putShort(access);</a>
<span class="sourceLineNo">642</span><a id="line.642">  }</a>
<span class="sourceLineNo">643</span><a id="line.643"></a>
<span class="sourceLineNo">644</span><a id="line.644">  @Override</a>
<span class="sourceLineNo">645</span><a id="line.645">  public AnnotationVisitor visitAnnotationDefault() {</a>
<span class="sourceLineNo">646</span><a id="line.646">    defaultValue = new ByteVector();</a>
<span class="sourceLineNo">647</span><a id="line.647">    return new AnnotationWriter(symbolTable, /* useNamedValues = */ false, defaultValue, null);</a>
<span class="sourceLineNo">648</span><a id="line.648">  }</a>
<span class="sourceLineNo">649</span><a id="line.649"></a>
<span class="sourceLineNo">650</span><a id="line.650">  @Override</a>
<span class="sourceLineNo">651</span><a id="line.651">  public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {</a>
<span class="sourceLineNo">652</span><a id="line.652">    // Create a ByteVector to hold an 'annotation' JVMS structure.</a>
<span class="sourceLineNo">653</span><a id="line.653">    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.</a>
<span class="sourceLineNo">654</span><a id="line.654">    ByteVector annotation = new ByteVector();</a>
<span class="sourceLineNo">655</span><a id="line.655">    // Write type_index and reserve space for num_element_value_pairs.</a>
<span class="sourceLineNo">656</span><a id="line.656">    annotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);</a>
<span class="sourceLineNo">657</span><a id="line.657">    if (visible) {</a>
<span class="sourceLineNo">658</span><a id="line.658">      return lastRuntimeVisibleAnnotation =</a>
<span class="sourceLineNo">659</span><a id="line.659">          new AnnotationWriter(symbolTable, annotation, lastRuntimeVisibleAnnotation);</a>
<span class="sourceLineNo">660</span><a id="line.660">    } else {</a>
<span class="sourceLineNo">661</span><a id="line.661">      return lastRuntimeInvisibleAnnotation =</a>
<span class="sourceLineNo">662</span><a id="line.662">          new AnnotationWriter(symbolTable, annotation, lastRuntimeInvisibleAnnotation);</a>
<span class="sourceLineNo">663</span><a id="line.663">    }</a>
<span class="sourceLineNo">664</span><a id="line.664">  }</a>
<span class="sourceLineNo">665</span><a id="line.665"></a>
<span class="sourceLineNo">666</span><a id="line.666">  @Override</a>
<span class="sourceLineNo">667</span><a id="line.667">  public AnnotationVisitor visitTypeAnnotation(</a>
<span class="sourceLineNo">668</span><a id="line.668">      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {</a>
<span class="sourceLineNo">669</span><a id="line.669">    // Create a ByteVector to hold a 'type_annotation' JVMS structure.</a>
<span class="sourceLineNo">670</span><a id="line.670">    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.</a>
<span class="sourceLineNo">671</span><a id="line.671">    ByteVector typeAnnotation = new ByteVector();</a>
<span class="sourceLineNo">672</span><a id="line.672">    // Write target_type, target_info, and target_path.</a>
<span class="sourceLineNo">673</span><a id="line.673">    TypeReference.putTarget(typeRef, typeAnnotation);</a>
<span class="sourceLineNo">674</span><a id="line.674">    TypePath.put(typePath, typeAnnotation);</a>
<span class="sourceLineNo">675</span><a id="line.675">    // Write type_index and reserve space for num_element_value_pairs.</a>
<span class="sourceLineNo">676</span><a id="line.676">    typeAnnotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);</a>
<span class="sourceLineNo">677</span><a id="line.677">    if (visible) {</a>
<span class="sourceLineNo">678</span><a id="line.678">      return lastRuntimeVisibleTypeAnnotation =</a>
<span class="sourceLineNo">679</span><a id="line.679">          new AnnotationWriter(symbolTable, typeAnnotation, lastRuntimeVisibleTypeAnnotation);</a>
<span class="sourceLineNo">680</span><a id="line.680">    } else {</a>
<span class="sourceLineNo">681</span><a id="line.681">      return lastRuntimeInvisibleTypeAnnotation =</a>
<span class="sourceLineNo">682</span><a id="line.682">          new AnnotationWriter(symbolTable, typeAnnotation, lastRuntimeInvisibleTypeAnnotation);</a>
<span class="sourceLineNo">683</span><a id="line.683">    }</a>
<span class="sourceLineNo">684</span><a id="line.684">  }</a>
<span class="sourceLineNo">685</span><a id="line.685"></a>
<span class="sourceLineNo">686</span><a id="line.686">  @Override</a>
<span class="sourceLineNo">687</span><a id="line.687">  public void visitAnnotableParameterCount(final int parameterCount, final boolean visible) {</a>
<span class="sourceLineNo">688</span><a id="line.688">    if (visible) {</a>
<span class="sourceLineNo">689</span><a id="line.689">      visibleAnnotableParameterCount = parameterCount;</a>
<span class="sourceLineNo">690</span><a id="line.690">    } else {</a>
<span class="sourceLineNo">691</span><a id="line.691">      invisibleAnnotableParameterCount = parameterCount;</a>
<span class="sourceLineNo">692</span><a id="line.692">    }</a>
<span class="sourceLineNo">693</span><a id="line.693">  }</a>
<span class="sourceLineNo">694</span><a id="line.694"></a>
<span class="sourceLineNo">695</span><a id="line.695">  @Override</a>
<span class="sourceLineNo">696</span><a id="line.696">  public AnnotationVisitor visitParameterAnnotation(</a>
<span class="sourceLineNo">697</span><a id="line.697">      final int parameter, final String annotationDescriptor, final boolean visible) {</a>
<span class="sourceLineNo">698</span><a id="line.698">    // Create a ByteVector to hold an 'annotation' JVMS structure.</a>
<span class="sourceLineNo">699</span><a id="line.699">    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.16.</a>
<span class="sourceLineNo">700</span><a id="line.700">    ByteVector annotation = new ByteVector();</a>
<span class="sourceLineNo">701</span><a id="line.701">    // Write type_index and reserve space for num_element_value_pairs.</a>
<span class="sourceLineNo">702</span><a id="line.702">    annotation.putShort(symbolTable.addConstantUtf8(annotationDescriptor)).putShort(0);</a>
<span class="sourceLineNo">703</span><a id="line.703">    if (visible) {</a>
<span class="sourceLineNo">704</span><a id="line.704">      if (lastRuntimeVisibleParameterAnnotations == null) {</a>
<span class="sourceLineNo">705</span><a id="line.705">        lastRuntimeVisibleParameterAnnotations =</a>
<span class="sourceLineNo">706</span><a id="line.706">            new AnnotationWriter[Type.getArgumentTypes(descriptor).length];</a>
<span class="sourceLineNo">707</span><a id="line.707">      }</a>
<span class="sourceLineNo">708</span><a id="line.708">      return lastRuntimeVisibleParameterAnnotations[parameter] =</a>
<span class="sourceLineNo">709</span><a id="line.709">          new AnnotationWriter(</a>
<span class="sourceLineNo">710</span><a id="line.710">              symbolTable, annotation, lastRuntimeVisibleParameterAnnotations[parameter]);</a>
<span class="sourceLineNo">711</span><a id="line.711">    } else {</a>
<span class="sourceLineNo">712</span><a id="line.712">      if (lastRuntimeInvisibleParameterAnnotations == null) {</a>
<span class="sourceLineNo">713</span><a id="line.713">        lastRuntimeInvisibleParameterAnnotations =</a>
<span class="sourceLineNo">714</span><a id="line.714">            new AnnotationWriter[Type.getArgumentTypes(descriptor).length];</a>
<span class="sourceLineNo">715</span><a id="line.715">      }</a>
<span class="sourceLineNo">716</span><a id="line.716">      return lastRuntimeInvisibleParameterAnnotations[parameter] =</a>
<span class="sourceLineNo">717</span><a id="line.717">          new AnnotationWriter(</a>
<span class="sourceLineNo">718</span><a id="line.718">              symbolTable, annotation, lastRuntimeInvisibleParameterAnnotations[parameter]);</a>
<span class="sourceLineNo">719</span><a id="line.719">    }</a>
<span class="sourceLineNo">720</span><a id="line.720">  }</a>
<span class="sourceLineNo">721</span><a id="line.721"></a>
<span class="sourceLineNo">722</span><a id="line.722">  @Override</a>
<span class="sourceLineNo">723</span><a id="line.723">  public void visitAttribute(final Attribute attribute) {</a>
<span class="sourceLineNo">724</span><a id="line.724">    // Store the attributes in the &lt;i&gt;reverse&lt;/i&gt; order of their visit by this method.</a>
<span class="sourceLineNo">725</span><a id="line.725">    if (attribute.isCodeAttribute()) {</a>
<span class="sourceLineNo">726</span><a id="line.726">      attribute.nextAttribute = firstCodeAttribute;</a>
<span class="sourceLineNo">727</span><a id="line.727">      firstCodeAttribute = attribute;</a>
<span class="sourceLineNo">728</span><a id="line.728">    } else {</a>
<span class="sourceLineNo">729</span><a id="line.729">      attribute.nextAttribute = firstAttribute;</a>
<span class="sourceLineNo">730</span><a id="line.730">      firstAttribute = attribute;</a>
<span class="sourceLineNo">731</span><a id="line.731">    }</a>
<span class="sourceLineNo">732</span><a id="line.732">  }</a>
<span class="sourceLineNo">733</span><a id="line.733"></a>
<span class="sourceLineNo">734</span><a id="line.734">  @Override</a>
<span class="sourceLineNo">735</span><a id="line.735">  public void visitCode() {</a>
<span class="sourceLineNo">736</span><a id="line.736">    // Nothing to do.</a>
<span class="sourceLineNo">737</span><a id="line.737">  }</a>
<span class="sourceLineNo">738</span><a id="line.738"></a>
<span class="sourceLineNo">739</span><a id="line.739">  @Override</a>
<span class="sourceLineNo">740</span><a id="line.740">  public void visitFrame(</a>
<span class="sourceLineNo">741</span><a id="line.741">      final int type,</a>
<span class="sourceLineNo">742</span><a id="line.742">      final int nLocal,</a>
<span class="sourceLineNo">743</span><a id="line.743">      final Object[] local,</a>
<span class="sourceLineNo">744</span><a id="line.744">      final int nStack,</a>
<span class="sourceLineNo">745</span><a id="line.745">      final Object[] stack) {</a>
<span class="sourceLineNo">746</span><a id="line.746">    if (compute == COMPUTE_ALL_FRAMES) {</a>
<span class="sourceLineNo">747</span><a id="line.747">      return;</a>
<span class="sourceLineNo">748</span><a id="line.748">    }</a>
<span class="sourceLineNo">749</span><a id="line.749"></a>
<span class="sourceLineNo">750</span><a id="line.750">    if (compute == COMPUTE_INSERTED_FRAMES) {</a>
<span class="sourceLineNo">751</span><a id="line.751">      if (currentBasicBlock.frame == null) {</a>
<span class="sourceLineNo">752</span><a id="line.752">        // This should happen only once, for the implicit first frame (which is explicitly visited</a>
<span class="sourceLineNo">753</span><a id="line.753">        // in ClassReader if the EXPAND_ASM_INSNS option is used - and COMPUTE_INSERTED_FRAMES</a>
<span class="sourceLineNo">754</span><a id="line.754">        // can't be set if EXPAND_ASM_INSNS is not used).</a>
<span class="sourceLineNo">755</span><a id="line.755">        currentBasicBlock.frame = new CurrentFrame(currentBasicBlock);</a>
<span class="sourceLineNo">756</span><a id="line.756">        currentBasicBlock.frame.setInputFrameFromDescriptor(</a>
<span class="sourceLineNo">757</span><a id="line.757">            symbolTable, accessFlags, descriptor, nLocal);</a>
<span class="sourceLineNo">758</span><a id="line.758">        currentBasicBlock.frame.accept(this);</a>
<span class="sourceLineNo">759</span><a id="line.759">      } else {</a>
<span class="sourceLineNo">760</span><a id="line.760">        if (type == Opcodes.F_NEW) {</a>
<span class="sourceLineNo">761</span><a id="line.761">          currentBasicBlock.frame.setInputFrameFromApiFormat(</a>
<span class="sourceLineNo">762</span><a id="line.762">              symbolTable, nLocal, local, nStack, stack);</a>
<span class="sourceLineNo">763</span><a id="line.763">        } else {</a>
<span class="sourceLineNo">764</span><a id="line.764">          // In this case type is equal to F_INSERT by hypothesis, and currentBlock.frame contains</a>
<span class="sourceLineNo">765</span><a id="line.765">          // the stack map frame at the current instruction, computed from the last F_NEW frame</a>
<span class="sourceLineNo">766</span><a id="line.766">          // and the bytecode instructions in between (via calls to CurrentFrame#execute).</a>
<span class="sourceLineNo">767</span><a id="line.767">        }</a>
<span class="sourceLineNo">768</span><a id="line.768">        currentBasicBlock.frame.accept(this);</a>
<span class="sourceLineNo">769</span><a id="line.769">      }</a>
<span class="sourceLineNo">770</span><a id="line.770">    } else if (type == Opcodes.F_NEW) {</a>
<span class="sourceLineNo">771</span><a id="line.771">      if (previousFrame == null) {</a>
<span class="sourceLineNo">772</span><a id="line.772">        int argumentsSize = Type.getArgumentsAndReturnSizes(descriptor) &gt;&gt; 2;</a>
<span class="sourceLineNo">773</span><a id="line.773">        Frame implicitFirstFrame = new Frame(new Label());</a>
<span class="sourceLineNo">774</span><a id="line.774">        implicitFirstFrame.setInputFrameFromDescriptor(</a>
<span class="sourceLineNo">775</span><a id="line.775">            symbolTable, accessFlags, descriptor, argumentsSize);</a>
<span class="sourceLineNo">776</span><a id="line.776">        implicitFirstFrame.accept(this);</a>
<span class="sourceLineNo">777</span><a id="line.777">      }</a>
<span class="sourceLineNo">778</span><a id="line.778">      currentLocals = nLocal;</a>
<span class="sourceLineNo">779</span><a id="line.779">      int frameIndex = visitFrameStart(code.length, nLocal, nStack);</a>
<span class="sourceLineNo">780</span><a id="line.780">      for (int i = 0; i &lt; nLocal; ++i) {</a>
<span class="sourceLineNo">781</span><a id="line.781">        currentFrame[frameIndex++] = Frame.getAbstractTypeFromApiFormat(symbolTable, local[i]);</a>
<span class="sourceLineNo">782</span><a id="line.782">      }</a>
<span class="sourceLineNo">783</span><a id="line.783">      for (int i = 0; i &lt; nStack; ++i) {</a>
<span class="sourceLineNo">784</span><a id="line.784">        currentFrame[frameIndex++] = Frame.getAbstractTypeFromApiFormat(symbolTable, stack[i]);</a>
<span class="sourceLineNo">785</span><a id="line.785">      }</a>
<span class="sourceLineNo">786</span><a id="line.786">      visitFrameEnd();</a>
<span class="sourceLineNo">787</span><a id="line.787">    } else {</a>
<span class="sourceLineNo">788</span><a id="line.788">      int offsetDelta;</a>
<span class="sourceLineNo">789</span><a id="line.789">      if (stackMapTableEntries == null) {</a>
<span class="sourceLineNo">790</span><a id="line.790">        stackMapTableEntries = new ByteVector();</a>
<span class="sourceLineNo">791</span><a id="line.791">        offsetDelta = code.length;</a>
<span class="sourceLineNo">792</span><a id="line.792">      } else {</a>
<span class="sourceLineNo">793</span><a id="line.793">        offsetDelta = code.length - previousFrameOffset - 1;</a>
<span class="sourceLineNo">794</span><a id="line.794">        if (offsetDelta &lt; 0) {</a>
<span class="sourceLineNo">795</span><a id="line.795">          if (type == Opcodes.F_SAME) {</a>
<span class="sourceLineNo">796</span><a id="line.796">            return;</a>
<span class="sourceLineNo">797</span><a id="line.797">          } else {</a>
<span class="sourceLineNo">798</span><a id="line.798">            throw new IllegalStateException();</a>
<span class="sourceLineNo">799</span><a id="line.799">          }</a>
<span class="sourceLineNo">800</span><a id="line.800">        }</a>
<span class="sourceLineNo">801</span><a id="line.801">      }</a>
<span class="sourceLineNo">802</span><a id="line.802"></a>
<span class="sourceLineNo">803</span><a id="line.803">      switch (type) {</a>
<span class="sourceLineNo">804</span><a id="line.804">        case Opcodes.F_FULL:</a>
<span class="sourceLineNo">805</span><a id="line.805">          currentLocals = nLocal;</a>
<span class="sourceLineNo">806</span><a id="line.806">          stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(nLocal);</a>
<span class="sourceLineNo">807</span><a id="line.807">          for (int i = 0; i &lt; nLocal; ++i) {</a>
<span class="sourceLineNo">808</span><a id="line.808">            putFrameType(local[i]);</a>
<span class="sourceLineNo">809</span><a id="line.809">          }</a>
<span class="sourceLineNo">810</span><a id="line.810">          stackMapTableEntries.putShort(nStack);</a>
<span class="sourceLineNo">811</span><a id="line.811">          for (int i = 0; i &lt; nStack; ++i) {</a>
<span class="sourceLineNo">812</span><a id="line.812">            putFrameType(stack[i]);</a>
<span class="sourceLineNo">813</span><a id="line.813">          }</a>
<span class="sourceLineNo">814</span><a id="line.814">          break;</a>
<span class="sourceLineNo">815</span><a id="line.815">        case Opcodes.F_APPEND:</a>
<span class="sourceLineNo">816</span><a id="line.816">          currentLocals += nLocal;</a>
<span class="sourceLineNo">817</span><a id="line.817">          stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED + nLocal).putShort(offsetDelta);</a>
<span class="sourceLineNo">818</span><a id="line.818">          for (int i = 0; i &lt; nLocal; ++i) {</a>
<span class="sourceLineNo">819</span><a id="line.819">            putFrameType(local[i]);</a>
<span class="sourceLineNo">820</span><a id="line.820">          }</a>
<span class="sourceLineNo">821</span><a id="line.821">          break;</a>
<span class="sourceLineNo">822</span><a id="line.822">        case Opcodes.F_CHOP:</a>
<span class="sourceLineNo">823</span><a id="line.823">          currentLocals -= nLocal;</a>
<span class="sourceLineNo">824</span><a id="line.824">          stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED - nLocal).putShort(offsetDelta);</a>
<span class="sourceLineNo">825</span><a id="line.825">          break;</a>
<span class="sourceLineNo">826</span><a id="line.826">        case Opcodes.F_SAME:</a>
<span class="sourceLineNo">827</span><a id="line.827">          if (offsetDelta &lt; 64) {</a>
<span class="sourceLineNo">828</span><a id="line.828">            stackMapTableEntries.putByte(offsetDelta);</a>
<span class="sourceLineNo">829</span><a id="line.829">          } else {</a>
<span class="sourceLineNo">830</span><a id="line.830">            stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);</a>
<span class="sourceLineNo">831</span><a id="line.831">          }</a>
<span class="sourceLineNo">832</span><a id="line.832">          break;</a>
<span class="sourceLineNo">833</span><a id="line.833">        case Opcodes.F_SAME1:</a>
<span class="sourceLineNo">834</span><a id="line.834">          if (offsetDelta &lt; 64) {</a>
<span class="sourceLineNo">835</span><a id="line.835">            stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);</a>
<span class="sourceLineNo">836</span><a id="line.836">          } else {</a>
<span class="sourceLineNo">837</span><a id="line.837">            stackMapTableEntries</a>
<span class="sourceLineNo">838</span><a id="line.838">                .putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)</a>
<span class="sourceLineNo">839</span><a id="line.839">                .putShort(offsetDelta);</a>
<span class="sourceLineNo">840</span><a id="line.840">          }</a>
<span class="sourceLineNo">841</span><a id="line.841">          putFrameType(stack[0]);</a>
<span class="sourceLineNo">842</span><a id="line.842">          break;</a>
<span class="sourceLineNo">843</span><a id="line.843">        default:</a>
<span class="sourceLineNo">844</span><a id="line.844">          throw new IllegalArgumentException();</a>
<span class="sourceLineNo">845</span><a id="line.845">      }</a>
<span class="sourceLineNo">846</span><a id="line.846"></a>
<span class="sourceLineNo">847</span><a id="line.847">      previousFrameOffset = code.length;</a>
<span class="sourceLineNo">848</span><a id="line.848">      ++stackMapTableNumberOfEntries;</a>
<span class="sourceLineNo">849</span><a id="line.849">    }</a>
<span class="sourceLineNo">850</span><a id="line.850"></a>
<span class="sourceLineNo">851</span><a id="line.851">    if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {</a>
<span class="sourceLineNo">852</span><a id="line.852">      relativeStackSize = nStack;</a>
<span class="sourceLineNo">853</span><a id="line.853">      if (nStack &gt; maxRelativeStackSize) {</a>
<span class="sourceLineNo">854</span><a id="line.854">        maxRelativeStackSize = relativeStackSize;</a>
<span class="sourceLineNo">855</span><a id="line.855">      }</a>
<span class="sourceLineNo">856</span><a id="line.856">    }</a>
<span class="sourceLineNo">857</span><a id="line.857"></a>
<span class="sourceLineNo">858</span><a id="line.858">    maxStack = Math.max(maxStack, nStack);</a>
<span class="sourceLineNo">859</span><a id="line.859">    maxLocals = Math.max(maxLocals, currentLocals);</a>
<span class="sourceLineNo">860</span><a id="line.860">  }</a>
<span class="sourceLineNo">861</span><a id="line.861"></a>
<span class="sourceLineNo">862</span><a id="line.862">  @Override</a>
<span class="sourceLineNo">863</span><a id="line.863">  public void visitInsn(final int opcode) {</a>
<span class="sourceLineNo">864</span><a id="line.864">    lastBytecodeOffset = code.length;</a>
<span class="sourceLineNo">865</span><a id="line.865">    // Add the instruction to the bytecode of the method.</a>
<span class="sourceLineNo">866</span><a id="line.866">    code.putByte(opcode);</a>
<span class="sourceLineNo">867</span><a id="line.867">    // If needed, update the maximum stack size and number of locals, and stack map frames.</a>
<span class="sourceLineNo">868</span><a id="line.868">    if (currentBasicBlock != null) {</a>
<span class="sourceLineNo">869</span><a id="line.869">      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {</a>
<span class="sourceLineNo">870</span><a id="line.870">        currentBasicBlock.frame.execute(opcode, 0, null, null);</a>
<span class="sourceLineNo">871</span><a id="line.871">      } else {</a>
<span class="sourceLineNo">872</span><a id="line.872">        int size = relativeStackSize + STACK_SIZE_DELTA[opcode];</a>
<span class="sourceLineNo">873</span><a id="line.873">        if (size &gt; maxRelativeStackSize) {</a>
<span class="sourceLineNo">874</span><a id="line.874">          maxRelativeStackSize = size;</a>
<span class="sourceLineNo">875</span><a id="line.875">        }</a>
<span class="sourceLineNo">876</span><a id="line.876">        relativeStackSize = size;</a>
<span class="sourceLineNo">877</span><a id="line.877">      }</a>
<span class="sourceLineNo">878</span><a id="line.878">      if ((opcode &gt;= Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.RETURN) || opcode == Opcodes.ATHROW) {</a>
<span class="sourceLineNo">879</span><a id="line.879">        endCurrentBasicBlockWithNoSuccessor();</a>
<span class="sourceLineNo">880</span><a id="line.880">      }</a>
<span class="sourceLineNo">881</span><a id="line.881">    }</a>
<span class="sourceLineNo">882</span><a id="line.882">  }</a>
<span class="sourceLineNo">883</span><a id="line.883"></a>
<span class="sourceLineNo">884</span><a id="line.884">  @Override</a>
<span class="sourceLineNo">885</span><a id="line.885">  public void visitIntInsn(final int opcode, final int operand) {</a>
<span class="sourceLineNo">886</span><a id="line.886">    lastBytecodeOffset = code.length;</a>
<span class="sourceLineNo">887</span><a id="line.887">    // Add the instruction to the bytecode of the method.</a>
<span class="sourceLineNo">888</span><a id="line.888">    if (opcode == Opcodes.SIPUSH) {</a>
<span class="sourceLineNo">889</span><a id="line.889">      code.put12(opcode, operand);</a>
<span class="sourceLineNo">890</span><a id="line.890">    } else { // BIPUSH or NEWARRAY</a>
<span class="sourceLineNo">891</span><a id="line.891">      code.put11(opcode, operand);</a>
<span class="sourceLineNo">892</span><a id="line.892">    }</a>
<span class="sourceLineNo">893</span><a id="line.893">    // If needed, update the maximum stack size and number of locals, and stack map frames.</a>
<span class="sourceLineNo">894</span><a id="line.894">    if (currentBasicBlock != null) {</a>
<span class="sourceLineNo">895</span><a id="line.895">      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {</a>
<span class="sourceLineNo">896</span><a id="line.896">        currentBasicBlock.frame.execute(opcode, operand, null, null);</a>
<span class="sourceLineNo">897</span><a id="line.897">      } else if (opcode != Opcodes.NEWARRAY) {</a>
<span class="sourceLineNo">898</span><a id="line.898">        // The stack size delta is 1 for BIPUSH or SIPUSH, and 0 for NEWARRAY.</a>
<span class="sourceLineNo">899</span><a id="line.899">        int size = relativeStackSize + 1;</a>
<span class="sourceLineNo">900</span><a id="line.900">        if (size &gt; maxRelativeStackSize) {</a>
<span class="sourceLineNo">901</span><a id="line.901">          maxRelativeStackSize = size;</a>
<span class="sourceLineNo">902</span><a id="line.902">        }</a>
<span class="sourceLineNo">903</span><a id="line.903">        relativeStackSize = size;</a>
<span class="sourceLineNo">904</span><a id="line.904">      }</a>
<span class="sourceLineNo">905</span><a id="line.905">    }</a>
<span class="sourceLineNo">906</span><a id="line.906">  }</a>
<span class="sourceLineNo">907</span><a id="line.907"></a>
<span class="sourceLineNo">908</span><a id="line.908">  @Override</a>
<span class="sourceLineNo">909</span><a id="line.909">  public void visitVarInsn(final int opcode, final int var) {</a>
<span class="sourceLineNo">910</span><a id="line.910">    lastBytecodeOffset = code.length;</a>
<span class="sourceLineNo">911</span><a id="line.911">    // Add the instruction to the bytecode of the method.</a>
<span class="sourceLineNo">912</span><a id="line.912">    if (var &lt; 4 &amp;&amp; opcode != Opcodes.RET) {</a>
<span class="sourceLineNo">913</span><a id="line.913">      int optimizedOpcode;</a>
<span class="sourceLineNo">914</span><a id="line.914">      if (opcode &lt; Opcodes.ISTORE) {</a>
<span class="sourceLineNo">915</span><a id="line.915">        optimizedOpcode = Constants.ILOAD_0 + ((opcode - Opcodes.ILOAD) &lt;&lt; 2) + var;</a>
<span class="sourceLineNo">916</span><a id="line.916">      } else {</a>
<span class="sourceLineNo">917</span><a id="line.917">        optimizedOpcode = Constants.ISTORE_0 + ((opcode - Opcodes.ISTORE) &lt;&lt; 2) + var;</a>
<span class="sourceLineNo">918</span><a id="line.918">      }</a>
<span class="sourceLineNo">919</span><a id="line.919">      code.putByte(optimizedOpcode);</a>
<span class="sourceLineNo">920</span><a id="line.920">    } else if (var &gt;= 256) {</a>
<span class="sourceLineNo">921</span><a id="line.921">      code.putByte(Constants.WIDE).put12(opcode, var);</a>
<span class="sourceLineNo">922</span><a id="line.922">    } else {</a>
<span class="sourceLineNo">923</span><a id="line.923">      code.put11(opcode, var);</a>
<span class="sourceLineNo">924</span><a id="line.924">    }</a>
<span class="sourceLineNo">925</span><a id="line.925">    // If needed, update the maximum stack size and number of locals, and stack map frames.</a>
<span class="sourceLineNo">926</span><a id="line.926">    if (currentBasicBlock != null) {</a>
<span class="sourceLineNo">927</span><a id="line.927">      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {</a>
<span class="sourceLineNo">928</span><a id="line.928">        currentBasicBlock.frame.execute(opcode, var, null, null);</a>
<span class="sourceLineNo">929</span><a id="line.929">      } else {</a>
<span class="sourceLineNo">930</span><a id="line.930">        if (opcode == Opcodes.RET) {</a>
<span class="sourceLineNo">931</span><a id="line.931">          // No stack size delta.</a>
<span class="sourceLineNo">932</span><a id="line.932">          currentBasicBlock.flags |= Label.FLAG_SUBROUTINE_END;</a>
<span class="sourceLineNo">933</span><a id="line.933">          currentBasicBlock.outputStackSize = (short) relativeStackSize;</a>
<span class="sourceLineNo">934</span><a id="line.934">          endCurrentBasicBlockWithNoSuccessor();</a>
<span class="sourceLineNo">935</span><a id="line.935">        } else { // xLOAD or xSTORE</a>
<span class="sourceLineNo">936</span><a id="line.936">          int size = relativeStackSize + STACK_SIZE_DELTA[opcode];</a>
<span class="sourceLineNo">937</span><a id="line.937">          if (size &gt; maxRelativeStackSize) {</a>
<span class="sourceLineNo">938</span><a id="line.938">            maxRelativeStackSize = size;</a>
<span class="sourceLineNo">939</span><a id="line.939">          }</a>
<span class="sourceLineNo">940</span><a id="line.940">          relativeStackSize = size;</a>
<span class="sourceLineNo">941</span><a id="line.941">        }</a>
<span class="sourceLineNo">942</span><a id="line.942">      }</a>
<span class="sourceLineNo">943</span><a id="line.943">    }</a>
<span class="sourceLineNo">944</span><a id="line.944">    if (compute != COMPUTE_NOTHING) {</a>
<span class="sourceLineNo">945</span><a id="line.945">      int currentMaxLocals;</a>
<span class="sourceLineNo">946</span><a id="line.946">      if (opcode == Opcodes.LLOAD</a>
<span class="sourceLineNo">947</span><a id="line.947">          || opcode == Opcodes.DLOAD</a>
<span class="sourceLineNo">948</span><a id="line.948">          || opcode == Opcodes.LSTORE</a>
<span class="sourceLineNo">949</span><a id="line.949">          || opcode == Opcodes.DSTORE) {</a>
<span class="sourceLineNo">950</span><a id="line.950">        currentMaxLocals = var + 2;</a>
<span class="sourceLineNo">951</span><a id="line.951">      } else {</a>
<span class="sourceLineNo">952</span><a id="line.952">        currentMaxLocals = var + 1;</a>
<span class="sourceLineNo">953</span><a id="line.953">      }</a>
<span class="sourceLineNo">954</span><a id="line.954">      if (currentMaxLocals &gt; maxLocals) {</a>
<span class="sourceLineNo">955</span><a id="line.955">        maxLocals = currentMaxLocals;</a>
<span class="sourceLineNo">956</span><a id="line.956">      }</a>
<span class="sourceLineNo">957</span><a id="line.957">    }</a>
<span class="sourceLineNo">958</span><a id="line.958">    if (opcode &gt;= Opcodes.ISTORE &amp;&amp; compute == COMPUTE_ALL_FRAMES &amp;&amp; firstHandler != null) {</a>
<span class="sourceLineNo">959</span><a id="line.959">      // If there are exception handler blocks, each instruction within a handler range is, in</a>
<span class="sourceLineNo">960</span><a id="line.960">      // theory, a basic block (since execution can jump from this instruction to the exception</a>
<span class="sourceLineNo">961</span><a id="line.961">      // handler). As a consequence, the local variable types at the beginning of the handler</a>
<span class="sourceLineNo">962</span><a id="line.962">      // block should be the merge of the local variable types at all the instructions within the</a>
<span class="sourceLineNo">963</span><a id="line.963">      // handler range. However, instead of creating a basic block for each instruction, we can</a>
<span class="sourceLineNo">964</span><a id="line.964">      // get the same result in a more efficient way. Namely, by starting a new basic block after</a>
<span class="sourceLineNo">965</span><a id="line.965">      // each xSTORE instruction, which is what we do here.</a>
<span class="sourceLineNo">966</span><a id="line.966">      visitLabel(new Label());</a>
<span class="sourceLineNo">967</span><a id="line.967">    }</a>
<span class="sourceLineNo">968</span><a id="line.968">  }</a>
<span class="sourceLineNo">969</span><a id="line.969"></a>
<span class="sourceLineNo">970</span><a id="line.970">  @Override</a>
<span class="sourceLineNo">971</span><a id="line.971">  public void visitTypeInsn(final int opcode, final String type) {</a>
<span class="sourceLineNo">972</span><a id="line.972">    lastBytecodeOffset = code.length;</a>
<span class="sourceLineNo">973</span><a id="line.973">    // Add the instruction to the bytecode of the method.</a>
<span class="sourceLineNo">974</span><a id="line.974">    Symbol typeSymbol = symbolTable.addConstantClass(type);</a>
<span class="sourceLineNo">975</span><a id="line.975">    code.put12(opcode, typeSymbol.index);</a>
<span class="sourceLineNo">976</span><a id="line.976">    // If needed, update the maximum stack size and number of locals, and stack map frames.</a>
<span class="sourceLineNo">977</span><a id="line.977">    if (currentBasicBlock != null) {</a>
<span class="sourceLineNo">978</span><a id="line.978">      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {</a>
<span class="sourceLineNo">979</span><a id="line.979">        currentBasicBlock.frame.execute(opcode, lastBytecodeOffset, typeSymbol, symbolTable);</a>
<span class="sourceLineNo">980</span><a id="line.980">      } else if (opcode == Opcodes.NEW) {</a>
<span class="sourceLineNo">981</span><a id="line.981">        // The stack size delta is 1 for NEW, and 0 for ANEWARRAY, CHECKCAST, or INSTANCEOF.</a>
<span class="sourceLineNo">982</span><a id="line.982">        int size = relativeStackSize + 1;</a>
<span class="sourceLineNo">983</span><a id="line.983">        if (size &gt; maxRelativeStackSize) {</a>
<span class="sourceLineNo">984</span><a id="line.984">          maxRelativeStackSize = size;</a>
<span class="sourceLineNo">985</span><a id="line.985">        }</a>
<span class="sourceLineNo">986</span><a id="line.986">        relativeStackSize = size;</a>
<span class="sourceLineNo">987</span><a id="line.987">      }</a>
<span class="sourceLineNo">988</span><a id="line.988">    }</a>
<span class="sourceLineNo">989</span><a id="line.989">  }</a>
<span class="sourceLineNo">990</span><a id="line.990"></a>
<span class="sourceLineNo">991</span><a id="line.991">  @Override</a>
<span class="sourceLineNo">992</span><a id="line.992">  public void visitFieldInsn(</a>
<span class="sourceLineNo">993</span><a id="line.993">      final int opcode, final String owner, final String name, final String descriptor) {</a>
<span class="sourceLineNo">994</span><a id="line.994">    lastBytecodeOffset = code.length;</a>
<span class="sourceLineNo">995</span><a id="line.995">    // Add the instruction to the bytecode of the method.</a>
<span class="sourceLineNo">996</span><a id="line.996">    Symbol fieldrefSymbol = symbolTable.addConstantFieldref(owner, name, descriptor);</a>
<span class="sourceLineNo">997</span><a id="line.997">    code.put12(opcode, fieldrefSymbol.index);</a>
<span class="sourceLineNo">998</span><a id="line.998">    // If needed, update the maximum stack size and number of locals, and stack map frames.</a>
<span class="sourceLineNo">999</span><a id="line.999">    if (currentBasicBlock != null) {</a>
<span class="sourceLineNo">1000</span><a id="line.1000">      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {</a>
<span class="sourceLineNo">1001</span><a id="line.1001">        currentBasicBlock.frame.execute(opcode, 0, fieldrefSymbol, symbolTable);</a>
<span class="sourceLineNo">1002</span><a id="line.1002">      } else {</a>
<span class="sourceLineNo">1003</span><a id="line.1003">        int size;</a>
<span class="sourceLineNo">1004</span><a id="line.1004">        char firstDescChar = descriptor.charAt(0);</a>
<span class="sourceLineNo">1005</span><a id="line.1005">        switch (opcode) {</a>
<span class="sourceLineNo">1006</span><a id="line.1006">          case Opcodes.GETSTATIC:</a>
<span class="sourceLineNo">1007</span><a id="line.1007">            size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? 2 : 1);</a>
<span class="sourceLineNo">1008</span><a id="line.1008">            break;</a>
<span class="sourceLineNo">1009</span><a id="line.1009">          case Opcodes.PUTSTATIC:</a>
<span class="sourceLineNo">1010</span><a id="line.1010">            size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? -2 : -1);</a>
<span class="sourceLineNo">1011</span><a id="line.1011">            break;</a>
<span class="sourceLineNo">1012</span><a id="line.1012">          case Opcodes.GETFIELD:</a>
<span class="sourceLineNo">1013</span><a id="line.1013">            size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? 1 : 0);</a>
<span class="sourceLineNo">1014</span><a id="line.1014">            break;</a>
<span class="sourceLineNo">1015</span><a id="line.1015">          case Opcodes.PUTFIELD:</a>
<span class="sourceLineNo">1016</span><a id="line.1016">          default:</a>
<span class="sourceLineNo">1017</span><a id="line.1017">            size = relativeStackSize + (firstDescChar == 'D' || firstDescChar == 'J' ? -3 : -2);</a>
<span class="sourceLineNo">1018</span><a id="line.1018">            break;</a>
<span class="sourceLineNo">1019</span><a id="line.1019">        }</a>
<span class="sourceLineNo">1020</span><a id="line.1020">        if (size &gt; maxRelativeStackSize) {</a>
<span class="sourceLineNo">1021</span><a id="line.1021">          maxRelativeStackSize = size;</a>
<span class="sourceLineNo">1022</span><a id="line.1022">        }</a>
<span class="sourceLineNo">1023</span><a id="line.1023">        relativeStackSize = size;</a>
<span class="sourceLineNo">1024</span><a id="line.1024">      }</a>
<span class="sourceLineNo">1025</span><a id="line.1025">    }</a>
<span class="sourceLineNo">1026</span><a id="line.1026">  }</a>
<span class="sourceLineNo">1027</span><a id="line.1027"></a>
<span class="sourceLineNo">1028</span><a id="line.1028">  @Override</a>
<span class="sourceLineNo">1029</span><a id="line.1029">  public void visitMethodInsn(</a>
<span class="sourceLineNo">1030</span><a id="line.1030">      final int opcode,</a>
<span class="sourceLineNo">1031</span><a id="line.1031">      final String owner,</a>
<span class="sourceLineNo">1032</span><a id="line.1032">      final String name,</a>
<span class="sourceLineNo">1033</span><a id="line.1033">      final String descriptor,</a>
<span class="sourceLineNo">1034</span><a id="line.1034">      final boolean isInterface) {</a>
<span class="sourceLineNo">1035</span><a id="line.1035">    lastBytecodeOffset = code.length;</a>
<span class="sourceLineNo">1036</span><a id="line.1036">    // Add the instruction to the bytecode of the method.</a>
<span class="sourceLineNo">1037</span><a id="line.1037">    Symbol methodrefSymbol = symbolTable.addConstantMethodref(owner, name, descriptor, isInterface);</a>
<span class="sourceLineNo">1038</span><a id="line.1038">    if (opcode == Opcodes.INVOKEINTERFACE) {</a>
<span class="sourceLineNo">1039</span><a id="line.1039">      code.put12(Opcodes.INVOKEINTERFACE, methodrefSymbol.index)</a>
<span class="sourceLineNo">1040</span><a id="line.1040">          .put11(methodrefSymbol.getArgumentsAndReturnSizes() &gt;&gt; 2, 0);</a>
<span class="sourceLineNo">1041</span><a id="line.1041">    } else {</a>
<span class="sourceLineNo">1042</span><a id="line.1042">      code.put12(opcode, methodrefSymbol.index);</a>
<span class="sourceLineNo">1043</span><a id="line.1043">    }</a>
<span class="sourceLineNo">1044</span><a id="line.1044">    // If needed, update the maximum stack size and number of locals, and stack map frames.</a>
<span class="sourceLineNo">1045</span><a id="line.1045">    if (currentBasicBlock != null) {</a>
<span class="sourceLineNo">1046</span><a id="line.1046">      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {</a>
<span class="sourceLineNo">1047</span><a id="line.1047">        currentBasicBlock.frame.execute(opcode, 0, methodrefSymbol, symbolTable);</a>
<span class="sourceLineNo">1048</span><a id="line.1048">      } else {</a>
<span class="sourceLineNo">1049</span><a id="line.1049">        int argumentsAndReturnSize = methodrefSymbol.getArgumentsAndReturnSizes();</a>
<span class="sourceLineNo">1050</span><a id="line.1050">        int stackSizeDelta = (argumentsAndReturnSize &amp; 3) - (argumentsAndReturnSize &gt;&gt; 2);</a>
<span class="sourceLineNo">1051</span><a id="line.1051">        int size;</a>
<span class="sourceLineNo">1052</span><a id="line.1052">        if (opcode == Opcodes.INVOKESTATIC) {</a>
<span class="sourceLineNo">1053</span><a id="line.1053">          size = relativeStackSize + stackSizeDelta + 1;</a>
<span class="sourceLineNo">1054</span><a id="line.1054">        } else {</a>
<span class="sourceLineNo">1055</span><a id="line.1055">          size = relativeStackSize + stackSizeDelta;</a>
<span class="sourceLineNo">1056</span><a id="line.1056">        }</a>
<span class="sourceLineNo">1057</span><a id="line.1057">        if (size &gt; maxRelativeStackSize) {</a>
<span class="sourceLineNo">1058</span><a id="line.1058">          maxRelativeStackSize = size;</a>
<span class="sourceLineNo">1059</span><a id="line.1059">        }</a>
<span class="sourceLineNo">1060</span><a id="line.1060">        relativeStackSize = size;</a>
<span class="sourceLineNo">1061</span><a id="line.1061">      }</a>
<span class="sourceLineNo">1062</span><a id="line.1062">    }</a>
<span class="sourceLineNo">1063</span><a id="line.1063">  }</a>
<span class="sourceLineNo">1064</span><a id="line.1064"></a>
<span class="sourceLineNo">1065</span><a id="line.1065">  @Override</a>
<span class="sourceLineNo">1066</span><a id="line.1066">  public void visitInvokeDynamicInsn(</a>
<span class="sourceLineNo">1067</span><a id="line.1067">      final String name,</a>
<span class="sourceLineNo">1068</span><a id="line.1068">      final String descriptor,</a>
<span class="sourceLineNo">1069</span><a id="line.1069">      final Handle bootstrapMethodHandle,</a>
<span class="sourceLineNo">1070</span><a id="line.1070">      final Object... bootstrapMethodArguments) {</a>
<span class="sourceLineNo">1071</span><a id="line.1071">    lastBytecodeOffset = code.length;</a>
<span class="sourceLineNo">1072</span><a id="line.1072">    // Add the instruction to the bytecode of the method.</a>
<span class="sourceLineNo">1073</span><a id="line.1073">    Symbol invokeDynamicSymbol =</a>
<span class="sourceLineNo">1074</span><a id="line.1074">        symbolTable.addConstantInvokeDynamic(</a>
<span class="sourceLineNo">1075</span><a id="line.1075">            name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);</a>
<span class="sourceLineNo">1076</span><a id="line.1076">    code.put12(Opcodes.INVOKEDYNAMIC, invokeDynamicSymbol.index);</a>
<span class="sourceLineNo">1077</span><a id="line.1077">    code.putShort(0);</a>
<span class="sourceLineNo">1078</span><a id="line.1078">    // If needed, update the maximum stack size and number of locals, and stack map frames.</a>
<span class="sourceLineNo">1079</span><a id="line.1079">    if (currentBasicBlock != null) {</a>
<span class="sourceLineNo">1080</span><a id="line.1080">      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {</a>
<span class="sourceLineNo">1081</span><a id="line.1081">        currentBasicBlock.frame.execute(Opcodes.INVOKEDYNAMIC, 0, invokeDynamicSymbol, symbolTable);</a>
<span class="sourceLineNo">1082</span><a id="line.1082">      } else {</a>
<span class="sourceLineNo">1083</span><a id="line.1083">        int argumentsAndReturnSize = invokeDynamicSymbol.getArgumentsAndReturnSizes();</a>
<span class="sourceLineNo">1084</span><a id="line.1084">        int stackSizeDelta = (argumentsAndReturnSize &amp; 3) - (argumentsAndReturnSize &gt;&gt; 2) + 1;</a>
<span class="sourceLineNo">1085</span><a id="line.1085">        int size = relativeStackSize + stackSizeDelta;</a>
<span class="sourceLineNo">1086</span><a id="line.1086">        if (size &gt; maxRelativeStackSize) {</a>
<span class="sourceLineNo">1087</span><a id="line.1087">          maxRelativeStackSize = size;</a>
<span class="sourceLineNo">1088</span><a id="line.1088">        }</a>
<span class="sourceLineNo">1089</span><a id="line.1089">        relativeStackSize = size;</a>
<span class="sourceLineNo">1090</span><a id="line.1090">      }</a>
<span class="sourceLineNo">1091</span><a id="line.1091">    }</a>
<span class="sourceLineNo">1092</span><a id="line.1092">  }</a>
<span class="sourceLineNo">1093</span><a id="line.1093"></a>
<span class="sourceLineNo">1094</span><a id="line.1094">  @Override</a>
<span class="sourceLineNo">1095</span><a id="line.1095">  public void visitJumpInsn(final int opcode, final Label label) {</a>
<span class="sourceLineNo">1096</span><a id="line.1096">    lastBytecodeOffset = code.length;</a>
<span class="sourceLineNo">1097</span><a id="line.1097">    // Add the instruction to the bytecode of the method.</a>
<span class="sourceLineNo">1098</span><a id="line.1098">    // Compute the 'base' opcode, i.e. GOTO or JSR if opcode is GOTO_W or JSR_W, otherwise opcode.</a>
<span class="sourceLineNo">1099</span><a id="line.1099">    int baseOpcode =</a>
<span class="sourceLineNo">1100</span><a id="line.1100">        opcode &gt;= Constants.GOTO_W ? opcode - Constants.WIDE_JUMP_OPCODE_DELTA : opcode;</a>
<span class="sourceLineNo">1101</span><a id="line.1101">    boolean nextInsnIsJumpTarget = false;</a>
<span class="sourceLineNo">1102</span><a id="line.1102">    if ((label.flags &amp; Label.FLAG_RESOLVED) != 0</a>
<span class="sourceLineNo">1103</span><a id="line.1103">        &amp;&amp; label.bytecodeOffset - code.length &lt; Short.MIN_VALUE) {</a>
<span class="sourceLineNo">1104</span><a id="line.1104">      // Case of a backward jump with an offset &lt; -32768. In this case we automatically replace GOTO</a>
<span class="sourceLineNo">1105</span><a id="line.1105">      // with GOTO_W, JSR with JSR_W and IFxxx &lt;l&gt; with IFNOTxxx &lt;L&gt; GOTO_W &lt;l&gt; L:..., where</a>
<span class="sourceLineNo">1106</span><a id="line.1106">      // IFNOTxxx is the "opposite" opcode of IFxxx (e.g. IFNE for IFEQ) and where &lt;L&gt; designates</a>
<span class="sourceLineNo">1107</span><a id="line.1107">      // the instruction just after the GOTO_W.</a>
<span class="sourceLineNo">1108</span><a id="line.1108">      if (baseOpcode == Opcodes.GOTO) {</a>
<span class="sourceLineNo">1109</span><a id="line.1109">        code.putByte(Constants.GOTO_W);</a>
<span class="sourceLineNo">1110</span><a id="line.1110">      } else if (baseOpcode == Opcodes.JSR) {</a>
<span class="sourceLineNo">1111</span><a id="line.1111">        code.putByte(Constants.JSR_W);</a>
<span class="sourceLineNo">1112</span><a id="line.1112">      } else {</a>
<span class="sourceLineNo">1113</span><a id="line.1113">        // Put the "opposite" opcode of baseOpcode. This can be done by flipping the least</a>
<span class="sourceLineNo">1114</span><a id="line.1114">        // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ (with a</a>
<span class="sourceLineNo">1115</span><a id="line.1115">        // pre and post offset by 1). The jump offset is 8 bytes (3 for IFNOTxxx, 5 for GOTO_W).</a>
<span class="sourceLineNo">1116</span><a id="line.1116">        code.putByte(baseOpcode &gt;= Opcodes.IFNULL ? baseOpcode ^ 1 : ((baseOpcode + 1) ^ 1) - 1);</a>
<span class="sourceLineNo">1117</span><a id="line.1117">        code.putShort(8);</a>
<span class="sourceLineNo">1118</span><a id="line.1118">        // Here we could put a GOTO_W in theory, but if ASM specific instructions are used in this</a>
<span class="sourceLineNo">1119</span><a id="line.1119">        // method or another one, and if the class has frames, we will need to insert a frame after</a>
<span class="sourceLineNo">1120</span><a id="line.1120">        // this GOTO_W during the additional ClassReader -&gt; ClassWriter round trip to remove the ASM</a>
<span class="sourceLineNo">1121</span><a id="line.1121">        // specific instructions. To not miss this additional frame, we need to use an ASM_GOTO_W</a>
<span class="sourceLineNo">1122</span><a id="line.1122">        // here, which has the unfortunate effect of forcing this additional round trip (which in</a>
<span class="sourceLineNo">1123</span><a id="line.1123">        // some case would not have been really necessary, but we can't know this at this point).</a>
<span class="sourceLineNo">1124</span><a id="line.1124">        code.putByte(Constants.ASM_GOTO_W);</a>
<span class="sourceLineNo">1125</span><a id="line.1125">        hasAsmInstructions = true;</a>
<span class="sourceLineNo">1126</span><a id="line.1126">        // The instruction after the GOTO_W becomes the target of the IFNOT instruction.</a>
<span class="sourceLineNo">1127</span><a id="line.1127">        nextInsnIsJumpTarget = true;</a>
<span class="sourceLineNo">1128</span><a id="line.1128">      }</a>
<span class="sourceLineNo">1129</span><a id="line.1129">      label.put(code, code.length - 1, true);</a>
<span class="sourceLineNo">1130</span><a id="line.1130">    } else if (baseOpcode != opcode) {</a>
<span class="sourceLineNo">1131</span><a id="line.1131">      // Case of a GOTO_W or JSR_W specified by the user (normally ClassReader when used to remove</a>
<span class="sourceLineNo">1132</span><a id="line.1132">      // ASM specific instructions). In this case we keep the original instruction.</a>
<span class="sourceLineNo">1133</span><a id="line.1133">      code.putByte(opcode);</a>
<span class="sourceLineNo">1134</span><a id="line.1134">      label.put(code, code.length - 1, true);</a>
<span class="sourceLineNo">1135</span><a id="line.1135">    } else {</a>
<span class="sourceLineNo">1136</span><a id="line.1136">      // Case of a jump with an offset &gt;= -32768, or of a jump with an unknown offset. In these</a>
<span class="sourceLineNo">1137</span><a id="line.1137">      // cases we store the offset in 2 bytes (which will be increased via a ClassReader -&gt;</a>
<span class="sourceLineNo">1138</span><a id="line.1138">      // ClassWriter round trip if it turns out that 2 bytes are not sufficient).</a>
<span class="sourceLineNo">1139</span><a id="line.1139">      code.putByte(baseOpcode);</a>
<span class="sourceLineNo">1140</span><a id="line.1140">      label.put(code, code.length - 1, false);</a>
<span class="sourceLineNo">1141</span><a id="line.1141">    }</a>
<span class="sourceLineNo">1142</span><a id="line.1142"></a>
<span class="sourceLineNo">1143</span><a id="line.1143">    // If needed, update the maximum stack size and number of locals, and stack map frames.</a>
<span class="sourceLineNo">1144</span><a id="line.1144">    if (currentBasicBlock != null) {</a>
<span class="sourceLineNo">1145</span><a id="line.1145">      Label nextBasicBlock = null;</a>
<span class="sourceLineNo">1146</span><a id="line.1146">      if (compute == COMPUTE_ALL_FRAMES) {</a>
<span class="sourceLineNo">1147</span><a id="line.1147">        currentBasicBlock.frame.execute(baseOpcode, 0, null, null);</a>
<span class="sourceLineNo">1148</span><a id="line.1148">        // Record the fact that 'label' is the target of a jump instruction.</a>
<span class="sourceLineNo">1149</span><a id="line.1149">        label.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;</a>
<span class="sourceLineNo">1150</span><a id="line.1150">        // Add 'label' as a successor of the current basic block.</a>
<span class="sourceLineNo">1151</span><a id="line.1151">        addSuccessorToCurrentBasicBlock(Edge.JUMP, label);</a>
<span class="sourceLineNo">1152</span><a id="line.1152">        if (baseOpcode != Opcodes.GOTO) {</a>
<span class="sourceLineNo">1153</span><a id="line.1153">          // The next instruction starts a new basic block (except for GOTO: by default the code</a>
<span class="sourceLineNo">1154</span><a id="line.1154">          // following a goto is unreachable - unless there is an explicit label for it - and we</a>
<span class="sourceLineNo">1155</span><a id="line.1155">          // should not compute stack frame types for its instructions).</a>
<span class="sourceLineNo">1156</span><a id="line.1156">          nextBasicBlock = new Label();</a>
<span class="sourceLineNo">1157</span><a id="line.1157">        }</a>
<span class="sourceLineNo">1158</span><a id="line.1158">      } else if (compute == COMPUTE_INSERTED_FRAMES) {</a>
<span class="sourceLineNo">1159</span><a id="line.1159">        currentBasicBlock.frame.execute(baseOpcode, 0, null, null);</a>
<span class="sourceLineNo">1160</span><a id="line.1160">      } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {</a>
<span class="sourceLineNo">1161</span><a id="line.1161">        // No need to update maxRelativeStackSize (the stack size delta is always negative).</a>
<span class="sourceLineNo">1162</span><a id="line.1162">        relativeStackSize += STACK_SIZE_DELTA[baseOpcode];</a>
<span class="sourceLineNo">1163</span><a id="line.1163">      } else {</a>
<span class="sourceLineNo">1164</span><a id="line.1164">        if (baseOpcode == Opcodes.JSR) {</a>
<span class="sourceLineNo">1165</span><a id="line.1165">          // Record the fact that 'label' designates a subroutine, if not already done.</a>
<span class="sourceLineNo">1166</span><a id="line.1166">          if ((label.flags &amp; Label.FLAG_SUBROUTINE_START) == 0) {</a>
<span class="sourceLineNo">1167</span><a id="line.1167">            label.flags |= Label.FLAG_SUBROUTINE_START;</a>
<span class="sourceLineNo">1168</span><a id="line.1168">            hasSubroutines = true;</a>
<span class="sourceLineNo">1169</span><a id="line.1169">          }</a>
<span class="sourceLineNo">1170</span><a id="line.1170">          currentBasicBlock.flags |= Label.FLAG_SUBROUTINE_CALLER;</a>
<span class="sourceLineNo">1171</span><a id="line.1171">          // Note that, by construction in this method, a block which calls a subroutine has at</a>
<span class="sourceLineNo">1172</span><a id="line.1172">          // least two successors in the control flow graph: the first one (added below) leads to</a>
<span class="sourceLineNo">1173</span><a id="line.1173">          // the instruction after the JSR, while the second one (added here) leads to the JSR</a>
<span class="sourceLineNo">1174</span><a id="line.1174">          // target. Note that the first successor is virtual (it does not correspond to a possible</a>
<span class="sourceLineNo">1175</span><a id="line.1175">          // execution path): it is only used to compute the successors of the basic blocks ending</a>
<span class="sourceLineNo">1176</span><a id="line.1176">          // with a ret, in {@link Label#addSubroutineRetSuccessors}.</a>
<span class="sourceLineNo">1177</span><a id="line.1177">          addSuccessorToCurrentBasicBlock(relativeStackSize + 1, label);</a>
<span class="sourceLineNo">1178</span><a id="line.1178">          // The instruction after the JSR starts a new basic block.</a>
<span class="sourceLineNo">1179</span><a id="line.1179">          nextBasicBlock = new Label();</a>
<span class="sourceLineNo">1180</span><a id="line.1180">        } else {</a>
<span class="sourceLineNo">1181</span><a id="line.1181">          // No need to update maxRelativeStackSize (the stack size delta is always negative).</a>
<span class="sourceLineNo">1182</span><a id="line.1182">          relativeStackSize += STACK_SIZE_DELTA[baseOpcode];</a>
<span class="sourceLineNo">1183</span><a id="line.1183">          addSuccessorToCurrentBasicBlock(relativeStackSize, label);</a>
<span class="sourceLineNo">1184</span><a id="line.1184">        }</a>
<span class="sourceLineNo">1185</span><a id="line.1185">      }</a>
<span class="sourceLineNo">1186</span><a id="line.1186">      // If the next instruction starts a new basic block, call visitLabel to add the label of this</a>
<span class="sourceLineNo">1187</span><a id="line.1187">      // instruction as a successor of the current block, and to start a new basic block.</a>
<span class="sourceLineNo">1188</span><a id="line.1188">      if (nextBasicBlock != null) {</a>
<span class="sourceLineNo">1189</span><a id="line.1189">        if (nextInsnIsJumpTarget) {</a>
<span class="sourceLineNo">1190</span><a id="line.1190">          nextBasicBlock.flags |= Label.FLAG_JUMP_TARGET;</a>
<span class="sourceLineNo">1191</span><a id="line.1191">        }</a>
<span class="sourceLineNo">1192</span><a id="line.1192">        visitLabel(nextBasicBlock);</a>
<span class="sourceLineNo">1193</span><a id="line.1193">      }</a>
<span class="sourceLineNo">1194</span><a id="line.1194">      if (baseOpcode == Opcodes.GOTO) {</a>
<span class="sourceLineNo">1195</span><a id="line.1195">        endCurrentBasicBlockWithNoSuccessor();</a>
<span class="sourceLineNo">1196</span><a id="line.1196">      }</a>
<span class="sourceLineNo">1197</span><a id="line.1197">    }</a>
<span class="sourceLineNo">1198</span><a id="line.1198">  }</a>
<span class="sourceLineNo">1199</span><a id="line.1199"></a>
<span class="sourceLineNo">1200</span><a id="line.1200">  @Override</a>
<span class="sourceLineNo">1201</span><a id="line.1201">  public void visitLabel(final Label label) {</a>
<span class="sourceLineNo">1202</span><a id="line.1202">    // Resolve the forward references to this label, if any.</a>
<span class="sourceLineNo">1203</span><a id="line.1203">    hasAsmInstructions |= label.resolve(code.data, code.length);</a>
<span class="sourceLineNo">1204</span><a id="line.1204">    // visitLabel starts a new basic block (except for debug only labels), so we need to update the</a>
<span class="sourceLineNo">1205</span><a id="line.1205">    // previous and current block references and list of successors.</a>
<span class="sourceLineNo">1206</span><a id="line.1206">    if ((label.flags &amp; Label.FLAG_DEBUG_ONLY) != 0) {</a>
<span class="sourceLineNo">1207</span><a id="line.1207">      return;</a>
<span class="sourceLineNo">1208</span><a id="line.1208">    }</a>
<span class="sourceLineNo">1209</span><a id="line.1209">    if (compute == COMPUTE_ALL_FRAMES) {</a>
<span class="sourceLineNo">1210</span><a id="line.1210">      if (currentBasicBlock != null) {</a>
<span class="sourceLineNo">1211</span><a id="line.1211">        if (label.bytecodeOffset == currentBasicBlock.bytecodeOffset) {</a>
<span class="sourceLineNo">1212</span><a id="line.1212">          // We use {@link Label#getCanonicalInstance} to store the state of a basic block in only</a>
<span class="sourceLineNo">1213</span><a id="line.1213">          // one place, but this does not work for labels which have not been visited yet.</a>
<span class="sourceLineNo">1214</span><a id="line.1214">          // Therefore, when we detect here two labels having the same bytecode offset, we need to</a>
<span class="sourceLineNo">1215</span><a id="line.1215">          // - consolidate the state scattered in these two instances into the canonical instance:</a>
<span class="sourceLineNo">1216</span><a id="line.1216">          currentBasicBlock.flags |= (label.flags &amp; Label.FLAG_JUMP_TARGET);</a>
<span class="sourceLineNo">1217</span><a id="line.1217">          // - make sure the two instances share the same Frame instance (the implementation of</a>
<span class="sourceLineNo">1218</span><a id="line.1218">          // {@link Label#getCanonicalInstance} relies on this property; here label.frame should be</a>
<span class="sourceLineNo">1219</span><a id="line.1219">          // null):</a>
<span class="sourceLineNo">1220</span><a id="line.1220">          label.frame = currentBasicBlock.frame;</a>
<span class="sourceLineNo">1221</span><a id="line.1221">          // - and make sure to NOT assign 'label' into 'currentBasicBlock' or 'lastBasicBlock', so</a>
<span class="sourceLineNo">1222</span><a id="line.1222">          // that they still refer to the canonical instance for this bytecode offset.</a>
<span class="sourceLineNo">1223</span><a id="line.1223">          return;</a>
<span class="sourceLineNo">1224</span><a id="line.1224">        }</a>
<span class="sourceLineNo">1225</span><a id="line.1225">        // End the current basic block (with one new successor).</a>
<span class="sourceLineNo">1226</span><a id="line.1226">        addSuccessorToCurrentBasicBlock(Edge.JUMP, label);</a>
<span class="sourceLineNo">1227</span><a id="line.1227">      }</a>
<span class="sourceLineNo">1228</span><a id="line.1228">      // Append 'label' at the end of the basic block list.</a>
<span class="sourceLineNo">1229</span><a id="line.1229">      if (lastBasicBlock != null) {</a>
<span class="sourceLineNo">1230</span><a id="line.1230">        if (label.bytecodeOffset == lastBasicBlock.bytecodeOffset) {</a>
<span class="sourceLineNo">1231</span><a id="line.1231">          // Same comment as above.</a>
<span class="sourceLineNo">1232</span><a id="line.1232">          lastBasicBlock.flags |= (label.flags &amp; Label.FLAG_JUMP_TARGET);</a>
<span class="sourceLineNo">1233</span><a id="line.1233">          // Here label.frame should be null.</a>
<span class="sourceLineNo">1234</span><a id="line.1234">          label.frame = lastBasicBlock.frame;</a>
<span class="sourceLineNo">1235</span><a id="line.1235">          currentBasicBlock = lastBasicBlock;</a>
<span class="sourceLineNo">1236</span><a id="line.1236">          return;</a>
<span class="sourceLineNo">1237</span><a id="line.1237">        }</a>
<span class="sourceLineNo">1238</span><a id="line.1238">        lastBasicBlock.nextBasicBlock = label;</a>
<span class="sourceLineNo">1239</span><a id="line.1239">      }</a>
<span class="sourceLineNo">1240</span><a id="line.1240">      lastBasicBlock = label;</a>
<span class="sourceLineNo">1241</span><a id="line.1241">      // Make it the new current basic block.</a>
<span class="sourceLineNo">1242</span><a id="line.1242">      currentBasicBlock = label;</a>
<span class="sourceLineNo">1243</span><a id="line.1243">      // Here label.frame should be null.</a>
<span class="sourceLineNo">1244</span><a id="line.1244">      label.frame = new Frame(label);</a>
<span class="sourceLineNo">1245</span><a id="line.1245">    } else if (compute == COMPUTE_INSERTED_FRAMES) {</a>
<span class="sourceLineNo">1246</span><a id="line.1246">      if (currentBasicBlock == null) {</a>
<span class="sourceLineNo">1247</span><a id="line.1247">        // This case should happen only once, for the visitLabel call in the constructor. Indeed, if</a>
<span class="sourceLineNo">1248</span><a id="line.1248">        // compute is equal to COMPUTE_INSERTED_FRAMES, currentBasicBlock stays unchanged.</a>
<span class="sourceLineNo">1249</span><a id="line.1249">        currentBasicBlock = label;</a>
<span class="sourceLineNo">1250</span><a id="line.1250">      } else {</a>
<span class="sourceLineNo">1251</span><a id="line.1251">        // Update the frame owner so that a correct frame offset is computed in Frame.accept().</a>
<span class="sourceLineNo">1252</span><a id="line.1252">        currentBasicBlock.frame.owner = label;</a>
<span class="sourceLineNo">1253</span><a id="line.1253">      }</a>
<span class="sourceLineNo">1254</span><a id="line.1254">    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {</a>
<span class="sourceLineNo">1255</span><a id="line.1255">      if (currentBasicBlock != null) {</a>
<span class="sourceLineNo">1256</span><a id="line.1256">        // End the current basic block (with one new successor).</a>
<span class="sourceLineNo">1257</span><a id="line.1257">        currentBasicBlock.outputStackMax = (short) maxRelativeStackSize;</a>
<span class="sourceLineNo">1258</span><a id="line.1258">        addSuccessorToCurrentBasicBlock(relativeStackSize, label);</a>
<span class="sourceLineNo">1259</span><a id="line.1259">      }</a>
<span class="sourceLineNo">1260</span><a id="line.1260">      // Start a new current basic block, and reset the current and maximum relative stack sizes.</a>
<span class="sourceLineNo">1261</span><a id="line.1261">      currentBasicBlock = label;</a>
<span class="sourceLineNo">1262</span><a id="line.1262">      relativeStackSize = 0;</a>
<span class="sourceLineNo">1263</span><a id="line.1263">      maxRelativeStackSize = 0;</a>
<span class="sourceLineNo">1264</span><a id="line.1264">      // Append the new basic block at the end of the basic block list.</a>
<span class="sourceLineNo">1265</span><a id="line.1265">      if (lastBasicBlock != null) {</a>
<span class="sourceLineNo">1266</span><a id="line.1266">        lastBasicBlock.nextBasicBlock = label;</a>
<span class="sourceLineNo">1267</span><a id="line.1267">      }</a>
<span class="sourceLineNo">1268</span><a id="line.1268">      lastBasicBlock = label;</a>
<span class="sourceLineNo">1269</span><a id="line.1269">    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES &amp;&amp; currentBasicBlock == null) {</a>
<span class="sourceLineNo">1270</span><a id="line.1270">      // This case should happen only once, for the visitLabel call in the constructor. Indeed, if</a>
<span class="sourceLineNo">1271</span><a id="line.1271">      // compute is equal to COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES, currentBasicBlock stays</a>
<span class="sourceLineNo">1272</span><a id="line.1272">      // unchanged.</a>
<span class="sourceLineNo">1273</span><a id="line.1273">      currentBasicBlock = label;</a>
<span class="sourceLineNo">1274</span><a id="line.1274">    }</a>
<span class="sourceLineNo">1275</span><a id="line.1275">  }</a>
<span class="sourceLineNo">1276</span><a id="line.1276"></a>
<span class="sourceLineNo">1277</span><a id="line.1277">  @Override</a>
<span class="sourceLineNo">1278</span><a id="line.1278">  public void visitLdcInsn(final Object value) {</a>
<span class="sourceLineNo">1279</span><a id="line.1279">    lastBytecodeOffset = code.length;</a>
<span class="sourceLineNo">1280</span><a id="line.1280">    // Add the instruction to the bytecode of the method.</a>
<span class="sourceLineNo">1281</span><a id="line.1281">    Symbol constantSymbol = symbolTable.addConstant(value);</a>
<span class="sourceLineNo">1282</span><a id="line.1282">    int constantIndex = constantSymbol.index;</a>
<span class="sourceLineNo">1283</span><a id="line.1283">    boolean isLongOrDouble =</a>
<span class="sourceLineNo">1284</span><a id="line.1284">        constantSymbol.tag == Symbol.CONSTANT_LONG_TAG</a>
<span class="sourceLineNo">1285</span><a id="line.1285">            || constantSymbol.tag == Symbol.CONSTANT_DOUBLE_TAG;</a>
<span class="sourceLineNo">1286</span><a id="line.1286">    if (isLongOrDouble) {</a>
<span class="sourceLineNo">1287</span><a id="line.1287">      code.put12(Constants.LDC2_W, constantIndex);</a>
<span class="sourceLineNo">1288</span><a id="line.1288">    } else if (constantIndex &gt;= 256) {</a>
<span class="sourceLineNo">1289</span><a id="line.1289">      code.put12(Constants.LDC_W, constantIndex);</a>
<span class="sourceLineNo">1290</span><a id="line.1290">    } else {</a>
<span class="sourceLineNo">1291</span><a id="line.1291">      code.put11(Opcodes.LDC, constantIndex);</a>
<span class="sourceLineNo">1292</span><a id="line.1292">    }</a>
<span class="sourceLineNo">1293</span><a id="line.1293">    // If needed, update the maximum stack size and number of locals, and stack map frames.</a>
<span class="sourceLineNo">1294</span><a id="line.1294">    if (currentBasicBlock != null) {</a>
<span class="sourceLineNo">1295</span><a id="line.1295">      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {</a>
<span class="sourceLineNo">1296</span><a id="line.1296">        currentBasicBlock.frame.execute(Opcodes.LDC, 0, constantSymbol, symbolTable);</a>
<span class="sourceLineNo">1297</span><a id="line.1297">      } else {</a>
<span class="sourceLineNo">1298</span><a id="line.1298">        int size = relativeStackSize + (isLongOrDouble ? 2 : 1);</a>
<span class="sourceLineNo">1299</span><a id="line.1299">        if (size &gt; maxRelativeStackSize) {</a>
<span class="sourceLineNo">1300</span><a id="line.1300">          maxRelativeStackSize = size;</a>
<span class="sourceLineNo">1301</span><a id="line.1301">        }</a>
<span class="sourceLineNo">1302</span><a id="line.1302">        relativeStackSize = size;</a>
<span class="sourceLineNo">1303</span><a id="line.1303">      }</a>
<span class="sourceLineNo">1304</span><a id="line.1304">    }</a>
<span class="sourceLineNo">1305</span><a id="line.1305">  }</a>
<span class="sourceLineNo">1306</span><a id="line.1306"></a>
<span class="sourceLineNo">1307</span><a id="line.1307">  @Override</a>
<span class="sourceLineNo">1308</span><a id="line.1308">  public void visitIincInsn(final int var, final int increment) {</a>
<span class="sourceLineNo">1309</span><a id="line.1309">    lastBytecodeOffset = code.length;</a>
<span class="sourceLineNo">1310</span><a id="line.1310">    // Add the instruction to the bytecode of the method.</a>
<span class="sourceLineNo">1311</span><a id="line.1311">    if ((var &gt; 255) || (increment &gt; 127) || (increment &lt; -128)) {</a>
<span class="sourceLineNo">1312</span><a id="line.1312">      code.putByte(Constants.WIDE).put12(Opcodes.IINC, var).putShort(increment);</a>
<span class="sourceLineNo">1313</span><a id="line.1313">    } else {</a>
<span class="sourceLineNo">1314</span><a id="line.1314">      code.putByte(Opcodes.IINC).put11(var, increment);</a>
<span class="sourceLineNo">1315</span><a id="line.1315">    }</a>
<span class="sourceLineNo">1316</span><a id="line.1316">    // If needed, update the maximum stack size and number of locals, and stack map frames.</a>
<span class="sourceLineNo">1317</span><a id="line.1317">    if (currentBasicBlock != null</a>
<span class="sourceLineNo">1318</span><a id="line.1318">        &amp;&amp; (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES)) {</a>
<span class="sourceLineNo">1319</span><a id="line.1319">      currentBasicBlock.frame.execute(Opcodes.IINC, var, null, null);</a>
<span class="sourceLineNo">1320</span><a id="line.1320">    }</a>
<span class="sourceLineNo">1321</span><a id="line.1321">    if (compute != COMPUTE_NOTHING) {</a>
<span class="sourceLineNo">1322</span><a id="line.1322">      int currentMaxLocals = var + 1;</a>
<span class="sourceLineNo">1323</span><a id="line.1323">      if (currentMaxLocals &gt; maxLocals) {</a>
<span class="sourceLineNo">1324</span><a id="line.1324">        maxLocals = currentMaxLocals;</a>
<span class="sourceLineNo">1325</span><a id="line.1325">      }</a>
<span class="sourceLineNo">1326</span><a id="line.1326">    }</a>
<span class="sourceLineNo">1327</span><a id="line.1327">  }</a>
<span class="sourceLineNo">1328</span><a id="line.1328"></a>
<span class="sourceLineNo">1329</span><a id="line.1329">  @Override</a>
<span class="sourceLineNo">1330</span><a id="line.1330">  public void visitTableSwitchInsn(</a>
<span class="sourceLineNo">1331</span><a id="line.1331">      final int min, final int max, final Label dflt, final Label... labels) {</a>
<span class="sourceLineNo">1332</span><a id="line.1332">    lastBytecodeOffset = code.length;</a>
<span class="sourceLineNo">1333</span><a id="line.1333">    // Add the instruction to the bytecode of the method.</a>
<span class="sourceLineNo">1334</span><a id="line.1334">    code.putByte(Opcodes.TABLESWITCH).putByteArray(null, 0, (4 - code.length % 4) % 4);</a>
<span class="sourceLineNo">1335</span><a id="line.1335">    dflt.put(code, lastBytecodeOffset, true);</a>
<span class="sourceLineNo">1336</span><a id="line.1336">    code.putInt(min).putInt(max);</a>
<span class="sourceLineNo">1337</span><a id="line.1337">    for (Label label : labels) {</a>
<span class="sourceLineNo">1338</span><a id="line.1338">      label.put(code, lastBytecodeOffset, true);</a>
<span class="sourceLineNo">1339</span><a id="line.1339">    }</a>
<span class="sourceLineNo">1340</span><a id="line.1340">    // If needed, update the maximum stack size and number of locals, and stack map frames.</a>
<span class="sourceLineNo">1341</span><a id="line.1341">    visitSwitchInsn(dflt, labels);</a>
<span class="sourceLineNo">1342</span><a id="line.1342">  }</a>
<span class="sourceLineNo">1343</span><a id="line.1343"></a>
<span class="sourceLineNo">1344</span><a id="line.1344">  @Override</a>
<span class="sourceLineNo">1345</span><a id="line.1345">  public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {</a>
<span class="sourceLineNo">1346</span><a id="line.1346">    lastBytecodeOffset = code.length;</a>
<span class="sourceLineNo">1347</span><a id="line.1347">    // Add the instruction to the bytecode of the method.</a>
<span class="sourceLineNo">1348</span><a id="line.1348">    code.putByte(Opcodes.LOOKUPSWITCH).putByteArray(null, 0, (4 - code.length % 4) % 4);</a>
<span class="sourceLineNo">1349</span><a id="line.1349">    dflt.put(code, lastBytecodeOffset, true);</a>
<span class="sourceLineNo">1350</span><a id="line.1350">    code.putInt(labels.length);</a>
<span class="sourceLineNo">1351</span><a id="line.1351">    for (int i = 0; i &lt; labels.length; ++i) {</a>
<span class="sourceLineNo">1352</span><a id="line.1352">      code.putInt(keys[i]);</a>
<span class="sourceLineNo">1353</span><a id="line.1353">      labels[i].put(code, lastBytecodeOffset, true);</a>
<span class="sourceLineNo">1354</span><a id="line.1354">    }</a>
<span class="sourceLineNo">1355</span><a id="line.1355">    // If needed, update the maximum stack size and number of locals, and stack map frames.</a>
<span class="sourceLineNo">1356</span><a id="line.1356">    visitSwitchInsn(dflt, labels);</a>
<span class="sourceLineNo">1357</span><a id="line.1357">  }</a>
<span class="sourceLineNo">1358</span><a id="line.1358"></a>
<span class="sourceLineNo">1359</span><a id="line.1359">  private void visitSwitchInsn(final Label dflt, final Label[] labels) {</a>
<span class="sourceLineNo">1360</span><a id="line.1360">    if (currentBasicBlock != null) {</a>
<span class="sourceLineNo">1361</span><a id="line.1361">      if (compute == COMPUTE_ALL_FRAMES) {</a>
<span class="sourceLineNo">1362</span><a id="line.1362">        currentBasicBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);</a>
<span class="sourceLineNo">1363</span><a id="line.1363">        // Add all the labels as successors of the current basic block.</a>
<span class="sourceLineNo">1364</span><a id="line.1364">        addSuccessorToCurrentBasicBlock(Edge.JUMP, dflt);</a>
<span class="sourceLineNo">1365</span><a id="line.1365">        dflt.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;</a>
<span class="sourceLineNo">1366</span><a id="line.1366">        for (Label label : labels) {</a>
<span class="sourceLineNo">1367</span><a id="line.1367">          addSuccessorToCurrentBasicBlock(Edge.JUMP, label);</a>
<span class="sourceLineNo">1368</span><a id="line.1368">          label.getCanonicalInstance().flags |= Label.FLAG_JUMP_TARGET;</a>
<span class="sourceLineNo">1369</span><a id="line.1369">        }</a>
<span class="sourceLineNo">1370</span><a id="line.1370">      } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {</a>
<span class="sourceLineNo">1371</span><a id="line.1371">        // No need to update maxRelativeStackSize (the stack size delta is always negative).</a>
<span class="sourceLineNo">1372</span><a id="line.1372">        --relativeStackSize;</a>
<span class="sourceLineNo">1373</span><a id="line.1373">        // Add all the labels as successors of the current basic block.</a>
<span class="sourceLineNo">1374</span><a id="line.1374">        addSuccessorToCurrentBasicBlock(relativeStackSize, dflt);</a>
<span class="sourceLineNo">1375</span><a id="line.1375">        for (Label label : labels) {</a>
<span class="sourceLineNo">1376</span><a id="line.1376">          addSuccessorToCurrentBasicBlock(relativeStackSize, label);</a>
<span class="sourceLineNo">1377</span><a id="line.1377">        }</a>
<span class="sourceLineNo">1378</span><a id="line.1378">      }</a>
<span class="sourceLineNo">1379</span><a id="line.1379">      // End the current basic block.</a>
<span class="sourceLineNo">1380</span><a id="line.1380">      endCurrentBasicBlockWithNoSuccessor();</a>
<span class="sourceLineNo">1381</span><a id="line.1381">    }</a>
<span class="sourceLineNo">1382</span><a id="line.1382">  }</a>
<span class="sourceLineNo">1383</span><a id="line.1383"></a>
<span class="sourceLineNo">1384</span><a id="line.1384">  @Override</a>
<span class="sourceLineNo">1385</span><a id="line.1385">  public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {</a>
<span class="sourceLineNo">1386</span><a id="line.1386">    lastBytecodeOffset = code.length;</a>
<span class="sourceLineNo">1387</span><a id="line.1387">    // Add the instruction to the bytecode of the method.</a>
<span class="sourceLineNo">1388</span><a id="line.1388">    Symbol descSymbol = symbolTable.addConstantClass(descriptor);</a>
<span class="sourceLineNo">1389</span><a id="line.1389">    code.put12(Opcodes.MULTIANEWARRAY, descSymbol.index).putByte(numDimensions);</a>
<span class="sourceLineNo">1390</span><a id="line.1390">    // If needed, update the maximum stack size and number of locals, and stack map frames.</a>
<span class="sourceLineNo">1391</span><a id="line.1391">    if (currentBasicBlock != null) {</a>
<span class="sourceLineNo">1392</span><a id="line.1392">      if (compute == COMPUTE_ALL_FRAMES || compute == COMPUTE_INSERTED_FRAMES) {</a>
<span class="sourceLineNo">1393</span><a id="line.1393">        currentBasicBlock.frame.execute(</a>
<span class="sourceLineNo">1394</span><a id="line.1394">            Opcodes.MULTIANEWARRAY, numDimensions, descSymbol, symbolTable);</a>
<span class="sourceLineNo">1395</span><a id="line.1395">      } else {</a>
<span class="sourceLineNo">1396</span><a id="line.1396">        // No need to update maxRelativeStackSize (the stack size delta is always negative).</a>
<span class="sourceLineNo">1397</span><a id="line.1397">        relativeStackSize += 1 - numDimensions;</a>
<span class="sourceLineNo">1398</span><a id="line.1398">      }</a>
<span class="sourceLineNo">1399</span><a id="line.1399">    }</a>
<span class="sourceLineNo">1400</span><a id="line.1400">  }</a>
<span class="sourceLineNo">1401</span><a id="line.1401"></a>
<span class="sourceLineNo">1402</span><a id="line.1402">  @Override</a>
<span class="sourceLineNo">1403</span><a id="line.1403">  public AnnotationVisitor visitInsnAnnotation(</a>
<span class="sourceLineNo">1404</span><a id="line.1404">      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {</a>
<span class="sourceLineNo">1405</span><a id="line.1405">    // Create a ByteVector to hold a 'type_annotation' JVMS structure.</a>
<span class="sourceLineNo">1406</span><a id="line.1406">    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.</a>
<span class="sourceLineNo">1407</span><a id="line.1407">    ByteVector typeAnnotation = new ByteVector();</a>
<span class="sourceLineNo">1408</span><a id="line.1408">    // Write target_type, target_info, and target_path.</a>
<span class="sourceLineNo">1409</span><a id="line.1409">    TypeReference.putTarget((typeRef &amp; 0xFF0000FF) | (lastBytecodeOffset &lt;&lt; 8), typeAnnotation);</a>
<span class="sourceLineNo">1410</span><a id="line.1410">    TypePath.put(typePath, typeAnnotation);</a>
<span class="sourceLineNo">1411</span><a id="line.1411">    // Write type_index and reserve space for num_element_value_pairs.</a>
<span class="sourceLineNo">1412</span><a id="line.1412">    typeAnnotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);</a>
<span class="sourceLineNo">1413</span><a id="line.1413">    if (visible) {</a>
<span class="sourceLineNo">1414</span><a id="line.1414">      return lastCodeRuntimeVisibleTypeAnnotation =</a>
<span class="sourceLineNo">1415</span><a id="line.1415">          new AnnotationWriter(symbolTable, typeAnnotation, lastCodeRuntimeVisibleTypeAnnotation);</a>
<span class="sourceLineNo">1416</span><a id="line.1416">    } else {</a>
<span class="sourceLineNo">1417</span><a id="line.1417">      return lastCodeRuntimeInvisibleTypeAnnotation =</a>
<span class="sourceLineNo">1418</span><a id="line.1418">          new AnnotationWriter(symbolTable, typeAnnotation, lastCodeRuntimeInvisibleTypeAnnotation);</a>
<span class="sourceLineNo">1419</span><a id="line.1419">    }</a>
<span class="sourceLineNo">1420</span><a id="line.1420">  }</a>
<span class="sourceLineNo">1421</span><a id="line.1421"></a>
<span class="sourceLineNo">1422</span><a id="line.1422">  @Override</a>
<span class="sourceLineNo">1423</span><a id="line.1423">  public void visitTryCatchBlock(</a>
<span class="sourceLineNo">1424</span><a id="line.1424">      final Label start, final Label end, final Label handler, final String type) {</a>
<span class="sourceLineNo">1425</span><a id="line.1425">    Handler newHandler =</a>
<span class="sourceLineNo">1426</span><a id="line.1426">        new Handler(</a>
<span class="sourceLineNo">1427</span><a id="line.1427">            start, end, handler, type != null ? symbolTable.addConstantClass(type).index : 0, type);</a>
<span class="sourceLineNo">1428</span><a id="line.1428">    if (firstHandler == null) {</a>
<span class="sourceLineNo">1429</span><a id="line.1429">      firstHandler = newHandler;</a>
<span class="sourceLineNo">1430</span><a id="line.1430">    } else {</a>
<span class="sourceLineNo">1431</span><a id="line.1431">      lastHandler.nextHandler = newHandler;</a>
<span class="sourceLineNo">1432</span><a id="line.1432">    }</a>
<span class="sourceLineNo">1433</span><a id="line.1433">    lastHandler = newHandler;</a>
<span class="sourceLineNo">1434</span><a id="line.1434">  }</a>
<span class="sourceLineNo">1435</span><a id="line.1435"></a>
<span class="sourceLineNo">1436</span><a id="line.1436">  @Override</a>
<span class="sourceLineNo">1437</span><a id="line.1437">  public AnnotationVisitor visitTryCatchAnnotation(</a>
<span class="sourceLineNo">1438</span><a id="line.1438">      final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {</a>
<span class="sourceLineNo">1439</span><a id="line.1439">    // Create a ByteVector to hold a 'type_annotation' JVMS structure.</a>
<span class="sourceLineNo">1440</span><a id="line.1440">    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.</a>
<span class="sourceLineNo">1441</span><a id="line.1441">    ByteVector typeAnnotation = new ByteVector();</a>
<span class="sourceLineNo">1442</span><a id="line.1442">    // Write target_type, target_info, and target_path.</a>
<span class="sourceLineNo">1443</span><a id="line.1443">    TypeReference.putTarget(typeRef, typeAnnotation);</a>
<span class="sourceLineNo">1444</span><a id="line.1444">    TypePath.put(typePath, typeAnnotation);</a>
<span class="sourceLineNo">1445</span><a id="line.1445">    // Write type_index and reserve space for num_element_value_pairs.</a>
<span class="sourceLineNo">1446</span><a id="line.1446">    typeAnnotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);</a>
<span class="sourceLineNo">1447</span><a id="line.1447">    if (visible) {</a>
<span class="sourceLineNo">1448</span><a id="line.1448">      return lastCodeRuntimeVisibleTypeAnnotation =</a>
<span class="sourceLineNo">1449</span><a id="line.1449">          new AnnotationWriter(symbolTable, typeAnnotation, lastCodeRuntimeVisibleTypeAnnotation);</a>
<span class="sourceLineNo">1450</span><a id="line.1450">    } else {</a>
<span class="sourceLineNo">1451</span><a id="line.1451">      return lastCodeRuntimeInvisibleTypeAnnotation =</a>
<span class="sourceLineNo">1452</span><a id="line.1452">          new AnnotationWriter(symbolTable, typeAnnotation, lastCodeRuntimeInvisibleTypeAnnotation);</a>
<span class="sourceLineNo">1453</span><a id="line.1453">    }</a>
<span class="sourceLineNo">1454</span><a id="line.1454">  }</a>
<span class="sourceLineNo">1455</span><a id="line.1455"></a>
<span class="sourceLineNo">1456</span><a id="line.1456">  @Override</a>
<span class="sourceLineNo">1457</span><a id="line.1457">  public void visitLocalVariable(</a>
<span class="sourceLineNo">1458</span><a id="line.1458">      final String name,</a>
<span class="sourceLineNo">1459</span><a id="line.1459">      final String descriptor,</a>
<span class="sourceLineNo">1460</span><a id="line.1460">      final String signature,</a>
<span class="sourceLineNo">1461</span><a id="line.1461">      final Label start,</a>
<span class="sourceLineNo">1462</span><a id="line.1462">      final Label end,</a>
<span class="sourceLineNo">1463</span><a id="line.1463">      final int index) {</a>
<span class="sourceLineNo">1464</span><a id="line.1464">    if (signature != null) {</a>
<span class="sourceLineNo">1465</span><a id="line.1465">      if (localVariableTypeTable == null) {</a>
<span class="sourceLineNo">1466</span><a id="line.1466">        localVariableTypeTable = new ByteVector();</a>
<span class="sourceLineNo">1467</span><a id="line.1467">      }</a>
<span class="sourceLineNo">1468</span><a id="line.1468">      ++localVariableTypeTableLength;</a>
<span class="sourceLineNo">1469</span><a id="line.1469">      localVariableTypeTable</a>
<span class="sourceLineNo">1470</span><a id="line.1470">          .putShort(start.bytecodeOffset)</a>
<span class="sourceLineNo">1471</span><a id="line.1471">          .putShort(end.bytecodeOffset - start.bytecodeOffset)</a>
<span class="sourceLineNo">1472</span><a id="line.1472">          .putShort(symbolTable.addConstantUtf8(name))</a>
<span class="sourceLineNo">1473</span><a id="line.1473">          .putShort(symbolTable.addConstantUtf8(signature))</a>
<span class="sourceLineNo">1474</span><a id="line.1474">          .putShort(index);</a>
<span class="sourceLineNo">1475</span><a id="line.1475">    }</a>
<span class="sourceLineNo">1476</span><a id="line.1476">    if (localVariableTable == null) {</a>
<span class="sourceLineNo">1477</span><a id="line.1477">      localVariableTable = new ByteVector();</a>
<span class="sourceLineNo">1478</span><a id="line.1478">    }</a>
<span class="sourceLineNo">1479</span><a id="line.1479">    ++localVariableTableLength;</a>
<span class="sourceLineNo">1480</span><a id="line.1480">    localVariableTable</a>
<span class="sourceLineNo">1481</span><a id="line.1481">        .putShort(start.bytecodeOffset)</a>
<span class="sourceLineNo">1482</span><a id="line.1482">        .putShort(end.bytecodeOffset - start.bytecodeOffset)</a>
<span class="sourceLineNo">1483</span><a id="line.1483">        .putShort(symbolTable.addConstantUtf8(name))</a>
<span class="sourceLineNo">1484</span><a id="line.1484">        .putShort(symbolTable.addConstantUtf8(descriptor))</a>
<span class="sourceLineNo">1485</span><a id="line.1485">        .putShort(index);</a>
<span class="sourceLineNo">1486</span><a id="line.1486">    if (compute != COMPUTE_NOTHING) {</a>
<span class="sourceLineNo">1487</span><a id="line.1487">      char firstDescChar = descriptor.charAt(0);</a>
<span class="sourceLineNo">1488</span><a id="line.1488">      int currentMaxLocals = index + (firstDescChar == 'J' || firstDescChar == 'D' ? 2 : 1);</a>
<span class="sourceLineNo">1489</span><a id="line.1489">      if (currentMaxLocals &gt; maxLocals) {</a>
<span class="sourceLineNo">1490</span><a id="line.1490">        maxLocals = currentMaxLocals;</a>
<span class="sourceLineNo">1491</span><a id="line.1491">      }</a>
<span class="sourceLineNo">1492</span><a id="line.1492">    }</a>
<span class="sourceLineNo">1493</span><a id="line.1493">  }</a>
<span class="sourceLineNo">1494</span><a id="line.1494"></a>
<span class="sourceLineNo">1495</span><a id="line.1495">  @Override</a>
<span class="sourceLineNo">1496</span><a id="line.1496">  public AnnotationVisitor visitLocalVariableAnnotation(</a>
<span class="sourceLineNo">1497</span><a id="line.1497">      final int typeRef,</a>
<span class="sourceLineNo">1498</span><a id="line.1498">      final TypePath typePath,</a>
<span class="sourceLineNo">1499</span><a id="line.1499">      final Label[] start,</a>
<span class="sourceLineNo">1500</span><a id="line.1500">      final Label[] end,</a>
<span class="sourceLineNo">1501</span><a id="line.1501">      final int[] index,</a>
<span class="sourceLineNo">1502</span><a id="line.1502">      final String descriptor,</a>
<span class="sourceLineNo">1503</span><a id="line.1503">      final boolean visible) {</a>
<span class="sourceLineNo">1504</span><a id="line.1504">    // Create a ByteVector to hold a 'type_annotation' JVMS structure.</a>
<span class="sourceLineNo">1505</span><a id="line.1505">    // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.20.</a>
<span class="sourceLineNo">1506</span><a id="line.1506">    ByteVector typeAnnotation = new ByteVector();</a>
<span class="sourceLineNo">1507</span><a id="line.1507">    // Write target_type, target_info, and target_path.</a>
<span class="sourceLineNo">1508</span><a id="line.1508">    typeAnnotation.putByte(typeRef &gt;&gt;&gt; 24).putShort(start.length);</a>
<span class="sourceLineNo">1509</span><a id="line.1509">    for (int i = 0; i &lt; start.length; ++i) {</a>
<span class="sourceLineNo">1510</span><a id="line.1510">      typeAnnotation</a>
<span class="sourceLineNo">1511</span><a id="line.1511">          .putShort(start[i].bytecodeOffset)</a>
<span class="sourceLineNo">1512</span><a id="line.1512">          .putShort(end[i].bytecodeOffset - start[i].bytecodeOffset)</a>
<span class="sourceLineNo">1513</span><a id="line.1513">          .putShort(index[i]);</a>
<span class="sourceLineNo">1514</span><a id="line.1514">    }</a>
<span class="sourceLineNo">1515</span><a id="line.1515">    TypePath.put(typePath, typeAnnotation);</a>
<span class="sourceLineNo">1516</span><a id="line.1516">    // Write type_index and reserve space for num_element_value_pairs.</a>
<span class="sourceLineNo">1517</span><a id="line.1517">    typeAnnotation.putShort(symbolTable.addConstantUtf8(descriptor)).putShort(0);</a>
<span class="sourceLineNo">1518</span><a id="line.1518">    if (visible) {</a>
<span class="sourceLineNo">1519</span><a id="line.1519">      return lastCodeRuntimeVisibleTypeAnnotation =</a>
<span class="sourceLineNo">1520</span><a id="line.1520">          new AnnotationWriter(symbolTable, typeAnnotation, lastCodeRuntimeVisibleTypeAnnotation);</a>
<span class="sourceLineNo">1521</span><a id="line.1521">    } else {</a>
<span class="sourceLineNo">1522</span><a id="line.1522">      return lastCodeRuntimeInvisibleTypeAnnotation =</a>
<span class="sourceLineNo">1523</span><a id="line.1523">          new AnnotationWriter(symbolTable, typeAnnotation, lastCodeRuntimeInvisibleTypeAnnotation);</a>
<span class="sourceLineNo">1524</span><a id="line.1524">    }</a>
<span class="sourceLineNo">1525</span><a id="line.1525">  }</a>
<span class="sourceLineNo">1526</span><a id="line.1526"></a>
<span class="sourceLineNo">1527</span><a id="line.1527">  @Override</a>
<span class="sourceLineNo">1528</span><a id="line.1528">  public void visitLineNumber(final int line, final Label start) {</a>
<span class="sourceLineNo">1529</span><a id="line.1529">    if (lineNumberTable == null) {</a>
<span class="sourceLineNo">1530</span><a id="line.1530">      lineNumberTable = new ByteVector();</a>
<span class="sourceLineNo">1531</span><a id="line.1531">    }</a>
<span class="sourceLineNo">1532</span><a id="line.1532">    ++lineNumberTableLength;</a>
<span class="sourceLineNo">1533</span><a id="line.1533">    lineNumberTable.putShort(start.bytecodeOffset);</a>
<span class="sourceLineNo">1534</span><a id="line.1534">    lineNumberTable.putShort(line);</a>
<span class="sourceLineNo">1535</span><a id="line.1535">  }</a>
<span class="sourceLineNo">1536</span><a id="line.1536"></a>
<span class="sourceLineNo">1537</span><a id="line.1537">  @Override</a>
<span class="sourceLineNo">1538</span><a id="line.1538">  public void visitMaxs(final int maxStack, final int maxLocals) {</a>
<span class="sourceLineNo">1539</span><a id="line.1539">    if (compute == COMPUTE_ALL_FRAMES) {</a>
<span class="sourceLineNo">1540</span><a id="line.1540">      computeAllFrames();</a>
<span class="sourceLineNo">1541</span><a id="line.1541">    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {</a>
<span class="sourceLineNo">1542</span><a id="line.1542">      computeMaxStackAndLocal();</a>
<span class="sourceLineNo">1543</span><a id="line.1543">    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES) {</a>
<span class="sourceLineNo">1544</span><a id="line.1544">      this.maxStack = maxRelativeStackSize;</a>
<span class="sourceLineNo">1545</span><a id="line.1545">    } else {</a>
<span class="sourceLineNo">1546</span><a id="line.1546">      this.maxStack = maxStack;</a>
<span class="sourceLineNo">1547</span><a id="line.1547">      this.maxLocals = maxLocals;</a>
<span class="sourceLineNo">1548</span><a id="line.1548">    }</a>
<span class="sourceLineNo">1549</span><a id="line.1549">  }</a>
<span class="sourceLineNo">1550</span><a id="line.1550"></a>
<span class="sourceLineNo">1551</span><a id="line.1551">  /** Computes all the stack map frames of the method, from scratch. */</a>
<span class="sourceLineNo">1552</span><a id="line.1552">  private void computeAllFrames() {</a>
<span class="sourceLineNo">1553</span><a id="line.1553">    // Complete the control flow graph with exception handler blocks.</a>
<span class="sourceLineNo">1554</span><a id="line.1554">    Handler handler = firstHandler;</a>
<span class="sourceLineNo">1555</span><a id="line.1555">    while (handler != null) {</a>
<span class="sourceLineNo">1556</span><a id="line.1556">      String catchTypeDescriptor =</a>
<span class="sourceLineNo">1557</span><a id="line.1557">          handler.catchTypeDescriptor == null ? "java/lang/Throwable" : handler.catchTypeDescriptor;</a>
<span class="sourceLineNo">1558</span><a id="line.1558">      int catchType = Frame.getAbstractTypeFromInternalName(symbolTable, catchTypeDescriptor);</a>
<span class="sourceLineNo">1559</span><a id="line.1559">      // Mark handlerBlock as an exception handler.</a>
<span class="sourceLineNo">1560</span><a id="line.1560">      Label handlerBlock = handler.handlerPc.getCanonicalInstance();</a>
<span class="sourceLineNo">1561</span><a id="line.1561">      handlerBlock.flags |= Label.FLAG_JUMP_TARGET;</a>
<span class="sourceLineNo">1562</span><a id="line.1562">      // Add handlerBlock as a successor of all the basic blocks in the exception handler range.</a>
<span class="sourceLineNo">1563</span><a id="line.1563">      Label handlerRangeBlock = handler.startPc.getCanonicalInstance();</a>
<span class="sourceLineNo">1564</span><a id="line.1564">      Label handlerRangeEnd = handler.endPc.getCanonicalInstance();</a>
<span class="sourceLineNo">1565</span><a id="line.1565">      while (handlerRangeBlock != handlerRangeEnd) {</a>
<span class="sourceLineNo">1566</span><a id="line.1566">        handlerRangeBlock.outgoingEdges =</a>
<span class="sourceLineNo">1567</span><a id="line.1567">            new Edge(catchType, handlerBlock, handlerRangeBlock.outgoingEdges);</a>
<span class="sourceLineNo">1568</span><a id="line.1568">        handlerRangeBlock = handlerRangeBlock.nextBasicBlock;</a>
<span class="sourceLineNo">1569</span><a id="line.1569">      }</a>
<span class="sourceLineNo">1570</span><a id="line.1570">      handler = handler.nextHandler;</a>
<span class="sourceLineNo">1571</span><a id="line.1571">    }</a>
<span class="sourceLineNo">1572</span><a id="line.1572"></a>
<span class="sourceLineNo">1573</span><a id="line.1573">    // Create and visit the first (implicit) frame.</a>
<span class="sourceLineNo">1574</span><a id="line.1574">    Frame firstFrame = firstBasicBlock.frame;</a>
<span class="sourceLineNo">1575</span><a id="line.1575">    firstFrame.setInputFrameFromDescriptor(symbolTable, accessFlags, descriptor, this.maxLocals);</a>
<span class="sourceLineNo">1576</span><a id="line.1576">    firstFrame.accept(this);</a>
<span class="sourceLineNo">1577</span><a id="line.1577"></a>
<span class="sourceLineNo">1578</span><a id="line.1578">    // Fix point algorithm: add the first basic block to a list of blocks to process (i.e. blocks</a>
<span class="sourceLineNo">1579</span><a id="line.1579">    // whose stack map frame has changed) and, while there are blocks to process, remove one from</a>
<span class="sourceLineNo">1580</span><a id="line.1580">    // the list and update the stack map frames of its successor blocks in the control flow graph</a>
<span class="sourceLineNo">1581</span><a id="line.1581">    // (which might change them, in which case these blocks must be processed too, and are thus</a>
<span class="sourceLineNo">1582</span><a id="line.1582">    // added to the list of blocks to process). Also compute the maximum stack size of the method,</a>
<span class="sourceLineNo">1583</span><a id="line.1583">    // as a by-product.</a>
<span class="sourceLineNo">1584</span><a id="line.1584">    Label listOfBlocksToProcess = firstBasicBlock;</a>
<span class="sourceLineNo">1585</span><a id="line.1585">    listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;</a>
<span class="sourceLineNo">1586</span><a id="line.1586">    int maxStackSize = 0;</a>
<span class="sourceLineNo">1587</span><a id="line.1587">    while (listOfBlocksToProcess != Label.EMPTY_LIST) {</a>
<span class="sourceLineNo">1588</span><a id="line.1588">      // Remove a basic block from the list of blocks to process.</a>
<span class="sourceLineNo">1589</span><a id="line.1589">      Label basicBlock = listOfBlocksToProcess;</a>
<span class="sourceLineNo">1590</span><a id="line.1590">      listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;</a>
<span class="sourceLineNo">1591</span><a id="line.1591">      basicBlock.nextListElement = null;</a>
<span class="sourceLineNo">1592</span><a id="line.1592">      // By definition, basicBlock is reachable.</a>
<span class="sourceLineNo">1593</span><a id="line.1593">      basicBlock.flags |= Label.FLAG_REACHABLE;</a>
<span class="sourceLineNo">1594</span><a id="line.1594">      // Update the (absolute) maximum stack size.</a>
<span class="sourceLineNo">1595</span><a id="line.1595">      int maxBlockStackSize = basicBlock.frame.getInputStackSize() + basicBlock.outputStackMax;</a>
<span class="sourceLineNo">1596</span><a id="line.1596">      if (maxBlockStackSize &gt; maxStackSize) {</a>
<span class="sourceLineNo">1597</span><a id="line.1597">        maxStackSize = maxBlockStackSize;</a>
<span class="sourceLineNo">1598</span><a id="line.1598">      }</a>
<span class="sourceLineNo">1599</span><a id="line.1599">      // Update the successor blocks of basicBlock in the control flow graph.</a>
<span class="sourceLineNo">1600</span><a id="line.1600">      Edge outgoingEdge = basicBlock.outgoingEdges;</a>
<span class="sourceLineNo">1601</span><a id="line.1601">      while (outgoingEdge != null) {</a>
<span class="sourceLineNo">1602</span><a id="line.1602">        Label successorBlock = outgoingEdge.successor.getCanonicalInstance();</a>
<span class="sourceLineNo">1603</span><a id="line.1603">        boolean successorBlockChanged =</a>
<span class="sourceLineNo">1604</span><a id="line.1604">            basicBlock.frame.merge(symbolTable, successorBlock.frame, outgoingEdge.info);</a>
<span class="sourceLineNo">1605</span><a id="line.1605">        if (successorBlockChanged &amp;&amp; successorBlock.nextListElement == null) {</a>
<span class="sourceLineNo">1606</span><a id="line.1606">          // If successorBlock has changed it must be processed. Thus, if it is not already in the</a>
<span class="sourceLineNo">1607</span><a id="line.1607">          // list of blocks to process, add it to this list.</a>
<span class="sourceLineNo">1608</span><a id="line.1608">          successorBlock.nextListElement = listOfBlocksToProcess;</a>
<span class="sourceLineNo">1609</span><a id="line.1609">          listOfBlocksToProcess = successorBlock;</a>
<span class="sourceLineNo">1610</span><a id="line.1610">        }</a>
<span class="sourceLineNo">1611</span><a id="line.1611">        outgoingEdge = outgoingEdge.nextEdge;</a>
<span class="sourceLineNo">1612</span><a id="line.1612">      }</a>
<span class="sourceLineNo">1613</span><a id="line.1613">    }</a>
<span class="sourceLineNo">1614</span><a id="line.1614"></a>
<span class="sourceLineNo">1615</span><a id="line.1615">    // Loop over all the basic blocks and visit the stack map frames that must be stored in the</a>
<span class="sourceLineNo">1616</span><a id="line.1616">    // StackMapTable attribute. Also replace unreachable code with NOP* ATHROW, and remove it from</a>
<span class="sourceLineNo">1617</span><a id="line.1617">    // exception handler ranges.</a>
<span class="sourceLineNo">1618</span><a id="line.1618">    Label basicBlock = firstBasicBlock;</a>
<span class="sourceLineNo">1619</span><a id="line.1619">    while (basicBlock != null) {</a>
<span class="sourceLineNo">1620</span><a id="line.1620">      if ((basicBlock.flags &amp; (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE))</a>
<span class="sourceLineNo">1621</span><a id="line.1621">          == (Label.FLAG_JUMP_TARGET | Label.FLAG_REACHABLE)) {</a>
<span class="sourceLineNo">1622</span><a id="line.1622">        basicBlock.frame.accept(this);</a>
<span class="sourceLineNo">1623</span><a id="line.1623">      }</a>
<span class="sourceLineNo">1624</span><a id="line.1624">      if ((basicBlock.flags &amp; Label.FLAG_REACHABLE) == 0) {</a>
<span class="sourceLineNo">1625</span><a id="line.1625">        // Find the start and end bytecode offsets of this unreachable block.</a>
<span class="sourceLineNo">1626</span><a id="line.1626">        Label nextBasicBlock = basicBlock.nextBasicBlock;</a>
<span class="sourceLineNo">1627</span><a id="line.1627">        int startOffset = basicBlock.bytecodeOffset;</a>
<span class="sourceLineNo">1628</span><a id="line.1628">        int endOffset = (nextBasicBlock == null ? code.length : nextBasicBlock.bytecodeOffset) - 1;</a>
<span class="sourceLineNo">1629</span><a id="line.1629">        if (endOffset &gt;= startOffset) {</a>
<span class="sourceLineNo">1630</span><a id="line.1630">          // Replace its instructions with NOP ... NOP ATHROW.</a>
<span class="sourceLineNo">1631</span><a id="line.1631">          for (int i = startOffset; i &lt; endOffset; ++i) {</a>
<span class="sourceLineNo">1632</span><a id="line.1632">            code.data[i] = Opcodes.NOP;</a>
<span class="sourceLineNo">1633</span><a id="line.1633">          }</a>
<span class="sourceLineNo">1634</span><a id="line.1634">          code.data[endOffset] = (byte) Opcodes.ATHROW;</a>
<span class="sourceLineNo">1635</span><a id="line.1635">          // Emit a frame for this unreachable block, with no local and a Throwable on the stack</a>
<span class="sourceLineNo">1636</span><a id="line.1636">          // (so that the ATHROW could consume this Throwable if it were reachable).</a>
<span class="sourceLineNo">1637</span><a id="line.1637">          int frameIndex = visitFrameStart(startOffset, /* nLocal = */ 0, /* nStack = */ 1);</a>
<span class="sourceLineNo">1638</span><a id="line.1638">          currentFrame[frameIndex] =</a>
<span class="sourceLineNo">1639</span><a id="line.1639">              Frame.getAbstractTypeFromInternalName(symbolTable, "java/lang/Throwable");</a>
<span class="sourceLineNo">1640</span><a id="line.1640">          visitFrameEnd();</a>
<span class="sourceLineNo">1641</span><a id="line.1641">          // Remove this unreachable basic block from the exception handler ranges.</a>
<span class="sourceLineNo">1642</span><a id="line.1642">          firstHandler = Handler.removeRange(firstHandler, basicBlock, nextBasicBlock);</a>
<span class="sourceLineNo">1643</span><a id="line.1643">          // The maximum stack size is now at least one, because of the Throwable declared above.</a>
<span class="sourceLineNo">1644</span><a id="line.1644">          maxStackSize = Math.max(maxStackSize, 1);</a>
<span class="sourceLineNo">1645</span><a id="line.1645">        }</a>
<span class="sourceLineNo">1646</span><a id="line.1646">      }</a>
<span class="sourceLineNo">1647</span><a id="line.1647">      basicBlock = basicBlock.nextBasicBlock;</a>
<span class="sourceLineNo">1648</span><a id="line.1648">    }</a>
<span class="sourceLineNo">1649</span><a id="line.1649"></a>
<span class="sourceLineNo">1650</span><a id="line.1650">    this.maxStack = maxStackSize;</a>
<span class="sourceLineNo">1651</span><a id="line.1651">  }</a>
<span class="sourceLineNo">1652</span><a id="line.1652"></a>
<span class="sourceLineNo">1653</span><a id="line.1653">  /** Computes the maximum stack size of the method. */</a>
<span class="sourceLineNo">1654</span><a id="line.1654">  private void computeMaxStackAndLocal() {</a>
<span class="sourceLineNo">1655</span><a id="line.1655">    // Complete the control flow graph with exception handler blocks.</a>
<span class="sourceLineNo">1656</span><a id="line.1656">    Handler handler = firstHandler;</a>
<span class="sourceLineNo">1657</span><a id="line.1657">    while (handler != null) {</a>
<span class="sourceLineNo">1658</span><a id="line.1658">      Label handlerBlock = handler.handlerPc;</a>
<span class="sourceLineNo">1659</span><a id="line.1659">      Label handlerRangeBlock = handler.startPc;</a>
<span class="sourceLineNo">1660</span><a id="line.1660">      Label handlerRangeEnd = handler.endPc;</a>
<span class="sourceLineNo">1661</span><a id="line.1661">      // Add handlerBlock as a successor of all the basic blocks in the exception handler range.</a>
<span class="sourceLineNo">1662</span><a id="line.1662">      while (handlerRangeBlock != handlerRangeEnd) {</a>
<span class="sourceLineNo">1663</span><a id="line.1663">        if ((handlerRangeBlock.flags &amp; Label.FLAG_SUBROUTINE_CALLER) == 0) {</a>
<span class="sourceLineNo">1664</span><a id="line.1664">          handlerRangeBlock.outgoingEdges =</a>
<span class="sourceLineNo">1665</span><a id="line.1665">              new Edge(Edge.EXCEPTION, handlerBlock, handlerRangeBlock.outgoingEdges);</a>
<span class="sourceLineNo">1666</span><a id="line.1666">        } else {</a>
<span class="sourceLineNo">1667</span><a id="line.1667">          // If handlerRangeBlock is a JSR block, add handlerBlock after the first two outgoing</a>
<span class="sourceLineNo">1668</span><a id="line.1668">          // edges to preserve the hypothesis about JSR block successors order (see</a>
<span class="sourceLineNo">1669</span><a id="line.1669">          // {@link #visitJumpInsn}).</a>
<span class="sourceLineNo">1670</span><a id="line.1670">          handlerRangeBlock.outgoingEdges.nextEdge.nextEdge =</a>
<span class="sourceLineNo">1671</span><a id="line.1671">              new Edge(</a>
<span class="sourceLineNo">1672</span><a id="line.1672">                  Edge.EXCEPTION, handlerBlock, handlerRangeBlock.outgoingEdges.nextEdge.nextEdge);</a>
<span class="sourceLineNo">1673</span><a id="line.1673">        }</a>
<span class="sourceLineNo">1674</span><a id="line.1674">        handlerRangeBlock = handlerRangeBlock.nextBasicBlock;</a>
<span class="sourceLineNo">1675</span><a id="line.1675">      }</a>
<span class="sourceLineNo">1676</span><a id="line.1676">      handler = handler.nextHandler;</a>
<span class="sourceLineNo">1677</span><a id="line.1677">    }</a>
<span class="sourceLineNo">1678</span><a id="line.1678"></a>
<span class="sourceLineNo">1679</span><a id="line.1679">    // Complete the control flow graph with the successor blocks of subroutines, if needed.</a>
<span class="sourceLineNo">1680</span><a id="line.1680">    if (hasSubroutines) {</a>
<span class="sourceLineNo">1681</span><a id="line.1681">      // First step: find the subroutines. This step determines, for each basic block, to which</a>
<span class="sourceLineNo">1682</span><a id="line.1682">      // subroutine(s) it belongs. Start with the main "subroutine":</a>
<span class="sourceLineNo">1683</span><a id="line.1683">      short numSubroutines = 1;</a>
<span class="sourceLineNo">1684</span><a id="line.1684">      firstBasicBlock.markSubroutine(numSubroutines);</a>
<span class="sourceLineNo">1685</span><a id="line.1685">      // Then, mark the subroutines called by the main subroutine, then the subroutines called by</a>
<span class="sourceLineNo">1686</span><a id="line.1686">      // those called by the main subroutine, etc.</a>
<span class="sourceLineNo">1687</span><a id="line.1687">      for (short currentSubroutine = 1; currentSubroutine &lt;= numSubroutines; ++currentSubroutine) {</a>
<span class="sourceLineNo">1688</span><a id="line.1688">        Label basicBlock = firstBasicBlock;</a>
<span class="sourceLineNo">1689</span><a id="line.1689">        while (basicBlock != null) {</a>
<span class="sourceLineNo">1690</span><a id="line.1690">          if ((basicBlock.flags &amp; Label.FLAG_SUBROUTINE_CALLER) != 0</a>
<span class="sourceLineNo">1691</span><a id="line.1691">              &amp;&amp; basicBlock.subroutineId == currentSubroutine) {</a>
<span class="sourceLineNo">1692</span><a id="line.1692">            Label jsrTarget = basicBlock.outgoingEdges.nextEdge.successor;</a>
<span class="sourceLineNo">1693</span><a id="line.1693">            if (jsrTarget.subroutineId == 0) {</a>
<span class="sourceLineNo">1694</span><a id="line.1694">              // If this subroutine has not been marked yet, find its basic blocks.</a>
<span class="sourceLineNo">1695</span><a id="line.1695">              jsrTarget.markSubroutine(++numSubroutines);</a>
<span class="sourceLineNo">1696</span><a id="line.1696">            }</a>
<span class="sourceLineNo">1697</span><a id="line.1697">          }</a>
<span class="sourceLineNo">1698</span><a id="line.1698">          basicBlock = basicBlock.nextBasicBlock;</a>
<span class="sourceLineNo">1699</span><a id="line.1699">        }</a>
<span class="sourceLineNo">1700</span><a id="line.1700">      }</a>
<span class="sourceLineNo">1701</span><a id="line.1701">      // Second step: find the successors in the control flow graph of each subroutine basic block</a>
<span class="sourceLineNo">1702</span><a id="line.1702">      // 'r' ending with a RET instruction. These successors are the virtual successors of the basic</a>
<span class="sourceLineNo">1703</span><a id="line.1703">      // blocks ending with JSR instructions (see {@link #visitJumpInsn)} that can reach 'r'.</a>
<span class="sourceLineNo">1704</span><a id="line.1704">      Label basicBlock = firstBasicBlock;</a>
<span class="sourceLineNo">1705</span><a id="line.1705">      while (basicBlock != null) {</a>
<span class="sourceLineNo">1706</span><a id="line.1706">        if ((basicBlock.flags &amp; Label.FLAG_SUBROUTINE_CALLER) != 0) {</a>
<span class="sourceLineNo">1707</span><a id="line.1707">          // By construction, jsr targets are stored in the second outgoing edge of basic blocks</a>
<span class="sourceLineNo">1708</span><a id="line.1708">          // that ends with a jsr instruction (see {@link #FLAG_SUBROUTINE_CALLER}).</a>
<span class="sourceLineNo">1709</span><a id="line.1709">          Label subroutine = basicBlock.outgoingEdges.nextEdge.successor;</a>
<span class="sourceLineNo">1710</span><a id="line.1710">          subroutine.addSubroutineRetSuccessors(basicBlock);</a>
<span class="sourceLineNo">1711</span><a id="line.1711">        }</a>
<span class="sourceLineNo">1712</span><a id="line.1712">        basicBlock = basicBlock.nextBasicBlock;</a>
<span class="sourceLineNo">1713</span><a id="line.1713">      }</a>
<span class="sourceLineNo">1714</span><a id="line.1714">    }</a>
<span class="sourceLineNo">1715</span><a id="line.1715"></a>
<span class="sourceLineNo">1716</span><a id="line.1716">    // Data flow algorithm: put the first basic block in a list of blocks to process (i.e. blocks</a>
<span class="sourceLineNo">1717</span><a id="line.1717">    // whose input stack size has changed) and, while there are blocks to process, remove one</a>
<span class="sourceLineNo">1718</span><a id="line.1718">    // from the list, update the input stack size of its successor blocks in the control flow</a>
<span class="sourceLineNo">1719</span><a id="line.1719">    // graph, and add these blocks to the list of blocks to process (if not already done).</a>
<span class="sourceLineNo">1720</span><a id="line.1720">    Label listOfBlocksToProcess = firstBasicBlock;</a>
<span class="sourceLineNo">1721</span><a id="line.1721">    listOfBlocksToProcess.nextListElement = Label.EMPTY_LIST;</a>
<span class="sourceLineNo">1722</span><a id="line.1722">    int maxStackSize = maxStack;</a>
<span class="sourceLineNo">1723</span><a id="line.1723">    while (listOfBlocksToProcess != Label.EMPTY_LIST) {</a>
<span class="sourceLineNo">1724</span><a id="line.1724">      // Remove a basic block from the list of blocks to process. Note that we don't reset</a>
<span class="sourceLineNo">1725</span><a id="line.1725">      // basicBlock.nextListElement to null on purpose, to make sure we don't reprocess already</a>
<span class="sourceLineNo">1726</span><a id="line.1726">      // processed basic blocks.</a>
<span class="sourceLineNo">1727</span><a id="line.1727">      Label basicBlock = listOfBlocksToProcess;</a>
<span class="sourceLineNo">1728</span><a id="line.1728">      listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;</a>
<span class="sourceLineNo">1729</span><a id="line.1729">      // Compute the (absolute) input stack size and maximum stack size of this block.</a>
<span class="sourceLineNo">1730</span><a id="line.1730">      int inputStackTop = basicBlock.inputStackSize;</a>
<span class="sourceLineNo">1731</span><a id="line.1731">      int maxBlockStackSize = inputStackTop + basicBlock.outputStackMax;</a>
<span class="sourceLineNo">1732</span><a id="line.1732">      // Update the absolute maximum stack size of the method.</a>
<span class="sourceLineNo">1733</span><a id="line.1733">      if (maxBlockStackSize &gt; maxStackSize) {</a>
<span class="sourceLineNo">1734</span><a id="line.1734">        maxStackSize = maxBlockStackSize;</a>
<span class="sourceLineNo">1735</span><a id="line.1735">      }</a>
<span class="sourceLineNo">1736</span><a id="line.1736">      // Update the input stack size of the successor blocks of basicBlock in the control flow</a>
<span class="sourceLineNo">1737</span><a id="line.1737">      // graph, and add these blocks to the list of blocks to process, if not already done.</a>
<span class="sourceLineNo">1738</span><a id="line.1738">      Edge outgoingEdge = basicBlock.outgoingEdges;</a>
<span class="sourceLineNo">1739</span><a id="line.1739">      if ((basicBlock.flags &amp; Label.FLAG_SUBROUTINE_CALLER) != 0) {</a>
<span class="sourceLineNo">1740</span><a id="line.1740">        // Ignore the first outgoing edge of the basic blocks ending with a jsr: these are virtual</a>
<span class="sourceLineNo">1741</span><a id="line.1741">        // edges which lead to the instruction just after the jsr, and do not correspond to a</a>
<span class="sourceLineNo">1742</span><a id="line.1742">        // possible execution path (see {@link #visitJumpInsn} and</a>
<span class="sourceLineNo">1743</span><a id="line.1743">        // {@link Label#FLAG_SUBROUTINE_CALLER}).</a>
<span class="sourceLineNo">1744</span><a id="line.1744">        outgoingEdge = outgoingEdge.nextEdge;</a>
<span class="sourceLineNo">1745</span><a id="line.1745">      }</a>
<span class="sourceLineNo">1746</span><a id="line.1746">      while (outgoingEdge != null) {</a>
<span class="sourceLineNo">1747</span><a id="line.1747">        Label successorBlock = outgoingEdge.successor;</a>
<span class="sourceLineNo">1748</span><a id="line.1748">        if (successorBlock.nextListElement == null) {</a>
<span class="sourceLineNo">1749</span><a id="line.1749">          successorBlock.inputStackSize =</a>
<span class="sourceLineNo">1750</span><a id="line.1750">              (short) (outgoingEdge.info == Edge.EXCEPTION ? 1 : inputStackTop + outgoingEdge.info);</a>
<span class="sourceLineNo">1751</span><a id="line.1751">          successorBlock.nextListElement = listOfBlocksToProcess;</a>
<span class="sourceLineNo">1752</span><a id="line.1752">          listOfBlocksToProcess = successorBlock;</a>
<span class="sourceLineNo">1753</span><a id="line.1753">        }</a>
<span class="sourceLineNo">1754</span><a id="line.1754">        outgoingEdge = outgoingEdge.nextEdge;</a>
<span class="sourceLineNo">1755</span><a id="line.1755">      }</a>
<span class="sourceLineNo">1756</span><a id="line.1756">    }</a>
<span class="sourceLineNo">1757</span><a id="line.1757">    this.maxStack = maxStackSize;</a>
<span class="sourceLineNo">1758</span><a id="line.1758">  }</a>
<span class="sourceLineNo">1759</span><a id="line.1759"></a>
<span class="sourceLineNo">1760</span><a id="line.1760">  @Override</a>
<span class="sourceLineNo">1761</span><a id="line.1761">  public void visitEnd() {</a>
<span class="sourceLineNo">1762</span><a id="line.1762">    // Nothing to do.</a>
<span class="sourceLineNo">1763</span><a id="line.1763">  }</a>
<span class="sourceLineNo">1764</span><a id="line.1764"></a>
<span class="sourceLineNo">1765</span><a id="line.1765">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">1766</span><a id="line.1766">  // Utility methods: control flow analysis algorithm</a>
<span class="sourceLineNo">1767</span><a id="line.1767">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">1768</span><a id="line.1768"></a>
<span class="sourceLineNo">1769</span><a id="line.1769">  /**</a>
<span class="sourceLineNo">1770</span><a id="line.1770">   * Adds a successor to {@link #currentBasicBlock} in the control flow graph.</a>
<span class="sourceLineNo">1771</span><a id="line.1771">   *</a>
<span class="sourceLineNo">1772</span><a id="line.1772">   * @param info information about the control flow edge to be added.</a>
<span class="sourceLineNo">1773</span><a id="line.1773">   * @param successor the successor block to be added to the current basic block.</a>
<span class="sourceLineNo">1774</span><a id="line.1774">   */</a>
<span class="sourceLineNo">1775</span><a id="line.1775">  private void addSuccessorToCurrentBasicBlock(final int info, final Label successor) {</a>
<span class="sourceLineNo">1776</span><a id="line.1776">    currentBasicBlock.outgoingEdges = new Edge(info, successor, currentBasicBlock.outgoingEdges);</a>
<span class="sourceLineNo">1777</span><a id="line.1777">  }</a>
<span class="sourceLineNo">1778</span><a id="line.1778"></a>
<span class="sourceLineNo">1779</span><a id="line.1779">  /**</a>
<span class="sourceLineNo">1780</span><a id="line.1780">   * Ends the current basic block. This method must be used in the case where the current basic</a>
<span class="sourceLineNo">1781</span><a id="line.1781">   * block does not have any successor.</a>
<span class="sourceLineNo">1782</span><a id="line.1782">   *</a>
<span class="sourceLineNo">1783</span><a id="line.1783">   * &lt;p&gt;WARNING: this method must be called after the currently visited instruction has been put in</a>
<span class="sourceLineNo">1784</span><a id="line.1784">   * {@link #code} (if frames are computed, this method inserts a new Label to start a new basic</a>
<span class="sourceLineNo">1785</span><a id="line.1785">   * block after the current instruction).</a>
<span class="sourceLineNo">1786</span><a id="line.1786">   */</a>
<span class="sourceLineNo">1787</span><a id="line.1787">  private void endCurrentBasicBlockWithNoSuccessor() {</a>
<span class="sourceLineNo">1788</span><a id="line.1788">    if (compute == COMPUTE_ALL_FRAMES) {</a>
<span class="sourceLineNo">1789</span><a id="line.1789">      Label nextBasicBlock = new Label();</a>
<span class="sourceLineNo">1790</span><a id="line.1790">      nextBasicBlock.frame = new Frame(nextBasicBlock);</a>
<span class="sourceLineNo">1791</span><a id="line.1791">      nextBasicBlock.resolve(code.data, code.length);</a>
<span class="sourceLineNo">1792</span><a id="line.1792">      lastBasicBlock.nextBasicBlock = nextBasicBlock;</a>
<span class="sourceLineNo">1793</span><a id="line.1793">      lastBasicBlock = nextBasicBlock;</a>
<span class="sourceLineNo">1794</span><a id="line.1794">      currentBasicBlock = null;</a>
<span class="sourceLineNo">1795</span><a id="line.1795">    } else if (compute == COMPUTE_MAX_STACK_AND_LOCAL) {</a>
<span class="sourceLineNo">1796</span><a id="line.1796">      currentBasicBlock.outputStackMax = (short) maxRelativeStackSize;</a>
<span class="sourceLineNo">1797</span><a id="line.1797">      currentBasicBlock = null;</a>
<span class="sourceLineNo">1798</span><a id="line.1798">    }</a>
<span class="sourceLineNo">1799</span><a id="line.1799">  }</a>
<span class="sourceLineNo">1800</span><a id="line.1800"></a>
<span class="sourceLineNo">1801</span><a id="line.1801">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">1802</span><a id="line.1802">  // Utility methods: stack map frames</a>
<span class="sourceLineNo">1803</span><a id="line.1803">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">1804</span><a id="line.1804"></a>
<span class="sourceLineNo">1805</span><a id="line.1805">  /**</a>
<span class="sourceLineNo">1806</span><a id="line.1806">   * Starts the visit of a new stack map frame, stored in {@link #currentFrame}.</a>
<span class="sourceLineNo">1807</span><a id="line.1807">   *</a>
<span class="sourceLineNo">1808</span><a id="line.1808">   * @param offset the bytecode offset of the instruction to which the frame corresponds.</a>
<span class="sourceLineNo">1809</span><a id="line.1809">   * @param nLocal the number of local variables in the frame.</a>
<span class="sourceLineNo">1810</span><a id="line.1810">   * @param nStack the number of stack elements in the frame.</a>
<span class="sourceLineNo">1811</span><a id="line.1811">   * @return the index of the next element to be written in this frame.</a>
<span class="sourceLineNo">1812</span><a id="line.1812">   */</a>
<span class="sourceLineNo">1813</span><a id="line.1813">  int visitFrameStart(final int offset, final int nLocal, final int nStack) {</a>
<span class="sourceLineNo">1814</span><a id="line.1814">    int frameLength = 3 + nLocal + nStack;</a>
<span class="sourceLineNo">1815</span><a id="line.1815">    if (currentFrame == null || currentFrame.length &lt; frameLength) {</a>
<span class="sourceLineNo">1816</span><a id="line.1816">      currentFrame = new int[frameLength];</a>
<span class="sourceLineNo">1817</span><a id="line.1817">    }</a>
<span class="sourceLineNo">1818</span><a id="line.1818">    currentFrame[0] = offset;</a>
<span class="sourceLineNo">1819</span><a id="line.1819">    currentFrame[1] = nLocal;</a>
<span class="sourceLineNo">1820</span><a id="line.1820">    currentFrame[2] = nStack;</a>
<span class="sourceLineNo">1821</span><a id="line.1821">    return 3;</a>
<span class="sourceLineNo">1822</span><a id="line.1822">  }</a>
<span class="sourceLineNo">1823</span><a id="line.1823"></a>
<span class="sourceLineNo">1824</span><a id="line.1824">  /**</a>
<span class="sourceLineNo">1825</span><a id="line.1825">   * Sets an abstract type in {@link #currentFrame}.</a>
<span class="sourceLineNo">1826</span><a id="line.1826">   *</a>
<span class="sourceLineNo">1827</span><a id="line.1827">   * @param frameIndex the index of the element to be set in {@link #currentFrame}.</a>
<span class="sourceLineNo">1828</span><a id="line.1828">   * @param abstractType an abstract type.</a>
<span class="sourceLineNo">1829</span><a id="line.1829">   */</a>
<span class="sourceLineNo">1830</span><a id="line.1830">  void visitAbstractType(final int frameIndex, final int abstractType) {</a>
<span class="sourceLineNo">1831</span><a id="line.1831">    currentFrame[frameIndex] = abstractType;</a>
<span class="sourceLineNo">1832</span><a id="line.1832">  }</a>
<span class="sourceLineNo">1833</span><a id="line.1833"></a>
<span class="sourceLineNo">1834</span><a id="line.1834">  /**</a>
<span class="sourceLineNo">1835</span><a id="line.1835">   * Ends the visit of {@link #currentFrame} by writing it in the StackMapTable entries and by</a>
<span class="sourceLineNo">1836</span><a id="line.1836">   * updating the StackMapTable number_of_entries (except if the current frame is the first one,</a>
<span class="sourceLineNo">1837</span><a id="line.1837">   * which is implicit in StackMapTable). Then resets {@link #currentFrame} to &lt;tt&gt;null&lt;/tt&gt;.</a>
<span class="sourceLineNo">1838</span><a id="line.1838">   */</a>
<span class="sourceLineNo">1839</span><a id="line.1839">  void visitFrameEnd() {</a>
<span class="sourceLineNo">1840</span><a id="line.1840">    if (previousFrame != null) {</a>
<span class="sourceLineNo">1841</span><a id="line.1841">      if (stackMapTableEntries == null) {</a>
<span class="sourceLineNo">1842</span><a id="line.1842">        stackMapTableEntries = new ByteVector();</a>
<span class="sourceLineNo">1843</span><a id="line.1843">      }</a>
<span class="sourceLineNo">1844</span><a id="line.1844">      putFrame();</a>
<span class="sourceLineNo">1845</span><a id="line.1845">      ++stackMapTableNumberOfEntries;</a>
<span class="sourceLineNo">1846</span><a id="line.1846">    }</a>
<span class="sourceLineNo">1847</span><a id="line.1847">    previousFrame = currentFrame;</a>
<span class="sourceLineNo">1848</span><a id="line.1848">    currentFrame = null;</a>
<span class="sourceLineNo">1849</span><a id="line.1849">  }</a>
<span class="sourceLineNo">1850</span><a id="line.1850"></a>
<span class="sourceLineNo">1851</span><a id="line.1851">  /** Compresses and writes {@link #currentFrame} in a new StackMapTable entry. */</a>
<span class="sourceLineNo">1852</span><a id="line.1852">  private void putFrame() {</a>
<span class="sourceLineNo">1853</span><a id="line.1853">    final int nLocal = currentFrame[1];</a>
<span class="sourceLineNo">1854</span><a id="line.1854">    final int nStack = currentFrame[2];</a>
<span class="sourceLineNo">1855</span><a id="line.1855">    if (symbolTable.getMajorVersion() &lt; Opcodes.V1_6) {</a>
<span class="sourceLineNo">1856</span><a id="line.1856">      // Generate a StackMap attribute entry, which are always uncompressed.</a>
<span class="sourceLineNo">1857</span><a id="line.1857">      stackMapTableEntries.putShort(currentFrame[0]).putShort(nLocal);</a>
<span class="sourceLineNo">1858</span><a id="line.1858">      putAbstractTypes(3, 3 + nLocal);</a>
<span class="sourceLineNo">1859</span><a id="line.1859">      stackMapTableEntries.putShort(nStack);</a>
<span class="sourceLineNo">1860</span><a id="line.1860">      putAbstractTypes(3 + nLocal, 3 + nLocal + nStack);</a>
<span class="sourceLineNo">1861</span><a id="line.1861">      return;</a>
<span class="sourceLineNo">1862</span><a id="line.1862">    }</a>
<span class="sourceLineNo">1863</span><a id="line.1863">    final int offsetDelta =</a>
<span class="sourceLineNo">1864</span><a id="line.1864">        stackMapTableNumberOfEntries == 0</a>
<span class="sourceLineNo">1865</span><a id="line.1865">            ? currentFrame[0]</a>
<span class="sourceLineNo">1866</span><a id="line.1866">            : currentFrame[0] - previousFrame[0] - 1;</a>
<span class="sourceLineNo">1867</span><a id="line.1867">    final int previousNlocal = previousFrame[1];</a>
<span class="sourceLineNo">1868</span><a id="line.1868">    final int nLocalDelta = nLocal - previousNlocal;</a>
<span class="sourceLineNo">1869</span><a id="line.1869">    int type = Frame.FULL_FRAME;</a>
<span class="sourceLineNo">1870</span><a id="line.1870">    if (nStack == 0) {</a>
<span class="sourceLineNo">1871</span><a id="line.1871">      switch (nLocalDelta) {</a>
<span class="sourceLineNo">1872</span><a id="line.1872">        case -3:</a>
<span class="sourceLineNo">1873</span><a id="line.1873">        case -2:</a>
<span class="sourceLineNo">1874</span><a id="line.1874">        case -1:</a>
<span class="sourceLineNo">1875</span><a id="line.1875">          type = Frame.CHOP_FRAME;</a>
<span class="sourceLineNo">1876</span><a id="line.1876">          break;</a>
<span class="sourceLineNo">1877</span><a id="line.1877">        case 0:</a>
<span class="sourceLineNo">1878</span><a id="line.1878">          type = offsetDelta &lt; 64 ? Frame.SAME_FRAME : Frame.SAME_FRAME_EXTENDED;</a>
<span class="sourceLineNo">1879</span><a id="line.1879">          break;</a>
<span class="sourceLineNo">1880</span><a id="line.1880">        case 1:</a>
<span class="sourceLineNo">1881</span><a id="line.1881">        case 2:</a>
<span class="sourceLineNo">1882</span><a id="line.1882">        case 3:</a>
<span class="sourceLineNo">1883</span><a id="line.1883">          type = Frame.APPEND_FRAME;</a>
<span class="sourceLineNo">1884</span><a id="line.1884">          break;</a>
<span class="sourceLineNo">1885</span><a id="line.1885">        default:</a>
<span class="sourceLineNo">1886</span><a id="line.1886">          // Keep the FULL_FRAME type.</a>
<span class="sourceLineNo">1887</span><a id="line.1887">          break;</a>
<span class="sourceLineNo">1888</span><a id="line.1888">      }</a>
<span class="sourceLineNo">1889</span><a id="line.1889">    } else if (nLocalDelta == 0 &amp;&amp; nStack == 1) {</a>
<span class="sourceLineNo">1890</span><a id="line.1890">      type =</a>
<span class="sourceLineNo">1891</span><a id="line.1891">          offsetDelta &lt; 63</a>
<span class="sourceLineNo">1892</span><a id="line.1892">              ? Frame.SAME_LOCALS_1_STACK_ITEM_FRAME</a>
<span class="sourceLineNo">1893</span><a id="line.1893">              : Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;</a>
<span class="sourceLineNo">1894</span><a id="line.1894">    }</a>
<span class="sourceLineNo">1895</span><a id="line.1895">    if (type != Frame.FULL_FRAME) {</a>
<span class="sourceLineNo">1896</span><a id="line.1896">      // Verify if locals are the same as in the previous frame.</a>
<span class="sourceLineNo">1897</span><a id="line.1897">      int frameIndex = 3;</a>
<span class="sourceLineNo">1898</span><a id="line.1898">      for (int i = 0; i &lt; previousNlocal &amp;&amp; i &lt; nLocal; i++) {</a>
<span class="sourceLineNo">1899</span><a id="line.1899">        if (currentFrame[frameIndex] != previousFrame[frameIndex]) {</a>
<span class="sourceLineNo">1900</span><a id="line.1900">          type = Frame.FULL_FRAME;</a>
<span class="sourceLineNo">1901</span><a id="line.1901">          break;</a>
<span class="sourceLineNo">1902</span><a id="line.1902">        }</a>
<span class="sourceLineNo">1903</span><a id="line.1903">        frameIndex++;</a>
<span class="sourceLineNo">1904</span><a id="line.1904">      }</a>
<span class="sourceLineNo">1905</span><a id="line.1905">    }</a>
<span class="sourceLineNo">1906</span><a id="line.1906">    switch (type) {</a>
<span class="sourceLineNo">1907</span><a id="line.1907">      case Frame.SAME_FRAME:</a>
<span class="sourceLineNo">1908</span><a id="line.1908">        stackMapTableEntries.putByte(offsetDelta);</a>
<span class="sourceLineNo">1909</span><a id="line.1909">        break;</a>
<span class="sourceLineNo">1910</span><a id="line.1910">      case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME:</a>
<span class="sourceLineNo">1911</span><a id="line.1911">        stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);</a>
<span class="sourceLineNo">1912</span><a id="line.1912">        putAbstractTypes(3 + nLocal, 4 + nLocal);</a>
<span class="sourceLineNo">1913</span><a id="line.1913">        break;</a>
<span class="sourceLineNo">1914</span><a id="line.1914">      case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:</a>
<span class="sourceLineNo">1915</span><a id="line.1915">        stackMapTableEntries</a>
<span class="sourceLineNo">1916</span><a id="line.1916">            .putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)</a>
<span class="sourceLineNo">1917</span><a id="line.1917">            .putShort(offsetDelta);</a>
<span class="sourceLineNo">1918</span><a id="line.1918">        putAbstractTypes(3 + nLocal, 4 + nLocal);</a>
<span class="sourceLineNo">1919</span><a id="line.1919">        break;</a>
<span class="sourceLineNo">1920</span><a id="line.1920">      case Frame.SAME_FRAME_EXTENDED:</a>
<span class="sourceLineNo">1921</span><a id="line.1921">        stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);</a>
<span class="sourceLineNo">1922</span><a id="line.1922">        break;</a>
<span class="sourceLineNo">1923</span><a id="line.1923">      case Frame.CHOP_FRAME:</a>
<span class="sourceLineNo">1924</span><a id="line.1924">        stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED + nLocalDelta).putShort(offsetDelta);</a>
<span class="sourceLineNo">1925</span><a id="line.1925">        break;</a>
<span class="sourceLineNo">1926</span><a id="line.1926">      case Frame.APPEND_FRAME:</a>
<span class="sourceLineNo">1927</span><a id="line.1927">        stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED + nLocalDelta).putShort(offsetDelta);</a>
<span class="sourceLineNo">1928</span><a id="line.1928">        putAbstractTypes(3 + previousNlocal, 3 + nLocal);</a>
<span class="sourceLineNo">1929</span><a id="line.1929">        break;</a>
<span class="sourceLineNo">1930</span><a id="line.1930">      case Frame.FULL_FRAME:</a>
<span class="sourceLineNo">1931</span><a id="line.1931">      default:</a>
<span class="sourceLineNo">1932</span><a id="line.1932">        stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(nLocal);</a>
<span class="sourceLineNo">1933</span><a id="line.1933">        putAbstractTypes(3, 3 + nLocal);</a>
<span class="sourceLineNo">1934</span><a id="line.1934">        stackMapTableEntries.putShort(nStack);</a>
<span class="sourceLineNo">1935</span><a id="line.1935">        putAbstractTypes(3 + nLocal, 3 + nLocal + nStack);</a>
<span class="sourceLineNo">1936</span><a id="line.1936">    }</a>
<span class="sourceLineNo">1937</span><a id="line.1937">  }</a>
<span class="sourceLineNo">1938</span><a id="line.1938"></a>
<span class="sourceLineNo">1939</span><a id="line.1939">  /**</a>
<span class="sourceLineNo">1940</span><a id="line.1940">   * Puts some abstract types of {@link #currentFrame} in {@link #stackMapTableEntries} , using the</a>
<span class="sourceLineNo">1941</span><a id="line.1941">   * JVMS verification_type_info format used in StackMapTable attributes.</a>
<span class="sourceLineNo">1942</span><a id="line.1942">   *</a>
<span class="sourceLineNo">1943</span><a id="line.1943">   * @param start index of the first type in {@link #currentFrame} to write.</a>
<span class="sourceLineNo">1944</span><a id="line.1944">   * @param end index of last type in {@link #currentFrame} to write (exclusive).</a>
<span class="sourceLineNo">1945</span><a id="line.1945">   */</a>
<span class="sourceLineNo">1946</span><a id="line.1946">  private void putAbstractTypes(final int start, final int end) {</a>
<span class="sourceLineNo">1947</span><a id="line.1947">    for (int i = start; i &lt; end; ++i) {</a>
<span class="sourceLineNo">1948</span><a id="line.1948">      Frame.putAbstractType(symbolTable, currentFrame[i], stackMapTableEntries);</a>
<span class="sourceLineNo">1949</span><a id="line.1949">    }</a>
<span class="sourceLineNo">1950</span><a id="line.1950">  }</a>
<span class="sourceLineNo">1951</span><a id="line.1951"></a>
<span class="sourceLineNo">1952</span><a id="line.1952">  /**</a>
<span class="sourceLineNo">1953</span><a id="line.1953">   * Puts the given public API frame element type in {@link #stackMapTableEntries} , using the JVMS</a>
<span class="sourceLineNo">1954</span><a id="line.1954">   * verification_type_info format used in StackMapTable attributes.</a>
<span class="sourceLineNo">1955</span><a id="line.1955">   *</a>
<span class="sourceLineNo">1956</span><a id="line.1956">   * @param type a frame element type described using the same format as in {@link</a>
<span class="sourceLineNo">1957</span><a id="line.1957">   *     MethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link</a>
<span class="sourceLineNo">1958</span><a id="line.1958">   *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or</a>
<span class="sourceLineNo">1959</span><a id="line.1959">   *     {@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating</a>
<span class="sourceLineNo">1960</span><a id="line.1960">   *     a NEW instruction (for uninitialized types).</a>
<span class="sourceLineNo">1961</span><a id="line.1961">   */</a>
<span class="sourceLineNo">1962</span><a id="line.1962">  private void putFrameType(final Object type) {</a>
<span class="sourceLineNo">1963</span><a id="line.1963">    if (type instanceof Integer) {</a>
<span class="sourceLineNo">1964</span><a id="line.1964">      stackMapTableEntries.putByte(((Integer) type).intValue());</a>
<span class="sourceLineNo">1965</span><a id="line.1965">    } else if (type instanceof String) {</a>
<span class="sourceLineNo">1966</span><a id="line.1966">      stackMapTableEntries</a>
<span class="sourceLineNo">1967</span><a id="line.1967">          .putByte(Frame.ITEM_OBJECT)</a>
<span class="sourceLineNo">1968</span><a id="line.1968">          .putShort(symbolTable.addConstantClass((String) type).index);</a>
<span class="sourceLineNo">1969</span><a id="line.1969">    } else {</a>
<span class="sourceLineNo">1970</span><a id="line.1970">      stackMapTableEntries</a>
<span class="sourceLineNo">1971</span><a id="line.1971">          .putByte(Frame.ITEM_UNINITIALIZED)</a>
<span class="sourceLineNo">1972</span><a id="line.1972">          .putShort(((Label) type).bytecodeOffset);</a>
<span class="sourceLineNo">1973</span><a id="line.1973">    }</a>
<span class="sourceLineNo">1974</span><a id="line.1974">  }</a>
<span class="sourceLineNo">1975</span><a id="line.1975"></a>
<span class="sourceLineNo">1976</span><a id="line.1976">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">1977</span><a id="line.1977">  // Utility methods</a>
<span class="sourceLineNo">1978</span><a id="line.1978">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">1979</span><a id="line.1979"></a>
<span class="sourceLineNo">1980</span><a id="line.1980">  /**</a>
<span class="sourceLineNo">1981</span><a id="line.1981">   * Returns whether the attributes of this method can be copied from the attributes of the given</a>
<span class="sourceLineNo">1982</span><a id="line.1982">   * method (assuming there is no method visitor between the given ClassReader and this</a>
<span class="sourceLineNo">1983</span><a id="line.1983">   * MethodWriter). This method should only be called just after this MethodWriter has been created,</a>
<span class="sourceLineNo">1984</span><a id="line.1984">   * and before any content is visited. It returns true if the attributes corresponding to the</a>
<span class="sourceLineNo">1985</span><a id="line.1985">   * constructor arguments (at most a Signature, an Exception, a Deprecated and a Synthetic</a>
<span class="sourceLineNo">1986</span><a id="line.1986">   * attribute) are the same as the corresponding attributes in the given method.</a>
<span class="sourceLineNo">1987</span><a id="line.1987">   *</a>
<span class="sourceLineNo">1988</span><a id="line.1988">   * @param source the source ClassReader from which the attributes of this method might be copied.</a>
<span class="sourceLineNo">1989</span><a id="line.1989">   * @param methodInfoOffset the offset in 'source.b' of the method_info JVMS structure from which</a>
<span class="sourceLineNo">1990</span><a id="line.1990">   *     the attributes of this method might be copied.</a>
<span class="sourceLineNo">1991</span><a id="line.1991">   * @param methodInfoLength the length in 'source.b' of the method_info JVMS structure from which</a>
<span class="sourceLineNo">1992</span><a id="line.1992">   *     the attributes of this method might be copied.</a>
<span class="sourceLineNo">1993</span><a id="line.1993">   * @param hasSyntheticAttribute whether the method_info JVMS structure from which the attributes</a>
<span class="sourceLineNo">1994</span><a id="line.1994">   *     of this method might be copied contains a Synthetic attribute.</a>
<span class="sourceLineNo">1995</span><a id="line.1995">   * @param hasDeprecatedAttribute whether the method_info JVMS structure from which the attributes</a>
<span class="sourceLineNo">1996</span><a id="line.1996">   *     of this method might be copied contains a Deprecated attribute.</a>
<span class="sourceLineNo">1997</span><a id="line.1997">   * @param signatureIndex the constant pool index contained in the Signature attribute of the</a>
<span class="sourceLineNo">1998</span><a id="line.1998">   *     method_info JVMS structure from which the attributes of this method might be copied, or 0.</a>
<span class="sourceLineNo">1999</span><a id="line.1999">   * @param exceptionsOffset the offset in 'source.b' of the Exceptions attribute of the method_info</a>
<span class="sourceLineNo">2000</span><a id="line.2000">   *     JVMS structure from which the attributes of this method might be copied, or 0.</a>
<span class="sourceLineNo">2001</span><a id="line.2001">   * @return whether the attributes of this method can be copied from the attributes of the</a>
<span class="sourceLineNo">2002</span><a id="line.2002">   *     method_info JVMS structure in 'source.b', between 'methodInfoOffset' and 'methodInfoOffset'</a>
<span class="sourceLineNo">2003</span><a id="line.2003">   *     + 'methodInfoLength'.</a>
<span class="sourceLineNo">2004</span><a id="line.2004">   */</a>
<span class="sourceLineNo">2005</span><a id="line.2005">  boolean canCopyMethodAttributes(</a>
<span class="sourceLineNo">2006</span><a id="line.2006">      final ClassReader source,</a>
<span class="sourceLineNo">2007</span><a id="line.2007">      final int methodInfoOffset,</a>
<span class="sourceLineNo">2008</span><a id="line.2008">      final int methodInfoLength,</a>
<span class="sourceLineNo">2009</span><a id="line.2009">      final boolean hasSyntheticAttribute,</a>
<span class="sourceLineNo">2010</span><a id="line.2010">      final boolean hasDeprecatedAttribute,</a>
<span class="sourceLineNo">2011</span><a id="line.2011">      final int signatureIndex,</a>
<span class="sourceLineNo">2012</span><a id="line.2012">      final int exceptionsOffset) {</a>
<span class="sourceLineNo">2013</span><a id="line.2013">    if (source != symbolTable.getSource()</a>
<span class="sourceLineNo">2014</span><a id="line.2014">        || signatureIndex != this.signatureIndex</a>
<span class="sourceLineNo">2015</span><a id="line.2015">        || hasDeprecatedAttribute != ((accessFlags &amp; Opcodes.ACC_DEPRECATED) != 0)) {</a>
<span class="sourceLineNo">2016</span><a id="line.2016">      return false;</a>
<span class="sourceLineNo">2017</span><a id="line.2017">    }</a>
<span class="sourceLineNo">2018</span><a id="line.2018">    boolean needSyntheticAttribute =</a>
<span class="sourceLineNo">2019</span><a id="line.2019">        symbolTable.getMajorVersion() &lt; Opcodes.V1_5 &amp;&amp; (accessFlags &amp; Opcodes.ACC_SYNTHETIC) != 0;</a>
<span class="sourceLineNo">2020</span><a id="line.2020">    if (hasSyntheticAttribute != needSyntheticAttribute) {</a>
<span class="sourceLineNo">2021</span><a id="line.2021">      return false;</a>
<span class="sourceLineNo">2022</span><a id="line.2022">    }</a>
<span class="sourceLineNo">2023</span><a id="line.2023">    if (exceptionsOffset == 0) {</a>
<span class="sourceLineNo">2024</span><a id="line.2024">      if (numberOfExceptions != 0) {</a>
<span class="sourceLineNo">2025</span><a id="line.2025">        return false;</a>
<span class="sourceLineNo">2026</span><a id="line.2026">      }</a>
<span class="sourceLineNo">2027</span><a id="line.2027">    } else if (source.readUnsignedShort(exceptionsOffset) == numberOfExceptions) {</a>
<span class="sourceLineNo">2028</span><a id="line.2028">      int currentExceptionOffset = exceptionsOffset + 2;</a>
<span class="sourceLineNo">2029</span><a id="line.2029">      for (int i = 0; i &lt; numberOfExceptions; ++i) {</a>
<span class="sourceLineNo">2030</span><a id="line.2030">        if (source.readUnsignedShort(currentExceptionOffset) != exceptionIndexTable[i]) {</a>
<span class="sourceLineNo">2031</span><a id="line.2031">          return false;</a>
<span class="sourceLineNo">2032</span><a id="line.2032">        }</a>
<span class="sourceLineNo">2033</span><a id="line.2033">        currentExceptionOffset += 2;</a>
<span class="sourceLineNo">2034</span><a id="line.2034">      }</a>
<span class="sourceLineNo">2035</span><a id="line.2035">    }</a>
<span class="sourceLineNo">2036</span><a id="line.2036">    // Don't copy the attributes yet, instead store their location in the source class reader so</a>
<span class="sourceLineNo">2037</span><a id="line.2037">    // they can be copied later, in {@link #putMethodInfo}. Note that we skip the 6 header bytes</a>
<span class="sourceLineNo">2038</span><a id="line.2038">    // of the method_info JVMS structure.</a>
<span class="sourceLineNo">2039</span><a id="line.2039">    this.sourceOffset = methodInfoOffset + 6;</a>
<span class="sourceLineNo">2040</span><a id="line.2040">    this.sourceLength = methodInfoLength - 6;</a>
<span class="sourceLineNo">2041</span><a id="line.2041">    return true;</a>
<span class="sourceLineNo">2042</span><a id="line.2042">  }</a>
<span class="sourceLineNo">2043</span><a id="line.2043"></a>
<span class="sourceLineNo">2044</span><a id="line.2044">  /**</a>
<span class="sourceLineNo">2045</span><a id="line.2045">   * Returns the size of the method_info JVMS structure generated by this MethodWriter. Also add the</a>
<span class="sourceLineNo">2046</span><a id="line.2046">   * names of the attributes of this method in the constant pool.</a>
<span class="sourceLineNo">2047</span><a id="line.2047">   *</a>
<span class="sourceLineNo">2048</span><a id="line.2048">   * @return the size in bytes of the method_info JVMS structure.</a>
<span class="sourceLineNo">2049</span><a id="line.2049">   */</a>
<span class="sourceLineNo">2050</span><a id="line.2050">  int computeMethodInfoSize() {</a>
<span class="sourceLineNo">2051</span><a id="line.2051">    // If this method_info must be copied from an existing one, the size computation is trivial.</a>
<span class="sourceLineNo">2052</span><a id="line.2052">    if (sourceOffset != 0) {</a>
<span class="sourceLineNo">2053</span><a id="line.2053">      // sourceLength excludes the first 6 bytes for access_flags, name_index and descriptor_index.</a>
<span class="sourceLineNo">2054</span><a id="line.2054">      return 6 + sourceLength;</a>
<span class="sourceLineNo">2055</span><a id="line.2055">    }</a>
<span class="sourceLineNo">2056</span><a id="line.2056">    // 2 bytes each for access_flags, name_index, descriptor_index and attributes_count.</a>
<span class="sourceLineNo">2057</span><a id="line.2057">    int size = 8;</a>
<span class="sourceLineNo">2058</span><a id="line.2058">    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.</a>
<span class="sourceLineNo">2059</span><a id="line.2059">    if (code.length &gt; 0) {</a>
<span class="sourceLineNo">2060</span><a id="line.2060">      if (code.length &gt; 65535) {</a>
<span class="sourceLineNo">2061</span><a id="line.2061">        throw new IndexOutOfBoundsException("Method code too large!");</a>
<span class="sourceLineNo">2062</span><a id="line.2062">      }</a>
<span class="sourceLineNo">2063</span><a id="line.2063">      symbolTable.addConstantUtf8(Constants.CODE);</a>
<span class="sourceLineNo">2064</span><a id="line.2064">      // The Code attribute has 6 header bytes, plus 2, 2, 4 and 2 bytes respectively for max_stack,</a>
<span class="sourceLineNo">2065</span><a id="line.2065">      // max_locals, code_length and attributes_count, plus the bytecode and the exception table.</a>
<span class="sourceLineNo">2066</span><a id="line.2066">      size += 16 + code.length + Handler.getExceptionTableSize(firstHandler);</a>
<span class="sourceLineNo">2067</span><a id="line.2067">      if (stackMapTableEntries != null) {</a>
<span class="sourceLineNo">2068</span><a id="line.2068">        boolean useStackMapTable = symbolTable.getMajorVersion() &gt;= Opcodes.V1_6;</a>
<span class="sourceLineNo">2069</span><a id="line.2069">        symbolTable.addConstantUtf8(useStackMapTable ? Constants.STACK_MAP_TABLE : "StackMap");</a>
<span class="sourceLineNo">2070</span><a id="line.2070">        // 6 header bytes and 2 bytes for number_of_entries.</a>
<span class="sourceLineNo">2071</span><a id="line.2071">        size += 8 + stackMapTableEntries.length;</a>
<span class="sourceLineNo">2072</span><a id="line.2072">      }</a>
<span class="sourceLineNo">2073</span><a id="line.2073">      if (lineNumberTable != null) {</a>
<span class="sourceLineNo">2074</span><a id="line.2074">        symbolTable.addConstantUtf8(Constants.LINE_NUMBER_TABLE);</a>
<span class="sourceLineNo">2075</span><a id="line.2075">        // 6 header bytes and 2 bytes for line_number_table_length.</a>
<span class="sourceLineNo">2076</span><a id="line.2076">        size += 8 + lineNumberTable.length;</a>
<span class="sourceLineNo">2077</span><a id="line.2077">      }</a>
<span class="sourceLineNo">2078</span><a id="line.2078">      if (localVariableTable != null) {</a>
<span class="sourceLineNo">2079</span><a id="line.2079">        symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TABLE);</a>
<span class="sourceLineNo">2080</span><a id="line.2080">        // 6 header bytes and 2 bytes for local_variable_table_length.</a>
<span class="sourceLineNo">2081</span><a id="line.2081">        size += 8 + localVariableTable.length;</a>
<span class="sourceLineNo">2082</span><a id="line.2082">      }</a>
<span class="sourceLineNo">2083</span><a id="line.2083">      if (localVariableTypeTable != null) {</a>
<span class="sourceLineNo">2084</span><a id="line.2084">        symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TYPE_TABLE);</a>
<span class="sourceLineNo">2085</span><a id="line.2085">        // 6 header bytes and 2 bytes for local_variable_type_table_length.</a>
<span class="sourceLineNo">2086</span><a id="line.2086">        size += 8 + localVariableTypeTable.length;</a>
<span class="sourceLineNo">2087</span><a id="line.2087">      }</a>
<span class="sourceLineNo">2088</span><a id="line.2088">      if (lastCodeRuntimeVisibleTypeAnnotation != null) {</a>
<span class="sourceLineNo">2089</span><a id="line.2089">        size +=</a>
<span class="sourceLineNo">2090</span><a id="line.2090">            lastCodeRuntimeVisibleTypeAnnotation.computeAnnotationsSize(</a>
<span class="sourceLineNo">2091</span><a id="line.2091">                Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);</a>
<span class="sourceLineNo">2092</span><a id="line.2092">      }</a>
<span class="sourceLineNo">2093</span><a id="line.2093">      if (lastCodeRuntimeInvisibleTypeAnnotation != null) {</a>
<span class="sourceLineNo">2094</span><a id="line.2094">        size +=</a>
<span class="sourceLineNo">2095</span><a id="line.2095">            lastCodeRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(</a>
<span class="sourceLineNo">2096</span><a id="line.2096">                Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);</a>
<span class="sourceLineNo">2097</span><a id="line.2097">      }</a>
<span class="sourceLineNo">2098</span><a id="line.2098">      if (firstCodeAttribute != null) {</a>
<span class="sourceLineNo">2099</span><a id="line.2099">        size +=</a>
<span class="sourceLineNo">2100</span><a id="line.2100">            firstCodeAttribute.computeAttributesSize(</a>
<span class="sourceLineNo">2101</span><a id="line.2101">                symbolTable, code.data, code.length, maxStack, maxLocals);</a>
<span class="sourceLineNo">2102</span><a id="line.2102">      }</a>
<span class="sourceLineNo">2103</span><a id="line.2103">    }</a>
<span class="sourceLineNo">2104</span><a id="line.2104">    if (numberOfExceptions &gt; 0) {</a>
<span class="sourceLineNo">2105</span><a id="line.2105">      symbolTable.addConstantUtf8(Constants.EXCEPTIONS);</a>
<span class="sourceLineNo">2106</span><a id="line.2106">      size += 8 + 2 * numberOfExceptions;</a>
<span class="sourceLineNo">2107</span><a id="line.2107">    }</a>
<span class="sourceLineNo">2108</span><a id="line.2108">    boolean useSyntheticAttribute = symbolTable.getMajorVersion() &lt; Opcodes.V1_5;</a>
<span class="sourceLineNo">2109</span><a id="line.2109">    if ((accessFlags &amp; Opcodes.ACC_SYNTHETIC) != 0 &amp;&amp; useSyntheticAttribute) {</a>
<span class="sourceLineNo">2110</span><a id="line.2110">      symbolTable.addConstantUtf8(Constants.SYNTHETIC);</a>
<span class="sourceLineNo">2111</span><a id="line.2111">      size += 6;</a>
<span class="sourceLineNo">2112</span><a id="line.2112">    }</a>
<span class="sourceLineNo">2113</span><a id="line.2113">    if (signatureIndex != 0) {</a>
<span class="sourceLineNo">2114</span><a id="line.2114">      symbolTable.addConstantUtf8(Constants.SIGNATURE);</a>
<span class="sourceLineNo">2115</span><a id="line.2115">      size += 8;</a>
<span class="sourceLineNo">2116</span><a id="line.2116">    }</a>
<span class="sourceLineNo">2117</span><a id="line.2117">    if ((accessFlags &amp; Opcodes.ACC_DEPRECATED) != 0) {</a>
<span class="sourceLineNo">2118</span><a id="line.2118">      symbolTable.addConstantUtf8(Constants.DEPRECATED);</a>
<span class="sourceLineNo">2119</span><a id="line.2119">      size += 6;</a>
<span class="sourceLineNo">2120</span><a id="line.2120">    }</a>
<span class="sourceLineNo">2121</span><a id="line.2121">    if (lastRuntimeVisibleAnnotation != null) {</a>
<span class="sourceLineNo">2122</span><a id="line.2122">      size +=</a>
<span class="sourceLineNo">2123</span><a id="line.2123">          lastRuntimeVisibleAnnotation.computeAnnotationsSize(</a>
<span class="sourceLineNo">2124</span><a id="line.2124">              Constants.RUNTIME_VISIBLE_ANNOTATIONS);</a>
<span class="sourceLineNo">2125</span><a id="line.2125">    }</a>
<span class="sourceLineNo">2126</span><a id="line.2126">    if (lastRuntimeInvisibleAnnotation != null) {</a>
<span class="sourceLineNo">2127</span><a id="line.2127">      size +=</a>
<span class="sourceLineNo">2128</span><a id="line.2128">          lastRuntimeInvisibleAnnotation.computeAnnotationsSize(</a>
<span class="sourceLineNo">2129</span><a id="line.2129">              Constants.RUNTIME_INVISIBLE_ANNOTATIONS);</a>
<span class="sourceLineNo">2130</span><a id="line.2130">    }</a>
<span class="sourceLineNo">2131</span><a id="line.2131">    if (lastRuntimeVisibleParameterAnnotations != null) {</a>
<span class="sourceLineNo">2132</span><a id="line.2132">      size +=</a>
<span class="sourceLineNo">2133</span><a id="line.2133">          AnnotationWriter.computeParameterAnnotationsSize(</a>
<span class="sourceLineNo">2134</span><a id="line.2134">              Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS,</a>
<span class="sourceLineNo">2135</span><a id="line.2135">              lastRuntimeVisibleParameterAnnotations,</a>
<span class="sourceLineNo">2136</span><a id="line.2136">              visibleAnnotableParameterCount == 0</a>
<span class="sourceLineNo">2137</span><a id="line.2137">                  ? lastRuntimeVisibleParameterAnnotations.length</a>
<span class="sourceLineNo">2138</span><a id="line.2138">                  : visibleAnnotableParameterCount);</a>
<span class="sourceLineNo">2139</span><a id="line.2139">    }</a>
<span class="sourceLineNo">2140</span><a id="line.2140">    if (lastRuntimeInvisibleParameterAnnotations != null) {</a>
<span class="sourceLineNo">2141</span><a id="line.2141">      size +=</a>
<span class="sourceLineNo">2142</span><a id="line.2142">          AnnotationWriter.computeParameterAnnotationsSize(</a>
<span class="sourceLineNo">2143</span><a id="line.2143">              Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS,</a>
<span class="sourceLineNo">2144</span><a id="line.2144">              lastRuntimeInvisibleParameterAnnotations,</a>
<span class="sourceLineNo">2145</span><a id="line.2145">              invisibleAnnotableParameterCount == 0</a>
<span class="sourceLineNo">2146</span><a id="line.2146">                  ? lastRuntimeInvisibleParameterAnnotations.length</a>
<span class="sourceLineNo">2147</span><a id="line.2147">                  : invisibleAnnotableParameterCount);</a>
<span class="sourceLineNo">2148</span><a id="line.2148">    }</a>
<span class="sourceLineNo">2149</span><a id="line.2149">    if (lastRuntimeVisibleTypeAnnotation != null) {</a>
<span class="sourceLineNo">2150</span><a id="line.2150">      size +=</a>
<span class="sourceLineNo">2151</span><a id="line.2151">          lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize(</a>
<span class="sourceLineNo">2152</span><a id="line.2152">              Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);</a>
<span class="sourceLineNo">2153</span><a id="line.2153">    }</a>
<span class="sourceLineNo">2154</span><a id="line.2154">    if (lastRuntimeInvisibleTypeAnnotation != null) {</a>
<span class="sourceLineNo">2155</span><a id="line.2155">      size +=</a>
<span class="sourceLineNo">2156</span><a id="line.2156">          lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(</a>
<span class="sourceLineNo">2157</span><a id="line.2157">              Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);</a>
<span class="sourceLineNo">2158</span><a id="line.2158">    }</a>
<span class="sourceLineNo">2159</span><a id="line.2159">    if (defaultValue != null) {</a>
<span class="sourceLineNo">2160</span><a id="line.2160">      symbolTable.addConstantUtf8(Constants.ANNOTATION_DEFAULT);</a>
<span class="sourceLineNo">2161</span><a id="line.2161">      size += 6 + defaultValue.length;</a>
<span class="sourceLineNo">2162</span><a id="line.2162">    }</a>
<span class="sourceLineNo">2163</span><a id="line.2163">    if (parameters != null) {</a>
<span class="sourceLineNo">2164</span><a id="line.2164">      symbolTable.addConstantUtf8(Constants.METHOD_PARAMETERS);</a>
<span class="sourceLineNo">2165</span><a id="line.2165">      // 6 header bytes and 1 byte for parameters_count.</a>
<span class="sourceLineNo">2166</span><a id="line.2166">      size += 7 + parameters.length;</a>
<span class="sourceLineNo">2167</span><a id="line.2167">    }</a>
<span class="sourceLineNo">2168</span><a id="line.2168">    if (firstAttribute != null) {</a>
<span class="sourceLineNo">2169</span><a id="line.2169">      size += firstAttribute.computeAttributesSize(symbolTable);</a>
<span class="sourceLineNo">2170</span><a id="line.2170">    }</a>
<span class="sourceLineNo">2171</span><a id="line.2171">    return size;</a>
<span class="sourceLineNo">2172</span><a id="line.2172">  }</a>
<span class="sourceLineNo">2173</span><a id="line.2173"></a>
<span class="sourceLineNo">2174</span><a id="line.2174">  /**</a>
<span class="sourceLineNo">2175</span><a id="line.2175">   * Puts the content of the method_info JVMS structure generated by this MethodWriter into the</a>
<span class="sourceLineNo">2176</span><a id="line.2176">   * given ByteVector.</a>
<span class="sourceLineNo">2177</span><a id="line.2177">   *</a>
<span class="sourceLineNo">2178</span><a id="line.2178">   * @param output where the method_info structure must be put.</a>
<span class="sourceLineNo">2179</span><a id="line.2179">   */</a>
<span class="sourceLineNo">2180</span><a id="line.2180">  void putMethodInfo(final ByteVector output) {</a>
<span class="sourceLineNo">2181</span><a id="line.2181">    boolean useSyntheticAttribute = symbolTable.getMajorVersion() &lt; Opcodes.V1_5;</a>
<span class="sourceLineNo">2182</span><a id="line.2182">    int mask = useSyntheticAttribute ? Opcodes.ACC_SYNTHETIC : 0;</a>
<span class="sourceLineNo">2183</span><a id="line.2183">    output.putShort(accessFlags &amp; ~mask).putShort(nameIndex).putShort(descriptorIndex);</a>
<span class="sourceLineNo">2184</span><a id="line.2184">    // If this method_info must be copied from an existing one, copy it now and return early.</a>
<span class="sourceLineNo">2185</span><a id="line.2185">    if (sourceOffset != 0) {</a>
<span class="sourceLineNo">2186</span><a id="line.2186">      output.putByteArray(symbolTable.getSource().b, sourceOffset, sourceLength);</a>
<span class="sourceLineNo">2187</span><a id="line.2187">      return;</a>
<span class="sourceLineNo">2188</span><a id="line.2188">    }</a>
<span class="sourceLineNo">2189</span><a id="line.2189">    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.</a>
<span class="sourceLineNo">2190</span><a id="line.2190">    int attributeCount = 0;</a>
<span class="sourceLineNo">2191</span><a id="line.2191">    if (code.length &gt; 0) {</a>
<span class="sourceLineNo">2192</span><a id="line.2192">      ++attributeCount;</a>
<span class="sourceLineNo">2193</span><a id="line.2193">    }</a>
<span class="sourceLineNo">2194</span><a id="line.2194">    if (numberOfExceptions &gt; 0) {</a>
<span class="sourceLineNo">2195</span><a id="line.2195">      ++attributeCount;</a>
<span class="sourceLineNo">2196</span><a id="line.2196">    }</a>
<span class="sourceLineNo">2197</span><a id="line.2197">    if ((accessFlags &amp; Opcodes.ACC_SYNTHETIC) != 0 &amp;&amp; useSyntheticAttribute) {</a>
<span class="sourceLineNo">2198</span><a id="line.2198">      ++attributeCount;</a>
<span class="sourceLineNo">2199</span><a id="line.2199">    }</a>
<span class="sourceLineNo">2200</span><a id="line.2200">    if (signatureIndex != 0) {</a>
<span class="sourceLineNo">2201</span><a id="line.2201">      ++attributeCount;</a>
<span class="sourceLineNo">2202</span><a id="line.2202">    }</a>
<span class="sourceLineNo">2203</span><a id="line.2203">    if ((accessFlags &amp; Opcodes.ACC_DEPRECATED) != 0) {</a>
<span class="sourceLineNo">2204</span><a id="line.2204">      ++attributeCount;</a>
<span class="sourceLineNo">2205</span><a id="line.2205">    }</a>
<span class="sourceLineNo">2206</span><a id="line.2206">    if (lastRuntimeVisibleAnnotation != null) {</a>
<span class="sourceLineNo">2207</span><a id="line.2207">      ++attributeCount;</a>
<span class="sourceLineNo">2208</span><a id="line.2208">    }</a>
<span class="sourceLineNo">2209</span><a id="line.2209">    if (lastRuntimeInvisibleAnnotation != null) {</a>
<span class="sourceLineNo">2210</span><a id="line.2210">      ++attributeCount;</a>
<span class="sourceLineNo">2211</span><a id="line.2211">    }</a>
<span class="sourceLineNo">2212</span><a id="line.2212">    if (lastRuntimeVisibleParameterAnnotations != null) {</a>
<span class="sourceLineNo">2213</span><a id="line.2213">      ++attributeCount;</a>
<span class="sourceLineNo">2214</span><a id="line.2214">    }</a>
<span class="sourceLineNo">2215</span><a id="line.2215">    if (lastRuntimeInvisibleParameterAnnotations != null) {</a>
<span class="sourceLineNo">2216</span><a id="line.2216">      ++attributeCount;</a>
<span class="sourceLineNo">2217</span><a id="line.2217">    }</a>
<span class="sourceLineNo">2218</span><a id="line.2218">    if (lastRuntimeVisibleTypeAnnotation != null) {</a>
<span class="sourceLineNo">2219</span><a id="line.2219">      ++attributeCount;</a>
<span class="sourceLineNo">2220</span><a id="line.2220">    }</a>
<span class="sourceLineNo">2221</span><a id="line.2221">    if (lastRuntimeInvisibleTypeAnnotation != null) {</a>
<span class="sourceLineNo">2222</span><a id="line.2222">      ++attributeCount;</a>
<span class="sourceLineNo">2223</span><a id="line.2223">    }</a>
<span class="sourceLineNo">2224</span><a id="line.2224">    if (defaultValue != null) {</a>
<span class="sourceLineNo">2225</span><a id="line.2225">      ++attributeCount;</a>
<span class="sourceLineNo">2226</span><a id="line.2226">    }</a>
<span class="sourceLineNo">2227</span><a id="line.2227">    if (parameters != null) {</a>
<span class="sourceLineNo">2228</span><a id="line.2228">      ++attributeCount;</a>
<span class="sourceLineNo">2229</span><a id="line.2229">    }</a>
<span class="sourceLineNo">2230</span><a id="line.2230">    if (firstAttribute != null) {</a>
<span class="sourceLineNo">2231</span><a id="line.2231">      attributeCount += firstAttribute.getAttributeCount();</a>
<span class="sourceLineNo">2232</span><a id="line.2232">    }</a>
<span class="sourceLineNo">2233</span><a id="line.2233">    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.</a>
<span class="sourceLineNo">2234</span><a id="line.2234">    output.putShort(attributeCount);</a>
<span class="sourceLineNo">2235</span><a id="line.2235">    if (code.length &gt; 0) {</a>
<span class="sourceLineNo">2236</span><a id="line.2236">      // 2, 2, 4 and 2 bytes respectively for max_stack, max_locals, code_length and</a>
<span class="sourceLineNo">2237</span><a id="line.2237">      // attributes_count, plus the bytecode and the exception table.</a>
<span class="sourceLineNo">2238</span><a id="line.2238">      int size = 10 + code.length + Handler.getExceptionTableSize(firstHandler);</a>
<span class="sourceLineNo">2239</span><a id="line.2239">      int codeAttributeCount = 0;</a>
<span class="sourceLineNo">2240</span><a id="line.2240">      if (stackMapTableEntries != null) {</a>
<span class="sourceLineNo">2241</span><a id="line.2241">        // 6 header bytes and 2 bytes for number_of_entries.</a>
<span class="sourceLineNo">2242</span><a id="line.2242">        size += 8 + stackMapTableEntries.length;</a>
<span class="sourceLineNo">2243</span><a id="line.2243">        ++codeAttributeCount;</a>
<span class="sourceLineNo">2244</span><a id="line.2244">      }</a>
<span class="sourceLineNo">2245</span><a id="line.2245">      if (lineNumberTable != null) {</a>
<span class="sourceLineNo">2246</span><a id="line.2246">        // 6 header bytes and 2 bytes for line_number_table_length.</a>
<span class="sourceLineNo">2247</span><a id="line.2247">        size += 8 + lineNumberTable.length;</a>
<span class="sourceLineNo">2248</span><a id="line.2248">        ++codeAttributeCount;</a>
<span class="sourceLineNo">2249</span><a id="line.2249">      }</a>
<span class="sourceLineNo">2250</span><a id="line.2250">      if (localVariableTable != null) {</a>
<span class="sourceLineNo">2251</span><a id="line.2251">        // 6 header bytes and 2 bytes for local_variable_table_length.</a>
<span class="sourceLineNo">2252</span><a id="line.2252">        size += 8 + localVariableTable.length;</a>
<span class="sourceLineNo">2253</span><a id="line.2253">        ++codeAttributeCount;</a>
<span class="sourceLineNo">2254</span><a id="line.2254">      }</a>
<span class="sourceLineNo">2255</span><a id="line.2255">      if (localVariableTypeTable != null) {</a>
<span class="sourceLineNo">2256</span><a id="line.2256">        // 6 header bytes and 2 bytes for local_variable_type_table_length.</a>
<span class="sourceLineNo">2257</span><a id="line.2257">        size += 8 + localVariableTypeTable.length;</a>
<span class="sourceLineNo">2258</span><a id="line.2258">        ++codeAttributeCount;</a>
<span class="sourceLineNo">2259</span><a id="line.2259">      }</a>
<span class="sourceLineNo">2260</span><a id="line.2260">      if (lastCodeRuntimeVisibleTypeAnnotation != null) {</a>
<span class="sourceLineNo">2261</span><a id="line.2261">        size +=</a>
<span class="sourceLineNo">2262</span><a id="line.2262">            lastCodeRuntimeVisibleTypeAnnotation.computeAnnotationsSize(</a>
<span class="sourceLineNo">2263</span><a id="line.2263">                Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);</a>
<span class="sourceLineNo">2264</span><a id="line.2264">        ++codeAttributeCount;</a>
<span class="sourceLineNo">2265</span><a id="line.2265">      }</a>
<span class="sourceLineNo">2266</span><a id="line.2266">      if (lastCodeRuntimeInvisibleTypeAnnotation != null) {</a>
<span class="sourceLineNo">2267</span><a id="line.2267">        size +=</a>
<span class="sourceLineNo">2268</span><a id="line.2268">            lastCodeRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(</a>
<span class="sourceLineNo">2269</span><a id="line.2269">                Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);</a>
<span class="sourceLineNo">2270</span><a id="line.2270">        ++codeAttributeCount;</a>
<span class="sourceLineNo">2271</span><a id="line.2271">      }</a>
<span class="sourceLineNo">2272</span><a id="line.2272">      if (firstCodeAttribute != null) {</a>
<span class="sourceLineNo">2273</span><a id="line.2273">        size +=</a>
<span class="sourceLineNo">2274</span><a id="line.2274">            firstCodeAttribute.computeAttributesSize(</a>
<span class="sourceLineNo">2275</span><a id="line.2275">                symbolTable, code.data, code.length, maxStack, maxLocals);</a>
<span class="sourceLineNo">2276</span><a id="line.2276">        codeAttributeCount += firstCodeAttribute.getAttributeCount();</a>
<span class="sourceLineNo">2277</span><a id="line.2277">      }</a>
<span class="sourceLineNo">2278</span><a id="line.2278">      output</a>
<span class="sourceLineNo">2279</span><a id="line.2279">          .putShort(symbolTable.addConstantUtf8(Constants.CODE))</a>
<span class="sourceLineNo">2280</span><a id="line.2280">          .putInt(size)</a>
<span class="sourceLineNo">2281</span><a id="line.2281">          .putShort(maxStack)</a>
<span class="sourceLineNo">2282</span><a id="line.2282">          .putShort(maxLocals)</a>
<span class="sourceLineNo">2283</span><a id="line.2283">          .putInt(code.length)</a>
<span class="sourceLineNo">2284</span><a id="line.2284">          .putByteArray(code.data, 0, code.length);</a>
<span class="sourceLineNo">2285</span><a id="line.2285">      Handler.putExceptionTable(firstHandler, output);</a>
<span class="sourceLineNo">2286</span><a id="line.2286">      output.putShort(codeAttributeCount);</a>
<span class="sourceLineNo">2287</span><a id="line.2287">      if (stackMapTableEntries != null) {</a>
<span class="sourceLineNo">2288</span><a id="line.2288">        boolean useStackMapTable = symbolTable.getMajorVersion() &gt;= Opcodes.V1_6;</a>
<span class="sourceLineNo">2289</span><a id="line.2289">        output</a>
<span class="sourceLineNo">2290</span><a id="line.2290">            .putShort(</a>
<span class="sourceLineNo">2291</span><a id="line.2291">                symbolTable.addConstantUtf8(</a>
<span class="sourceLineNo">2292</span><a id="line.2292">                    useStackMapTable ? Constants.STACK_MAP_TABLE : "StackMap"))</a>
<span class="sourceLineNo">2293</span><a id="line.2293">            .putInt(2 + stackMapTableEntries.length)</a>
<span class="sourceLineNo">2294</span><a id="line.2294">            .putShort(stackMapTableNumberOfEntries)</a>
<span class="sourceLineNo">2295</span><a id="line.2295">            .putByteArray(stackMapTableEntries.data, 0, stackMapTableEntries.length);</a>
<span class="sourceLineNo">2296</span><a id="line.2296">      }</a>
<span class="sourceLineNo">2297</span><a id="line.2297">      if (lineNumberTable != null) {</a>
<span class="sourceLineNo">2298</span><a id="line.2298">        output</a>
<span class="sourceLineNo">2299</span><a id="line.2299">            .putShort(symbolTable.addConstantUtf8(Constants.LINE_NUMBER_TABLE))</a>
<span class="sourceLineNo">2300</span><a id="line.2300">            .putInt(2 + lineNumberTable.length)</a>
<span class="sourceLineNo">2301</span><a id="line.2301">            .putShort(lineNumberTableLength)</a>
<span class="sourceLineNo">2302</span><a id="line.2302">            .putByteArray(lineNumberTable.data, 0, lineNumberTable.length);</a>
<span class="sourceLineNo">2303</span><a id="line.2303">      }</a>
<span class="sourceLineNo">2304</span><a id="line.2304">      if (localVariableTable != null) {</a>
<span class="sourceLineNo">2305</span><a id="line.2305">        output</a>
<span class="sourceLineNo">2306</span><a id="line.2306">            .putShort(symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TABLE))</a>
<span class="sourceLineNo">2307</span><a id="line.2307">            .putInt(2 + localVariableTable.length)</a>
<span class="sourceLineNo">2308</span><a id="line.2308">            .putShort(localVariableTableLength)</a>
<span class="sourceLineNo">2309</span><a id="line.2309">            .putByteArray(localVariableTable.data, 0, localVariableTable.length);</a>
<span class="sourceLineNo">2310</span><a id="line.2310">      }</a>
<span class="sourceLineNo">2311</span><a id="line.2311">      if (localVariableTypeTable != null) {</a>
<span class="sourceLineNo">2312</span><a id="line.2312">        output</a>
<span class="sourceLineNo">2313</span><a id="line.2313">            .putShort(symbolTable.addConstantUtf8(Constants.LOCAL_VARIABLE_TYPE_TABLE))</a>
<span class="sourceLineNo">2314</span><a id="line.2314">            .putInt(2 + localVariableTypeTable.length)</a>
<span class="sourceLineNo">2315</span><a id="line.2315">            .putShort(localVariableTypeTableLength)</a>
<span class="sourceLineNo">2316</span><a id="line.2316">            .putByteArray(localVariableTypeTable.data, 0, localVariableTypeTable.length);</a>
<span class="sourceLineNo">2317</span><a id="line.2317">      }</a>
<span class="sourceLineNo">2318</span><a id="line.2318">      if (lastCodeRuntimeVisibleTypeAnnotation != null) {</a>
<span class="sourceLineNo">2319</span><a id="line.2319">        lastCodeRuntimeVisibleTypeAnnotation.putAnnotations(</a>
<span class="sourceLineNo">2320</span><a id="line.2320">            symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output);</a>
<span class="sourceLineNo">2321</span><a id="line.2321">      }</a>
<span class="sourceLineNo">2322</span><a id="line.2322">      if (lastCodeRuntimeInvisibleTypeAnnotation != null) {</a>
<span class="sourceLineNo">2323</span><a id="line.2323">        lastCodeRuntimeInvisibleTypeAnnotation.putAnnotations(</a>
<span class="sourceLineNo">2324</span><a id="line.2324">            symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output);</a>
<span class="sourceLineNo">2325</span><a id="line.2325">      }</a>
<span class="sourceLineNo">2326</span><a id="line.2326">      if (firstCodeAttribute != null) {</a>
<span class="sourceLineNo">2327</span><a id="line.2327">        firstCodeAttribute.putAttributes(</a>
<span class="sourceLineNo">2328</span><a id="line.2328">            symbolTable, code.data, code.length, maxStack, maxLocals, output);</a>
<span class="sourceLineNo">2329</span><a id="line.2329">      }</a>
<span class="sourceLineNo">2330</span><a id="line.2330">    }</a>
<span class="sourceLineNo">2331</span><a id="line.2331">    if (numberOfExceptions &gt; 0) {</a>
<span class="sourceLineNo">2332</span><a id="line.2332">      output</a>
<span class="sourceLineNo">2333</span><a id="line.2333">          .putShort(symbolTable.addConstantUtf8(Constants.EXCEPTIONS))</a>
<span class="sourceLineNo">2334</span><a id="line.2334">          .putInt(2 + 2 * numberOfExceptions)</a>
<span class="sourceLineNo">2335</span><a id="line.2335">          .putShort(numberOfExceptions);</a>
<span class="sourceLineNo">2336</span><a id="line.2336">      for (int exceptionIndex : exceptionIndexTable) {</a>
<span class="sourceLineNo">2337</span><a id="line.2337">        output.putShort(exceptionIndex);</a>
<span class="sourceLineNo">2338</span><a id="line.2338">      }</a>
<span class="sourceLineNo">2339</span><a id="line.2339">    }</a>
<span class="sourceLineNo">2340</span><a id="line.2340">    if ((accessFlags &amp; Opcodes.ACC_SYNTHETIC) != 0 &amp;&amp; useSyntheticAttribute) {</a>
<span class="sourceLineNo">2341</span><a id="line.2341">      output.putShort(symbolTable.addConstantUtf8(Constants.SYNTHETIC)).putInt(0);</a>
<span class="sourceLineNo">2342</span><a id="line.2342">    }</a>
<span class="sourceLineNo">2343</span><a id="line.2343">    if (signatureIndex != 0) {</a>
<span class="sourceLineNo">2344</span><a id="line.2344">      output</a>
<span class="sourceLineNo">2345</span><a id="line.2345">          .putShort(symbolTable.addConstantUtf8(Constants.SIGNATURE))</a>
<span class="sourceLineNo">2346</span><a id="line.2346">          .putInt(2)</a>
<span class="sourceLineNo">2347</span><a id="line.2347">          .putShort(signatureIndex);</a>
<span class="sourceLineNo">2348</span><a id="line.2348">    }</a>
<span class="sourceLineNo">2349</span><a id="line.2349">    if ((accessFlags &amp; Opcodes.ACC_DEPRECATED) != 0) {</a>
<span class="sourceLineNo">2350</span><a id="line.2350">      output.putShort(symbolTable.addConstantUtf8(Constants.DEPRECATED)).putInt(0);</a>
<span class="sourceLineNo">2351</span><a id="line.2351">    }</a>
<span class="sourceLineNo">2352</span><a id="line.2352">    if (lastRuntimeVisibleAnnotation != null) {</a>
<span class="sourceLineNo">2353</span><a id="line.2353">      lastRuntimeVisibleAnnotation.putAnnotations(</a>
<span class="sourceLineNo">2354</span><a id="line.2354">          symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_ANNOTATIONS), output);</a>
<span class="sourceLineNo">2355</span><a id="line.2355">    }</a>
<span class="sourceLineNo">2356</span><a id="line.2356">    if (lastRuntimeInvisibleAnnotation != null) {</a>
<span class="sourceLineNo">2357</span><a id="line.2357">      lastRuntimeInvisibleAnnotation.putAnnotations(</a>
<span class="sourceLineNo">2358</span><a id="line.2358">          symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_ANNOTATIONS), output);</a>
<span class="sourceLineNo">2359</span><a id="line.2359">    }</a>
<span class="sourceLineNo">2360</span><a id="line.2360">    if (lastRuntimeVisibleParameterAnnotations != null) {</a>
<span class="sourceLineNo">2361</span><a id="line.2361">      AnnotationWriter.putParameterAnnotations(</a>
<span class="sourceLineNo">2362</span><a id="line.2362">          symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS),</a>
<span class="sourceLineNo">2363</span><a id="line.2363">          lastRuntimeVisibleParameterAnnotations,</a>
<span class="sourceLineNo">2364</span><a id="line.2364">          visibleAnnotableParameterCount == 0</a>
<span class="sourceLineNo">2365</span><a id="line.2365">              ? lastRuntimeVisibleParameterAnnotations.length</a>
<span class="sourceLineNo">2366</span><a id="line.2366">              : visibleAnnotableParameterCount,</a>
<span class="sourceLineNo">2367</span><a id="line.2367">          output);</a>
<span class="sourceLineNo">2368</span><a id="line.2368">    }</a>
<span class="sourceLineNo">2369</span><a id="line.2369">    if (lastRuntimeInvisibleParameterAnnotations != null) {</a>
<span class="sourceLineNo">2370</span><a id="line.2370">      AnnotationWriter.putParameterAnnotations(</a>
<span class="sourceLineNo">2371</span><a id="line.2371">          symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS),</a>
<span class="sourceLineNo">2372</span><a id="line.2372">          lastRuntimeInvisibleParameterAnnotations,</a>
<span class="sourceLineNo">2373</span><a id="line.2373">          invisibleAnnotableParameterCount == 0</a>
<span class="sourceLineNo">2374</span><a id="line.2374">              ? lastRuntimeInvisibleParameterAnnotations.length</a>
<span class="sourceLineNo">2375</span><a id="line.2375">              : invisibleAnnotableParameterCount,</a>
<span class="sourceLineNo">2376</span><a id="line.2376">          output);</a>
<span class="sourceLineNo">2377</span><a id="line.2377">    }</a>
<span class="sourceLineNo">2378</span><a id="line.2378">    if (lastRuntimeVisibleTypeAnnotation != null) {</a>
<span class="sourceLineNo">2379</span><a id="line.2379">      lastRuntimeVisibleTypeAnnotation.putAnnotations(</a>
<span class="sourceLineNo">2380</span><a id="line.2380">          symbolTable.addConstantUtf8(Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS), output);</a>
<span class="sourceLineNo">2381</span><a id="line.2381">    }</a>
<span class="sourceLineNo">2382</span><a id="line.2382">    if (lastRuntimeInvisibleTypeAnnotation != null) {</a>
<span class="sourceLineNo">2383</span><a id="line.2383">      lastRuntimeInvisibleTypeAnnotation.putAnnotations(</a>
<span class="sourceLineNo">2384</span><a id="line.2384">          symbolTable.addConstantUtf8(Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS), output);</a>
<span class="sourceLineNo">2385</span><a id="line.2385">    }</a>
<span class="sourceLineNo">2386</span><a id="line.2386">    if (defaultValue != null) {</a>
<span class="sourceLineNo">2387</span><a id="line.2387">      output</a>
<span class="sourceLineNo">2388</span><a id="line.2388">          .putShort(symbolTable.addConstantUtf8(Constants.ANNOTATION_DEFAULT))</a>
<span class="sourceLineNo">2389</span><a id="line.2389">          .putInt(defaultValue.length)</a>
<span class="sourceLineNo">2390</span><a id="line.2390">          .putByteArray(defaultValue.data, 0, defaultValue.length);</a>
<span class="sourceLineNo">2391</span><a id="line.2391">    }</a>
<span class="sourceLineNo">2392</span><a id="line.2392">    if (parameters != null) {</a>
<span class="sourceLineNo">2393</span><a id="line.2393">      output</a>
<span class="sourceLineNo">2394</span><a id="line.2394">          .putShort(symbolTable.addConstantUtf8(Constants.METHOD_PARAMETERS))</a>
<span class="sourceLineNo">2395</span><a id="line.2395">          .putInt(1 + parameters.length)</a>
<span class="sourceLineNo">2396</span><a id="line.2396">          .putByte(parametersCount)</a>
<span class="sourceLineNo">2397</span><a id="line.2397">          .putByteArray(parameters.data, 0, parameters.length);</a>
<span class="sourceLineNo">2398</span><a id="line.2398">    }</a>
<span class="sourceLineNo">2399</span><a id="line.2399">    if (firstAttribute != null) {</a>
<span class="sourceLineNo">2400</span><a id="line.2400">      firstAttribute.putAttributes(symbolTable, output);</a>
<span class="sourceLineNo">2401</span><a id="line.2401">    }</a>
<span class="sourceLineNo">2402</span><a id="line.2402">  }</a>
<span class="sourceLineNo">2403</span><a id="line.2403"></a>
<span class="sourceLineNo">2404</span><a id="line.2404">  /**</a>
<span class="sourceLineNo">2405</span><a id="line.2405">   * Collects the attributes of this method into the given set of attribute prototypes.</a>
<span class="sourceLineNo">2406</span><a id="line.2406">   *</a>
<span class="sourceLineNo">2407</span><a id="line.2407">   * @param attributePrototypes a set of attribute prototypes.</a>
<span class="sourceLineNo">2408</span><a id="line.2408">   */</a>
<span class="sourceLineNo">2409</span><a id="line.2409">  final void collectAttributePrototypes(final Attribute.Set attributePrototypes) {</a>
<span class="sourceLineNo">2410</span><a id="line.2410">    attributePrototypes.addAttributes(firstAttribute);</a>
<span class="sourceLineNo">2411</span><a id="line.2411">    attributePrototypes.addAttributes(firstCodeAttribute);</a>
<span class="sourceLineNo">2412</span><a id="line.2412">  }</a>
<span class="sourceLineNo">2413</span><a id="line.2413">}</a>




























































</pre>
</div>
</main>
</body>
</html>
