<!DOCTYPE HTML>
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<main role="main">
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span><a id="line.1">// ASM: a very small and fast Java bytecode manipulation framework</a>
<span class="sourceLineNo">002</span><a id="line.2">// Copyright (c) 2000-2011 INRIA, France Telecom</a>
<span class="sourceLineNo">003</span><a id="line.3">// All rights reserved.</a>
<span class="sourceLineNo">004</span><a id="line.4">//</a>
<span class="sourceLineNo">005</span><a id="line.5">// Redistribution and use in source and binary forms, with or without</a>
<span class="sourceLineNo">006</span><a id="line.6">// modification, are permitted provided that the following conditions</a>
<span class="sourceLineNo">007</span><a id="line.7">// are met:</a>
<span class="sourceLineNo">008</span><a id="line.8">// 1. Redistributions of source code must retain the above copyright</a>
<span class="sourceLineNo">009</span><a id="line.9">//    notice, this list of conditions and the following disclaimer.</a>
<span class="sourceLineNo">010</span><a id="line.10">// 2. Redistributions in binary form must reproduce the above copyright</a>
<span class="sourceLineNo">011</span><a id="line.11">//    notice, this list of conditions and the following disclaimer in the</a>
<span class="sourceLineNo">012</span><a id="line.12">//    documentation and/or other materials provided with the distribution.</a>
<span class="sourceLineNo">013</span><a id="line.13">// 3. Neither the name of the copyright holders nor the names of its</a>
<span class="sourceLineNo">014</span><a id="line.14">//    contributors may be used to endorse or promote products derived from</a>
<span class="sourceLineNo">015</span><a id="line.15">//    this software without specific prior written permission.</a>
<span class="sourceLineNo">016</span><a id="line.16">//</a>
<span class="sourceLineNo">017</span><a id="line.17">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</a>
<span class="sourceLineNo">018</span><a id="line.18">// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<span class="sourceLineNo">019</span><a id="line.19">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<span class="sourceLineNo">020</span><a id="line.20">// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</a>
<span class="sourceLineNo">021</span><a id="line.21">// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<span class="sourceLineNo">022</span><a id="line.22">// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<span class="sourceLineNo">023</span><a id="line.23">// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<span class="sourceLineNo">024</span><a id="line.24">// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<span class="sourceLineNo">025</span><a id="line.25">// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<span class="sourceLineNo">026</span><a id="line.26">// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</a>
<span class="sourceLineNo">027</span><a id="line.27">// THE POSSIBILITY OF SUCH DAMAGE.</a>
<span class="sourceLineNo">028</span><a id="line.28">package clojure.asm;</a>
<span class="sourceLineNo">029</span><a id="line.29"></a>
<span class="sourceLineNo">030</span><a id="line.30">/**</a>
<span class="sourceLineNo">031</span><a id="line.31"> * A position in the bytecode of a method. Labels are used for jump, goto, and switch instructions,</a>
<span class="sourceLineNo">032</span><a id="line.32"> * and for try catch blocks. A label designates the &lt;i&gt;instruction&lt;/i&gt; that is just after. Note</a>
<span class="sourceLineNo">033</span><a id="line.33"> * however that there can be other elements between a label and the instruction it designates (such</a>
<span class="sourceLineNo">034</span><a id="line.34"> * as other labels, stack map frames, line numbers, etc.).</a>
<span class="sourceLineNo">035</span><a id="line.35"> *</a>
<span class="sourceLineNo">036</span><a id="line.36"> * @author Eric Bruneton</a>
<span class="sourceLineNo">037</span><a id="line.37"> */</a>
<span class="sourceLineNo">038</span><a id="line.38">public class Label {</a>
<span class="sourceLineNo">039</span><a id="line.39"></a>
<span class="sourceLineNo">040</span><a id="line.40">  /**</a>
<span class="sourceLineNo">041</span><a id="line.41">   * A flag indicating that a label is only used for debug attributes. Such a label is not the start</a>
<span class="sourceLineNo">042</span><a id="line.42">   * of a basic block, the target of a jump instruction, or an exception handler. It can be safely</a>
<span class="sourceLineNo">043</span><a id="line.43">   * ignored in control flow graph analysis algorithms (for optimization purposes).</a>
<span class="sourceLineNo">044</span><a id="line.44">   */</a>
<span class="sourceLineNo">045</span><a id="line.45">  static final int FLAG_DEBUG_ONLY = 1;</a>
<span class="sourceLineNo">046</span><a id="line.46"></a>
<span class="sourceLineNo">047</span><a id="line.47">  /**</a>
<span class="sourceLineNo">048</span><a id="line.48">   * A flag indicating that a label is the target of a jump instruction, or the start of an</a>
<span class="sourceLineNo">049</span><a id="line.49">   * exception handler.</a>
<span class="sourceLineNo">050</span><a id="line.50">   */</a>
<span class="sourceLineNo">051</span><a id="line.51">  static final int FLAG_JUMP_TARGET = 2;</a>
<span class="sourceLineNo">052</span><a id="line.52"></a>
<span class="sourceLineNo">053</span><a id="line.53">  /** A flag indicating that the bytecode offset of a label is known. */</a>
<span class="sourceLineNo">054</span><a id="line.54">  static final int FLAG_RESOLVED = 4;</a>
<span class="sourceLineNo">055</span><a id="line.55"></a>
<span class="sourceLineNo">056</span><a id="line.56">  /** A flag indicating that a label corresponds to a reachable basic block. */</a>
<span class="sourceLineNo">057</span><a id="line.57">  static final int FLAG_REACHABLE = 8;</a>
<span class="sourceLineNo">058</span><a id="line.58"></a>
<span class="sourceLineNo">059</span><a id="line.59">  /**</a>
<span class="sourceLineNo">060</span><a id="line.60">   * A flag indicating that the basic block corresponding to a label ends with a subroutine call. By</a>
<span class="sourceLineNo">061</span><a id="line.61">   * construction in {@link MethodWriter#visitJumpInsn}, labels with this flag set have at least two</a>
<span class="sourceLineNo">062</span><a id="line.62">   * outgoing edges:</a>
<span class="sourceLineNo">063</span><a id="line.63">   *</a>
<span class="sourceLineNo">064</span><a id="line.64">   * &lt;ul&gt;</a>
<span class="sourceLineNo">065</span><a id="line.65">   *   &lt;li&gt;the first one corresponds to the instruction that follows the jsr instruction in the</a>
<span class="sourceLineNo">066</span><a id="line.66">   *       bytecode, i.e. where execution continues when it returns from the jsr call. This is a</a>
<span class="sourceLineNo">067</span><a id="line.67">   *       virtual control flow edge, since execution never goes directly from the jsr to the next</a>
<span class="sourceLineNo">068</span><a id="line.68">   *       instruction. Instead, it goes to the subroutine and eventually returns to the instruction</a>
<span class="sourceLineNo">069</span><a id="line.69">   *       following the jsr. This virtual edge is used to compute the real outgoing edges of the</a>
<span class="sourceLineNo">070</span><a id="line.70">   *       basic blocks ending with a ret instruction, in {@link #addSubroutineRetSuccessors}.</a>
<span class="sourceLineNo">071</span><a id="line.71">   *   &lt;li&gt;the second one corresponds to the target of the jsr instruction,</a>
<span class="sourceLineNo">072</span><a id="line.72">   * &lt;/ul&gt;</a>
<span class="sourceLineNo">073</span><a id="line.73">   */</a>
<span class="sourceLineNo">074</span><a id="line.74">  static final int FLAG_SUBROUTINE_CALLER = 16;</a>
<span class="sourceLineNo">075</span><a id="line.75"></a>
<span class="sourceLineNo">076</span><a id="line.76">  /**</a>
<span class="sourceLineNo">077</span><a id="line.77">   * A flag indicating that the basic block corresponding to a label is the start of a subroutine.</a>
<span class="sourceLineNo">078</span><a id="line.78">   */</a>
<span class="sourceLineNo">079</span><a id="line.79">  static final int FLAG_SUBROUTINE_START = 32;</a>
<span class="sourceLineNo">080</span><a id="line.80"></a>
<span class="sourceLineNo">081</span><a id="line.81">  /** A flag indicating that the basic block corresponding to a label is the end of a subroutine. */</a>
<span class="sourceLineNo">082</span><a id="line.82">  static final int FLAG_SUBROUTINE_END = 64;</a>
<span class="sourceLineNo">083</span><a id="line.83"></a>
<span class="sourceLineNo">084</span><a id="line.84">  /**</a>
<span class="sourceLineNo">085</span><a id="line.85">   * The number of elements to add to the {@link #otherLineNumbers} array when it needs to be</a>
<span class="sourceLineNo">086</span><a id="line.86">   * resized to store a new source line number.</a>
<span class="sourceLineNo">087</span><a id="line.87">   */</a>
<span class="sourceLineNo">088</span><a id="line.88">  static final int LINE_NUMBERS_CAPACITY_INCREMENT = 4;</a>
<span class="sourceLineNo">089</span><a id="line.89"></a>
<span class="sourceLineNo">090</span><a id="line.90">  /**</a>
<span class="sourceLineNo">091</span><a id="line.91">   * The number of elements to add to the {@link #forwardReferences} array when it needs to be</a>
<span class="sourceLineNo">092</span><a id="line.92">   * resized to store a new forward reference.</a>
<span class="sourceLineNo">093</span><a id="line.93">   */</a>
<span class="sourceLineNo">094</span><a id="line.94">  static final int FORWARD_REFERENCES_CAPACITY_INCREMENT = 6;</a>
<span class="sourceLineNo">095</span><a id="line.95"></a>
<span class="sourceLineNo">096</span><a id="line.96">  /**</a>
<span class="sourceLineNo">097</span><a id="line.97">   * The bit mask to extract the type of a forward reference to this label. The extracted type is</a>
<span class="sourceLineNo">098</span><a id="line.98">   * either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link #FORWARD_REFERENCE_TYPE_WIDE}.</a>
<span class="sourceLineNo">099</span><a id="line.99">   *</a>
<span class="sourceLineNo">100</span><a id="line.100">   * @see #forwardReferences</a>
<span class="sourceLineNo">101</span><a id="line.101">   */</a>
<span class="sourceLineNo">102</span><a id="line.102">  static final int FORWARD_REFERENCE_TYPE_MASK = 0xF0000000;</a>
<span class="sourceLineNo">103</span><a id="line.103"></a>
<span class="sourceLineNo">104</span><a id="line.104">  /**</a>
<span class="sourceLineNo">105</span><a id="line.105">   * The type of forward references stored with two bytes in the bytecode. This is the case, for</a>
<span class="sourceLineNo">106</span><a id="line.106">   * instance, of a forward reference from an ifnull instruction.</a>
<span class="sourceLineNo">107</span><a id="line.107">   */</a>
<span class="sourceLineNo">108</span><a id="line.108">  static final int FORWARD_REFERENCE_TYPE_SHORT = 0x10000000;</a>
<span class="sourceLineNo">109</span><a id="line.109"></a>
<span class="sourceLineNo">110</span><a id="line.110">  /**</a>
<span class="sourceLineNo">111</span><a id="line.111">   * The type of forward references stored in four bytes in the bytecode. This is the case, for</a>
<span class="sourceLineNo">112</span><a id="line.112">   * instance, of a forward reference from a lookupswitch instruction.</a>
<span class="sourceLineNo">113</span><a id="line.113">   */</a>
<span class="sourceLineNo">114</span><a id="line.114">  static final int FORWARD_REFERENCE_TYPE_WIDE = 0x20000000;</a>
<span class="sourceLineNo">115</span><a id="line.115"></a>
<span class="sourceLineNo">116</span><a id="line.116">  /**</a>
<span class="sourceLineNo">117</span><a id="line.117">   * The bit mask to extract the 'handle' of a forward reference to this label. The extracted handle</a>
<span class="sourceLineNo">118</span><a id="line.118">   * is the bytecode offset where the forward reference value is stored (using either 2 or 4 bytes,</a>
<span class="sourceLineNo">119</span><a id="line.119">   * as indicated by the {@link #FORWARD_REFERENCE_TYPE_MASK}).</a>
<span class="sourceLineNo">120</span><a id="line.120">   *</a>
<span class="sourceLineNo">121</span><a id="line.121">   * @see #forwardReferences</a>
<span class="sourceLineNo">122</span><a id="line.122">   */</a>
<span class="sourceLineNo">123</span><a id="line.123">  static final int FORWARD_REFERENCE_HANDLE_MASK = 0x0FFFFFFF;</a>
<span class="sourceLineNo">124</span><a id="line.124"></a>
<span class="sourceLineNo">125</span><a id="line.125">  /**</a>
<span class="sourceLineNo">126</span><a id="line.126">   * A sentinel element used to indicate the end of a list of labels.</a>
<span class="sourceLineNo">127</span><a id="line.127">   *</a>
<span class="sourceLineNo">128</span><a id="line.128">   * @see #nextListElement</a>
<span class="sourceLineNo">129</span><a id="line.129">   */</a>
<span class="sourceLineNo">130</span><a id="line.130">  static final Label EMPTY_LIST = new Label();</a>
<span class="sourceLineNo">131</span><a id="line.131"></a>
<span class="sourceLineNo">132</span><a id="line.132">  /**</a>
<span class="sourceLineNo">133</span><a id="line.133">   * A user managed state associated with this label. Warning: this field is used by the ASM tree</a>
<span class="sourceLineNo">134</span><a id="line.134">   * package. In order to use it with the ASM tree package you must override the getLabelNode method</a>
<span class="sourceLineNo">135</span><a id="line.135">   * in MethodNode.</a>
<span class="sourceLineNo">136</span><a id="line.136">   */</a>
<span class="sourceLineNo">137</span><a id="line.137">  public Object info;</a>
<span class="sourceLineNo">138</span><a id="line.138"></a>
<span class="sourceLineNo">139</span><a id="line.139">  /**</a>
<span class="sourceLineNo">140</span><a id="line.140">   * The type and status of this label or its corresponding basic block. Must be zero or more of</a>
<span class="sourceLineNo">141</span><a id="line.141">   * {@link #FLAG_DEBUG_ONLY}, {@link #FLAG_JUMP_TARGET}, {@link #FLAG_RESOLVED}, {@link</a>
<span class="sourceLineNo">142</span><a id="line.142">   * #FLAG_REACHABLE}, {@link #FLAG_SUBROUTINE_CALLER}, {@link #FLAG_SUBROUTINE_START}, {@link</a>
<span class="sourceLineNo">143</span><a id="line.143">   * #FLAG_SUBROUTINE_END}.</a>
<span class="sourceLineNo">144</span><a id="line.144">   */</a>
<span class="sourceLineNo">145</span><a id="line.145">  short flags;</a>
<span class="sourceLineNo">146</span><a id="line.146"></a>
<span class="sourceLineNo">147</span><a id="line.147">  /**</a>
<span class="sourceLineNo">148</span><a id="line.148">   * The source line number corresponding to this label, or 0. If there are several source line</a>
<span class="sourceLineNo">149</span><a id="line.149">   * numbers corresponding to this label, the first one is stored in this field, and the remaining</a>
<span class="sourceLineNo">150</span><a id="line.150">   * ones are stored in {@link #otherLineNumbers}.</a>
<span class="sourceLineNo">151</span><a id="line.151">   */</a>
<span class="sourceLineNo">152</span><a id="line.152">  private short lineNumber;</a>
<span class="sourceLineNo">153</span><a id="line.153"></a>
<span class="sourceLineNo">154</span><a id="line.154">  /**</a>
<span class="sourceLineNo">155</span><a id="line.155">   * The source line numbers corresponding to this label, in addition to {@link #lineNumber}, or</a>
<span class="sourceLineNo">156</span><a id="line.156">   * null. The first element of this array is the number n of source line numbers it contains, which</a>
<span class="sourceLineNo">157</span><a id="line.157">   * are stored between indices 1 and n (inclusive).</a>
<span class="sourceLineNo">158</span><a id="line.158">   */</a>
<span class="sourceLineNo">159</span><a id="line.159">  private int[] otherLineNumbers;</a>
<span class="sourceLineNo">160</span><a id="line.160"></a>
<span class="sourceLineNo">161</span><a id="line.161">  /**</a>
<span class="sourceLineNo">162</span><a id="line.162">   * The offset of this label in the bytecode of its method, in bytes. This value is set if and only</a>
<span class="sourceLineNo">163</span><a id="line.163">   * if the {@link #FLAG_RESOLVED} flag is set.</a>
<span class="sourceLineNo">164</span><a id="line.164">   */</a>
<span class="sourceLineNo">165</span><a id="line.165">  int bytecodeOffset;</a>
<span class="sourceLineNo">166</span><a id="line.166"></a>
<span class="sourceLineNo">167</span><a id="line.167">  /**</a>
<span class="sourceLineNo">168</span><a id="line.168">   * The forward references to this label. The first element is the number of forward references,</a>
<span class="sourceLineNo">169</span><a id="line.169">   * times 2 (this corresponds to the index of the last element actually used in this array). Then,</a>
<span class="sourceLineNo">170</span><a id="line.170">   * each forward reference is described with two consecutive integers noted</a>
<span class="sourceLineNo">171</span><a id="line.171">   * 'sourceInsnBytecodeOffset' and 'reference':</a>
<span class="sourceLineNo">172</span><a id="line.172">   *</a>
<span class="sourceLineNo">173</span><a id="line.173">   * &lt;ul&gt;</a>
<span class="sourceLineNo">174</span><a id="line.174">   *   &lt;li&gt;'sourceInsnBytecodeOffset' is the bytecode offset of the instruction that contains the</a>
<span class="sourceLineNo">175</span><a id="line.175">   *       forward reference,</a>
<span class="sourceLineNo">176</span><a id="line.176">   *   &lt;li&gt;'reference' contains the type and the offset in the bytecode where the forward reference</a>
<span class="sourceLineNo">177</span><a id="line.177">   *       value must be stored, which can be extracted with {@link #FORWARD_REFERENCE_TYPE_MASK}</a>
<span class="sourceLineNo">178</span><a id="line.178">   *       and {@link #FORWARD_REFERENCE_HANDLE_MASK}.</a>
<span class="sourceLineNo">179</span><a id="line.179">   * &lt;/ul&gt;</a>
<span class="sourceLineNo">180</span><a id="line.180">   *</a>
<span class="sourceLineNo">181</span><a id="line.181">   * For instance, for an ifnull instruction at bytecode offset x, 'sourceInsnBytecodeOffset' is</a>
<span class="sourceLineNo">182</span><a id="line.182">   * equal to x, and 'reference' is of type {@link #FORWARD_REFERENCE_TYPE_SHORT} with value x + 1</a>
<span class="sourceLineNo">183</span><a id="line.183">   * (because the ifnull instruction uses a 2 bytes bytecode offset operand stored one byte after</a>
<span class="sourceLineNo">184</span><a id="line.184">   * the start of the instruction itself). For the default case of a lookupswitch instruction at</a>
<span class="sourceLineNo">185</span><a id="line.185">   * bytecode offset x, 'sourceInsnBytecodeOffset' is equal to x, and 'reference' is of type {@link</a>
<span class="sourceLineNo">186</span><a id="line.186">   * #FORWARD_REFERENCE_TYPE_WIDE} with value between x + 1 and x + 4 (because the lookupswitch</a>
<span class="sourceLineNo">187</span><a id="line.187">   * instruction uses a 4 bytes bytecode offset operand stored one to four bytes after the start of</a>
<span class="sourceLineNo">188</span><a id="line.188">   * the instruction itself).</a>
<span class="sourceLineNo">189</span><a id="line.189">   */</a>
<span class="sourceLineNo">190</span><a id="line.190">  private int[] forwardReferences;</a>
<span class="sourceLineNo">191</span><a id="line.191"></a>
<span class="sourceLineNo">192</span><a id="line.192">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">193</span><a id="line.193"></a>
<span class="sourceLineNo">194</span><a id="line.194">  // Fields for the control flow and data flow graph analysis algorithms (used to compute the</a>
<span class="sourceLineNo">195</span><a id="line.195">  // maximum stack size or the stack map frames). A control flow graph contains one node per "basic</a>
<span class="sourceLineNo">196</span><a id="line.196">  // block", and one edge per "jump" from one basic block to another. Each node (i.e., each basic</a>
<span class="sourceLineNo">197</span><a id="line.197">  // block) is represented with the Label object that corresponds to the first instruction of this</a>
<span class="sourceLineNo">198</span><a id="line.198">  // basic block. Each node also stores the list of its successors in the graph, as a linked list of</a>
<span class="sourceLineNo">199</span><a id="line.199">  // Edge objects.</a>
<span class="sourceLineNo">200</span><a id="line.200">  //</a>
<span class="sourceLineNo">201</span><a id="line.201">  // The control flow analysis algorithms used to compute the maximum stack size or the stack map</a>
<span class="sourceLineNo">202</span><a id="line.202">  // frames are similar and use two steps. The first step, during the visit of each instruction,</a>
<span class="sourceLineNo">203</span><a id="line.203">  // builds information about the state of the local variables and the operand stack at the end of</a>
<span class="sourceLineNo">204</span><a id="line.204">  // each basic block, called the "output frame", &lt;i&gt;relatively&lt;/i&gt; to the frame state at the</a>
<span class="sourceLineNo">205</span><a id="line.205">  // beginning of the basic block, which is called the "input frame", and which is &lt;i&gt;unknown&lt;/i&gt;</a>
<span class="sourceLineNo">206</span><a id="line.206">  // during this step. The second step, in {@link MethodWriter#computeAllFrames} and {@link</a>
<span class="sourceLineNo">207</span><a id="line.207">  // MethodWriter#computeMaxStackAndLocal}, is a fix point algorithm</a>
<span class="sourceLineNo">208</span><a id="line.208">  // that computes information about the input frame of each basic block, from the input state of</a>
<span class="sourceLineNo">209</span><a id="line.209">  // the first basic block (known from the method signature), and by the using the previously</a>
<span class="sourceLineNo">210</span><a id="line.210">  // computed relative output frames.</a>
<span class="sourceLineNo">211</span><a id="line.211">  //</a>
<span class="sourceLineNo">212</span><a id="line.212">  // The algorithm used to compute the maximum stack size only computes the relative output and</a>
<span class="sourceLineNo">213</span><a id="line.213">  // absolute input stack heights, while the algorithm used to compute stack map frames computes</a>
<span class="sourceLineNo">214</span><a id="line.214">  // relative output frames and absolute input frames.</a>
<span class="sourceLineNo">215</span><a id="line.215"></a>
<span class="sourceLineNo">216</span><a id="line.216">  /**</a>
<span class="sourceLineNo">217</span><a id="line.217">   * The number of elements in the input stack of the basic block corresponding to this label. This</a>
<span class="sourceLineNo">218</span><a id="line.218">   * field is computed in {@link MethodWriter#computeMaxStackAndLocal}.</a>
<span class="sourceLineNo">219</span><a id="line.219">   */</a>
<span class="sourceLineNo">220</span><a id="line.220">  short inputStackSize;</a>
<span class="sourceLineNo">221</span><a id="line.221"></a>
<span class="sourceLineNo">222</span><a id="line.222">  /**</a>
<span class="sourceLineNo">223</span><a id="line.223">   * The number of elements in the output stack, at the end of the basic block corresponding to this</a>
<span class="sourceLineNo">224</span><a id="line.224">   * label. This field is only computed for basic blocks that end with a RET instruction.</a>
<span class="sourceLineNo">225</span><a id="line.225">   */</a>
<span class="sourceLineNo">226</span><a id="line.226">  short outputStackSize;</a>
<span class="sourceLineNo">227</span><a id="line.227"></a>
<span class="sourceLineNo">228</span><a id="line.228">  /**</a>
<span class="sourceLineNo">229</span><a id="line.229">   * The maximum height reached by the output stack, relatively to the top of the input stack, in</a>
<span class="sourceLineNo">230</span><a id="line.230">   * the basic block corresponding to this label. This maximum is always positive or null.</a>
<span class="sourceLineNo">231</span><a id="line.231">   */</a>
<span class="sourceLineNo">232</span><a id="line.232">  short outputStackMax;</a>
<span class="sourceLineNo">233</span><a id="line.233"></a>
<span class="sourceLineNo">234</span><a id="line.234">  /**</a>
<span class="sourceLineNo">235</span><a id="line.235">   * The id of the subroutine to which this basic block belongs, or 0. If the basic block belongs to</a>
<span class="sourceLineNo">236</span><a id="line.236">   * several subroutines, this is the id of the "oldest" subroutine that contains it (with the</a>
<span class="sourceLineNo">237</span><a id="line.237">   * convention that a subroutine calling another one is "older" than the callee). This field is</a>
<span class="sourceLineNo">238</span><a id="line.238">   * computed in {@link MethodWriter#computeMaxStackAndLocal}, if the method contains JSR</a>
<span class="sourceLineNo">239</span><a id="line.239">   * instructions.</a>
<span class="sourceLineNo">240</span><a id="line.240">   */</a>
<span class="sourceLineNo">241</span><a id="line.241">  short subroutineId;</a>
<span class="sourceLineNo">242</span><a id="line.242"></a>
<span class="sourceLineNo">243</span><a id="line.243">  /**</a>
<span class="sourceLineNo">244</span><a id="line.244">   * The input and output stack map frames of the basic block corresponding to this label. This</a>
<span class="sourceLineNo">245</span><a id="line.245">   * field is only used when the {@link MethodWriter#COMPUTE_ALL_FRAMES} or {@link</a>
<span class="sourceLineNo">246</span><a id="line.246">   * MethodWriter#COMPUTE_INSERTED_FRAMES} option is used.</a>
<span class="sourceLineNo">247</span><a id="line.247">   */</a>
<span class="sourceLineNo">248</span><a id="line.248">  Frame frame;</a>
<span class="sourceLineNo">249</span><a id="line.249"></a>
<span class="sourceLineNo">250</span><a id="line.250">  /**</a>
<span class="sourceLineNo">251</span><a id="line.251">   * The successor of this label, in the order they are visited in {@link MethodVisitor#visitLabel}.</a>
<span class="sourceLineNo">252</span><a id="line.252">   * This linked list does not include labels used for debug info only. If the {@link</a>
<span class="sourceLineNo">253</span><a id="line.253">   * MethodWriter#COMPUTE_ALL_FRAMES} or {@link MethodWriter#COMPUTE_INSERTED_FRAMES} option is used</a>
<span class="sourceLineNo">254</span><a id="line.254">   * then it does not contain either successive labels that denote the same bytecode offset (in this</a>
<span class="sourceLineNo">255</span><a id="line.255">   * case only the first label appears in this list).</a>
<span class="sourceLineNo">256</span><a id="line.256">   */</a>
<span class="sourceLineNo">257</span><a id="line.257">  Label nextBasicBlock;</a>
<span class="sourceLineNo">258</span><a id="line.258"></a>
<span class="sourceLineNo">259</span><a id="line.259">  /**</a>
<span class="sourceLineNo">260</span><a id="line.260">   * The outgoing edges of the basic block corresponding to this label, in the control flow graph of</a>
<span class="sourceLineNo">261</span><a id="line.261">   * its method. These edges are stored in a linked list of {@link Edge} objects, linked to each</a>
<span class="sourceLineNo">262</span><a id="line.262">   * other by their {@link Edge#nextEdge} field.</a>
<span class="sourceLineNo">263</span><a id="line.263">   */</a>
<span class="sourceLineNo">264</span><a id="line.264">  Edge outgoingEdges;</a>
<span class="sourceLineNo">265</span><a id="line.265"></a>
<span class="sourceLineNo">266</span><a id="line.266">  /**</a>
<span class="sourceLineNo">267</span><a id="line.267">   * The next element in the list of labels to which this label belongs, or null if it does not</a>
<span class="sourceLineNo">268</span><a id="line.268">   * belong to any list. All lists of labels must end with the {@link #EMPTY_LIST} sentinel, in</a>
<span class="sourceLineNo">269</span><a id="line.269">   * order to ensure that this field is null if and only if this label does not belong to a list of</a>
<span class="sourceLineNo">270</span><a id="line.270">   * labels. Note that there can be several lists of labels at the same time, but that a label can</a>
<span class="sourceLineNo">271</span><a id="line.271">   * belong to at most one list at a time (unless some lists share a common tail, but this is not</a>
<span class="sourceLineNo">272</span><a id="line.272">   * used in practice).</a>
<span class="sourceLineNo">273</span><a id="line.273">   *</a>
<span class="sourceLineNo">274</span><a id="line.274">   * &lt;p&gt;List of labels are used in {@link MethodWriter#computeAllFrames} and {@link</a>
<span class="sourceLineNo">275</span><a id="line.275">   * MethodWriter#computeMaxStackAndLocal} to compute stack map frames and the maximum stack size,</a>
<span class="sourceLineNo">276</span><a id="line.276">   * respectively, as well as in {@link #markSubroutine} and {@link #addSubroutineRetSuccessors} to</a>
<span class="sourceLineNo">277</span><a id="line.277">   * compute the basic blocks belonging to subroutines and their outgoing edges. Outside of these</a>
<span class="sourceLineNo">278</span><a id="line.278">   * methods, this field should be null (this property is a precondition and a postcondition of</a>
<span class="sourceLineNo">279</span><a id="line.279">   * these methods).</a>
<span class="sourceLineNo">280</span><a id="line.280">   */</a>
<span class="sourceLineNo">281</span><a id="line.281">  Label nextListElement;</a>
<span class="sourceLineNo">282</span><a id="line.282"></a>
<span class="sourceLineNo">283</span><a id="line.283">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">284</span><a id="line.284">  // Constructor and accessors</a>
<span class="sourceLineNo">285</span><a id="line.285">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">286</span><a id="line.286"></a>
<span class="sourceLineNo">287</span><a id="line.287">  /** Constructs a new label. */</a>
<span class="sourceLineNo">288</span><a id="line.288">  public Label() {</a>
<span class="sourceLineNo">289</span><a id="line.289">    // Nothing to do.</a>
<span class="sourceLineNo">290</span><a id="line.290">  }</a>
<span class="sourceLineNo">291</span><a id="line.291"></a>
<span class="sourceLineNo">292</span><a id="line.292">  /**</a>
<span class="sourceLineNo">293</span><a id="line.293">   * Returns the bytecode offset corresponding to this label. This offset is computed from the start</a>
<span class="sourceLineNo">294</span><a id="line.294">   * of the method's bytecode. &lt;i&gt;This method is intended for {@link Attribute} sub classes, and is</a>
<span class="sourceLineNo">295</span><a id="line.295">   * normally not needed by class generators or adapters.&lt;/i&gt;</a>
<span class="sourceLineNo">296</span><a id="line.296">   *</a>
<span class="sourceLineNo">297</span><a id="line.297">   * @return the bytecode offset corresponding to this label.</a>
<span class="sourceLineNo">298</span><a id="line.298">   * @throws IllegalStateException if this label is not resolved yet.</a>
<span class="sourceLineNo">299</span><a id="line.299">   */</a>
<span class="sourceLineNo">300</span><a id="line.300">  public int getOffset() {</a>
<span class="sourceLineNo">301</span><a id="line.301">    if ((flags &amp; FLAG_RESOLVED) == 0) {</a>
<span class="sourceLineNo">302</span><a id="line.302">      throw new IllegalStateException("Label offset position has not been resolved yet");</a>
<span class="sourceLineNo">303</span><a id="line.303">    }</a>
<span class="sourceLineNo">304</span><a id="line.304">    return bytecodeOffset;</a>
<span class="sourceLineNo">305</span><a id="line.305">  }</a>
<span class="sourceLineNo">306</span><a id="line.306"></a>
<span class="sourceLineNo">307</span><a id="line.307">  /**</a>
<span class="sourceLineNo">308</span><a id="line.308">   * Returns the "canonical" {@link Label} instance corresponding to this label's bytecode offset,</a>
<span class="sourceLineNo">309</span><a id="line.309">   * if known, otherwise the label itself. The canonical instance is the first label (in the order</a>
<span class="sourceLineNo">310</span><a id="line.310">   * of their visit by {@link MethodVisitor#visitLabel}) corresponding to this bytecode offset. It</a>
<span class="sourceLineNo">311</span><a id="line.311">   * cannot be known for labels which have not been visited yet.</a>
<span class="sourceLineNo">312</span><a id="line.312">   *</a>
<span class="sourceLineNo">313</span><a id="line.313">   * &lt;p&gt;&lt;i&gt;This method should only be used when the {@link MethodWriter#COMPUTE_ALL_FRAMES} option</a>
<span class="sourceLineNo">314</span><a id="line.314">   * is used.&lt;/i&gt;</a>
<span class="sourceLineNo">315</span><a id="line.315">   *</a>
<span class="sourceLineNo">316</span><a id="line.316">   * @return the label itself if {@link #frame} is null, otherwise the Label's frame owner. This</a>
<span class="sourceLineNo">317</span><a id="line.317">   *     corresponds to the "canonical" label instance described above thanks to the way the label</a>
<span class="sourceLineNo">318</span><a id="line.318">   *     frame is set in {@link MethodWriter#visitLabel}.</a>
<span class="sourceLineNo">319</span><a id="line.319">   */</a>
<span class="sourceLineNo">320</span><a id="line.320">  final Label getCanonicalInstance() {</a>
<span class="sourceLineNo">321</span><a id="line.321">    return frame == null ? this : frame.owner;</a>
<span class="sourceLineNo">322</span><a id="line.322">  }</a>
<span class="sourceLineNo">323</span><a id="line.323"></a>
<span class="sourceLineNo">324</span><a id="line.324">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">325</span><a id="line.325">  // Methods to manage line numbers</a>
<span class="sourceLineNo">326</span><a id="line.326">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">327</span><a id="line.327"></a>
<span class="sourceLineNo">328</span><a id="line.328">  /**</a>
<span class="sourceLineNo">329</span><a id="line.329">   * Adds a source line number corresponding to this label.</a>
<span class="sourceLineNo">330</span><a id="line.330">   *</a>
<span class="sourceLineNo">331</span><a id="line.331">   * @param lineNumber a source line number (which should be strictly positive).</a>
<span class="sourceLineNo">332</span><a id="line.332">   */</a>
<span class="sourceLineNo">333</span><a id="line.333">  final void addLineNumber(final int lineNumber) {</a>
<span class="sourceLineNo">334</span><a id="line.334">    if (this.lineNumber == 0) {</a>
<span class="sourceLineNo">335</span><a id="line.335">      this.lineNumber = (short) lineNumber;</a>
<span class="sourceLineNo">336</span><a id="line.336">    } else {</a>
<span class="sourceLineNo">337</span><a id="line.337">      if (otherLineNumbers == null) {</a>
<span class="sourceLineNo">338</span><a id="line.338">        otherLineNumbers = new int[LINE_NUMBERS_CAPACITY_INCREMENT];</a>
<span class="sourceLineNo">339</span><a id="line.339">      }</a>
<span class="sourceLineNo">340</span><a id="line.340">      int otherLineNumberIndex = ++otherLineNumbers[0];</a>
<span class="sourceLineNo">341</span><a id="line.341">      if (otherLineNumberIndex &gt;= otherLineNumbers.length) {</a>
<span class="sourceLineNo">342</span><a id="line.342">        int[] newLineNumbers = new int[otherLineNumbers.length + LINE_NUMBERS_CAPACITY_INCREMENT];</a>
<span class="sourceLineNo">343</span><a id="line.343">        System.arraycopy(otherLineNumbers, 0, newLineNumbers, 0, otherLineNumbers.length);</a>
<span class="sourceLineNo">344</span><a id="line.344">        otherLineNumbers = newLineNumbers;</a>
<span class="sourceLineNo">345</span><a id="line.345">      }</a>
<span class="sourceLineNo">346</span><a id="line.346">      otherLineNumbers[otherLineNumberIndex] = lineNumber;</a>
<span class="sourceLineNo">347</span><a id="line.347">    }</a>
<span class="sourceLineNo">348</span><a id="line.348">  }</a>
<span class="sourceLineNo">349</span><a id="line.349"></a>
<span class="sourceLineNo">350</span><a id="line.350">  /**</a>
<span class="sourceLineNo">351</span><a id="line.351">   * Makes the given visitor visit this label and its source line numbers, if applicable.</a>
<span class="sourceLineNo">352</span><a id="line.352">   *</a>
<span class="sourceLineNo">353</span><a id="line.353">   * @param methodVisitor a method visitor.</a>
<span class="sourceLineNo">354</span><a id="line.354">   * @param visitLineNumbers whether to visit of the label's source line numbers, if any.</a>
<span class="sourceLineNo">355</span><a id="line.355">   */</a>
<span class="sourceLineNo">356</span><a id="line.356">  final void accept(final MethodVisitor methodVisitor, final boolean visitLineNumbers) {</a>
<span class="sourceLineNo">357</span><a id="line.357">    methodVisitor.visitLabel(this);</a>
<span class="sourceLineNo">358</span><a id="line.358">    if (visitLineNumbers &amp;&amp; lineNumber != 0) {</a>
<span class="sourceLineNo">359</span><a id="line.359">      methodVisitor.visitLineNumber(lineNumber &amp; 0xFFFF, this);</a>
<span class="sourceLineNo">360</span><a id="line.360">      if (otherLineNumbers != null) {</a>
<span class="sourceLineNo">361</span><a id="line.361">        for (int i = 1; i &lt;= otherLineNumbers[0]; ++i) {</a>
<span class="sourceLineNo">362</span><a id="line.362">          methodVisitor.visitLineNumber(otherLineNumbers[i], this);</a>
<span class="sourceLineNo">363</span><a id="line.363">        }</a>
<span class="sourceLineNo">364</span><a id="line.364">      }</a>
<span class="sourceLineNo">365</span><a id="line.365">    }</a>
<span class="sourceLineNo">366</span><a id="line.366">  }</a>
<span class="sourceLineNo">367</span><a id="line.367"></a>
<span class="sourceLineNo">368</span><a id="line.368">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">369</span><a id="line.369">  // Methods to compute offsets and to manage forward references</a>
<span class="sourceLineNo">370</span><a id="line.370">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">371</span><a id="line.371"></a>
<span class="sourceLineNo">372</span><a id="line.372">  /**</a>
<span class="sourceLineNo">373</span><a id="line.373">   * Puts a reference to this label in the bytecode of a method. If the bytecode offset of the label</a>
<span class="sourceLineNo">374</span><a id="line.374">   * is known, the relative bytecode offset between the label and the instruction referencing it is</a>
<span class="sourceLineNo">375</span><a id="line.375">   * computed and written directly. Otherwise, a null relative offset is written and a new forward</a>
<span class="sourceLineNo">376</span><a id="line.376">   * reference is declared for this label.</a>
<span class="sourceLineNo">377</span><a id="line.377">   *</a>
<span class="sourceLineNo">378</span><a id="line.378">   * @param code the bytecode of the method. This is where the reference is appended.</a>
<span class="sourceLineNo">379</span><a id="line.379">   * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the</a>
<span class="sourceLineNo">380</span><a id="line.380">   *     reference to be appended.</a>
<span class="sourceLineNo">381</span><a id="line.381">   * @param wideReference whether the reference must be stored in 4 bytes (instead of 2 bytes).</a>
<span class="sourceLineNo">382</span><a id="line.382">   */</a>
<span class="sourceLineNo">383</span><a id="line.383">  final void put(</a>
<span class="sourceLineNo">384</span><a id="line.384">      final ByteVector code, final int sourceInsnBytecodeOffset, final boolean wideReference) {</a>
<span class="sourceLineNo">385</span><a id="line.385">    if ((flags &amp; FLAG_RESOLVED) == 0) {</a>
<span class="sourceLineNo">386</span><a id="line.386">      if (wideReference) {</a>
<span class="sourceLineNo">387</span><a id="line.387">        addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_WIDE, code.length);</a>
<span class="sourceLineNo">388</span><a id="line.388">        code.putInt(-1);</a>
<span class="sourceLineNo">389</span><a id="line.389">      } else {</a>
<span class="sourceLineNo">390</span><a id="line.390">        addForwardReference(sourceInsnBytecodeOffset, FORWARD_REFERENCE_TYPE_SHORT, code.length);</a>
<span class="sourceLineNo">391</span><a id="line.391">        code.putShort(-1);</a>
<span class="sourceLineNo">392</span><a id="line.392">      }</a>
<span class="sourceLineNo">393</span><a id="line.393">    } else {</a>
<span class="sourceLineNo">394</span><a id="line.394">      if (wideReference) {</a>
<span class="sourceLineNo">395</span><a id="line.395">        code.putInt(bytecodeOffset - sourceInsnBytecodeOffset);</a>
<span class="sourceLineNo">396</span><a id="line.396">      } else {</a>
<span class="sourceLineNo">397</span><a id="line.397">        code.putShort(bytecodeOffset - sourceInsnBytecodeOffset);</a>
<span class="sourceLineNo">398</span><a id="line.398">      }</a>
<span class="sourceLineNo">399</span><a id="line.399">    }</a>
<span class="sourceLineNo">400</span><a id="line.400">  }</a>
<span class="sourceLineNo">401</span><a id="line.401"></a>
<span class="sourceLineNo">402</span><a id="line.402">  /**</a>
<span class="sourceLineNo">403</span><a id="line.403">   * Adds a forward reference to this label. This method must be called only for a true forward</a>
<span class="sourceLineNo">404</span><a id="line.404">   * reference, i.e. only if this label is not resolved yet. For backward references, the relative</a>
<span class="sourceLineNo">405</span><a id="line.405">   * bytecode offset of the reference can be, and must be, computed and stored directly.</a>
<span class="sourceLineNo">406</span><a id="line.406">   *</a>
<span class="sourceLineNo">407</span><a id="line.407">   * @param sourceInsnBytecodeOffset the bytecode offset of the instruction that contains the</a>
<span class="sourceLineNo">408</span><a id="line.408">   *     reference stored at referenceHandle.</a>
<span class="sourceLineNo">409</span><a id="line.409">   * @param referenceType either {@link #FORWARD_REFERENCE_TYPE_SHORT} or {@link</a>
<span class="sourceLineNo">410</span><a id="line.410">   *     #FORWARD_REFERENCE_TYPE_WIDE}.</a>
<span class="sourceLineNo">411</span><a id="line.411">   * @param referenceHandle the offset in the bytecode where the forward reference value must be</a>
<span class="sourceLineNo">412</span><a id="line.412">   *     stored.</a>
<span class="sourceLineNo">413</span><a id="line.413">   */</a>
<span class="sourceLineNo">414</span><a id="line.414">  private void addForwardReference(</a>
<span class="sourceLineNo">415</span><a id="line.415">      final int sourceInsnBytecodeOffset, final int referenceType, final int referenceHandle) {</a>
<span class="sourceLineNo">416</span><a id="line.416">    if (forwardReferences == null) {</a>
<span class="sourceLineNo">417</span><a id="line.417">      forwardReferences = new int[FORWARD_REFERENCES_CAPACITY_INCREMENT];</a>
<span class="sourceLineNo">418</span><a id="line.418">    }</a>
<span class="sourceLineNo">419</span><a id="line.419">    int lastElementIndex = forwardReferences[0];</a>
<span class="sourceLineNo">420</span><a id="line.420">    if (lastElementIndex + 2 &gt;= forwardReferences.length) {</a>
<span class="sourceLineNo">421</span><a id="line.421">      int[] newValues = new int[forwardReferences.length + FORWARD_REFERENCES_CAPACITY_INCREMENT];</a>
<span class="sourceLineNo">422</span><a id="line.422">      System.arraycopy(forwardReferences, 0, newValues, 0, forwardReferences.length);</a>
<span class="sourceLineNo">423</span><a id="line.423">      forwardReferences = newValues;</a>
<span class="sourceLineNo">424</span><a id="line.424">    }</a>
<span class="sourceLineNo">425</span><a id="line.425">    forwardReferences[++lastElementIndex] = sourceInsnBytecodeOffset;</a>
<span class="sourceLineNo">426</span><a id="line.426">    forwardReferences[++lastElementIndex] = referenceType | referenceHandle;</a>
<span class="sourceLineNo">427</span><a id="line.427">    forwardReferences[0] = lastElementIndex;</a>
<span class="sourceLineNo">428</span><a id="line.428">  }</a>
<span class="sourceLineNo">429</span><a id="line.429"></a>
<span class="sourceLineNo">430</span><a id="line.430">  /**</a>
<span class="sourceLineNo">431</span><a id="line.431">   * Sets the bytecode offset of this label to the given value and resolves the forward references</a>
<span class="sourceLineNo">432</span><a id="line.432">   * to this label, if any. This method must be called when this label is added to the bytecode of</a>
<span class="sourceLineNo">433</span><a id="line.433">   * the method, i.e. when its bytecode offset becomes known. This method fills in the blanks that</a>
<span class="sourceLineNo">434</span><a id="line.434">   * where left in the bytecode by each forward reference previously added to this label.</a>
<span class="sourceLineNo">435</span><a id="line.435">   *</a>
<span class="sourceLineNo">436</span><a id="line.436">   * @param code the bytecode of the method.</a>
<span class="sourceLineNo">437</span><a id="line.437">   * @param bytecodeOffset the bytecode offset of this label.</a>
<span class="sourceLineNo">438</span><a id="line.438">   * @return &lt;tt&gt;true&lt;/tt&gt; if a blank that was left for this label was too small to store the</a>
<span class="sourceLineNo">439</span><a id="line.439">   *     offset. In such a case the corresponding jump instruction is replaced with an equivalent</a>
<span class="sourceLineNo">440</span><a id="line.440">   *     ASM specific instruction using an unsigned two bytes offset. These ASM specific</a>
<span class="sourceLineNo">441</span><a id="line.441">   *     instructions are later replaced with standard bytecode instructions with wider offsets (4</a>
<span class="sourceLineNo">442</span><a id="line.442">   *     bytes instead of 2), in ClassReader.</a>
<span class="sourceLineNo">443</span><a id="line.443">   */</a>
<span class="sourceLineNo">444</span><a id="line.444">  final boolean resolve(final byte[] code, final int bytecodeOffset) {</a>
<span class="sourceLineNo">445</span><a id="line.445">    this.flags |= FLAG_RESOLVED;</a>
<span class="sourceLineNo">446</span><a id="line.446">    this.bytecodeOffset = bytecodeOffset;</a>
<span class="sourceLineNo">447</span><a id="line.447">    if (forwardReferences == null) {</a>
<span class="sourceLineNo">448</span><a id="line.448">      return false;</a>
<span class="sourceLineNo">449</span><a id="line.449">    }</a>
<span class="sourceLineNo">450</span><a id="line.450">    boolean hasAsmInstructions = false;</a>
<span class="sourceLineNo">451</span><a id="line.451">    for (int i = forwardReferences[0]; i &gt; 0; i -= 2) {</a>
<span class="sourceLineNo">452</span><a id="line.452">      final int sourceInsnBytecodeOffset = forwardReferences[i - 1];</a>
<span class="sourceLineNo">453</span><a id="line.453">      final int reference = forwardReferences[i];</a>
<span class="sourceLineNo">454</span><a id="line.454">      final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset;</a>
<span class="sourceLineNo">455</span><a id="line.455">      int handle = reference &amp; FORWARD_REFERENCE_HANDLE_MASK;</a>
<span class="sourceLineNo">456</span><a id="line.456">      if ((reference &amp; FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_SHORT) {</a>
<span class="sourceLineNo">457</span><a id="line.457">        if (relativeOffset &lt; Short.MIN_VALUE || relativeOffset &gt; Short.MAX_VALUE) {</a>
<span class="sourceLineNo">458</span><a id="line.458">          // Change the opcode of the jump instruction, in order to be able to find it later in</a>
<span class="sourceLineNo">459</span><a id="line.459">          // ClassReader. These ASM specific opcodes are similar to jump instruction opcodes, except</a>
<span class="sourceLineNo">460</span><a id="line.460">          // that the 2 bytes offset is unsigned (and can therefore represent values from 0 to</a>
<span class="sourceLineNo">461</span><a id="line.461">          // 65535, which is sufficient since the size of a method is limited to 65535 bytes).</a>
<span class="sourceLineNo">462</span><a id="line.462">          int opcode = code[sourceInsnBytecodeOffset] &amp; 0xFF;</a>
<span class="sourceLineNo">463</span><a id="line.463">          if (opcode &lt; Opcodes.IFNULL) {</a>
<span class="sourceLineNo">464</span><a id="line.464">            // Change IFEQ ... JSR to ASM_IFEQ ... ASM_JSR.</a>
<span class="sourceLineNo">465</span><a id="line.465">            code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_OPCODE_DELTA);</a>
<span class="sourceLineNo">466</span><a id="line.466">          } else {</a>
<span class="sourceLineNo">467</span><a id="line.467">            // Change IFNULL and IFNONNULL to ASM_IFNULL and ASM_IFNONNULL.</a>
<span class="sourceLineNo">468</span><a id="line.468">            code[sourceInsnBytecodeOffset] = (byte) (opcode + Constants.ASM_IFNULL_OPCODE_DELTA);</a>
<span class="sourceLineNo">469</span><a id="line.469">          }</a>
<span class="sourceLineNo">470</span><a id="line.470">          hasAsmInstructions = true;</a>
<span class="sourceLineNo">471</span><a id="line.471">        }</a>
<span class="sourceLineNo">472</span><a id="line.472">        code[handle++] = (byte) (relativeOffset &gt;&gt;&gt; 8);</a>
<span class="sourceLineNo">473</span><a id="line.473">        code[handle] = (byte) relativeOffset;</a>
<span class="sourceLineNo">474</span><a id="line.474">      } else {</a>
<span class="sourceLineNo">475</span><a id="line.475">        code[handle++] = (byte) (relativeOffset &gt;&gt;&gt; 24);</a>
<span class="sourceLineNo">476</span><a id="line.476">        code[handle++] = (byte) (relativeOffset &gt;&gt;&gt; 16);</a>
<span class="sourceLineNo">477</span><a id="line.477">        code[handle++] = (byte) (relativeOffset &gt;&gt;&gt; 8);</a>
<span class="sourceLineNo">478</span><a id="line.478">        code[handle] = (byte) relativeOffset;</a>
<span class="sourceLineNo">479</span><a id="line.479">      }</a>
<span class="sourceLineNo">480</span><a id="line.480">    }</a>
<span class="sourceLineNo">481</span><a id="line.481">    return hasAsmInstructions;</a>
<span class="sourceLineNo">482</span><a id="line.482">  }</a>
<span class="sourceLineNo">483</span><a id="line.483"></a>
<span class="sourceLineNo">484</span><a id="line.484">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">485</span><a id="line.485">  // Methods related to subroutines</a>
<span class="sourceLineNo">486</span><a id="line.486">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">487</span><a id="line.487"></a>
<span class="sourceLineNo">488</span><a id="line.488">  /**</a>
<span class="sourceLineNo">489</span><a id="line.489">   * Finds the basic blocks that belong to the subroutine starting with the basic block</a>
<span class="sourceLineNo">490</span><a id="line.490">   * corresponding to this label, and marks these blocks as belonging to this subroutine. This</a>
<span class="sourceLineNo">491</span><a id="line.491">   * method follows the control flow graph to find all the blocks that are reachable from the</a>
<span class="sourceLineNo">492</span><a id="line.492">   * current basic block WITHOUT following any jsr target.</a>
<span class="sourceLineNo">493</span><a id="line.493">   *</a>
<span class="sourceLineNo">494</span><a id="line.494">   * &lt;p&gt;Note: a precondition and postcondition of this method is that all labels must have a null</a>
<span class="sourceLineNo">495</span><a id="line.495">   * {@link #nextListElement}.</a>
<span class="sourceLineNo">496</span><a id="line.496">   *</a>
<span class="sourceLineNo">497</span><a id="line.497">   * @param subroutineId the id of the subroutine starting with the basic block corresponding to</a>
<span class="sourceLineNo">498</span><a id="line.498">   *     this label.</a>
<span class="sourceLineNo">499</span><a id="line.499">   */</a>
<span class="sourceLineNo">500</span><a id="line.500">  final void markSubroutine(final short subroutineId) {</a>
<span class="sourceLineNo">501</span><a id="line.501">    // Data flow algorithm: put this basic block in a list of blocks to process (which are blocks</a>
<span class="sourceLineNo">502</span><a id="line.502">    // belonging to subroutine subroutineId) and, while there are blocks to process, remove one from</a>
<span class="sourceLineNo">503</span><a id="line.503">    // the list, mark it as belonging to the subroutine, and add its successor basic blocks in the</a>
<span class="sourceLineNo">504</span><a id="line.504">    // control flow graph to the list of blocks to process (if not already done).</a>
<span class="sourceLineNo">505</span><a id="line.505">    Label listOfBlocksToProcess = this;</a>
<span class="sourceLineNo">506</span><a id="line.506">    listOfBlocksToProcess.nextListElement = EMPTY_LIST;</a>
<span class="sourceLineNo">507</span><a id="line.507">    while (listOfBlocksToProcess != EMPTY_LIST) {</a>
<span class="sourceLineNo">508</span><a id="line.508">      // Remove a basic block from the list of blocks to process.</a>
<span class="sourceLineNo">509</span><a id="line.509">      Label basicBlock = listOfBlocksToProcess;</a>
<span class="sourceLineNo">510</span><a id="line.510">      listOfBlocksToProcess = listOfBlocksToProcess.nextListElement;</a>
<span class="sourceLineNo">511</span><a id="line.511">      basicBlock.nextListElement = null;</a>
<span class="sourceLineNo">512</span><a id="line.512"></a>
<span class="sourceLineNo">513</span><a id="line.513">      // If it is not already marked as belonging to a subroutine, mark it as belonging to</a>
<span class="sourceLineNo">514</span><a id="line.514">      // subroutineId and add its successors to the list of blocks to process (unless already done).</a>
<span class="sourceLineNo">515</span><a id="line.515">      if (basicBlock.subroutineId == 0) {</a>
<span class="sourceLineNo">516</span><a id="line.516">        basicBlock.subroutineId = subroutineId;</a>
<span class="sourceLineNo">517</span><a id="line.517">        listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess);</a>
<span class="sourceLineNo">518</span><a id="line.518">      }</a>
<span class="sourceLineNo">519</span><a id="line.519">    }</a>
<span class="sourceLineNo">520</span><a id="line.520">  }</a>
<span class="sourceLineNo">521</span><a id="line.521"></a>
<span class="sourceLineNo">522</span><a id="line.522">  /**</a>
<span class="sourceLineNo">523</span><a id="line.523">   * Finds the basic blocks that end a subroutine starting with the basic block corresponding to</a>
<span class="sourceLineNo">524</span><a id="line.524">   * this label and, for each one of them, adds an outgoing edge to the basic block following the</a>
<span class="sourceLineNo">525</span><a id="line.525">   * given subroutine call. In other words, completes the control flow graph by adding the edges</a>
<span class="sourceLineNo">526</span><a id="line.526">   * corresponding to the return from this subroutine, when called from the given caller basic</a>
<span class="sourceLineNo">527</span><a id="line.527">   * block.</a>
<span class="sourceLineNo">528</span><a id="line.528">   *</a>
<span class="sourceLineNo">529</span><a id="line.529">   * &lt;p&gt;Note: a precondition and postcondition of this method is that all labels must have a null</a>
<span class="sourceLineNo">530</span><a id="line.530">   * {@link #nextListElement}.</a>
<span class="sourceLineNo">531</span><a id="line.531">   *</a>
<span class="sourceLineNo">532</span><a id="line.532">   * @param subroutineCaller a basic block that ends with a jsr to the basic block corresponding to</a>
<span class="sourceLineNo">533</span><a id="line.533">   *     this label. This label is supposed to correspond to the start of a subroutine.</a>
<span class="sourceLineNo">534</span><a id="line.534">   */</a>
<span class="sourceLineNo">535</span><a id="line.535">  final void addSubroutineRetSuccessors(final Label subroutineCaller) {</a>
<span class="sourceLineNo">536</span><a id="line.536">    // Data flow algorithm: put this basic block in a list blocks to process (which are blocks</a>
<span class="sourceLineNo">537</span><a id="line.537">    // belonging to a subroutine starting with this label) and, while there are blocks to process,</a>
<span class="sourceLineNo">538</span><a id="line.538">    // remove one from the list, put it in a list of blocks that have been processed, add a return</a>
<span class="sourceLineNo">539</span><a id="line.539">    // edge to the successor of subroutineCaller if applicable, and add its successor basic blocks</a>
<span class="sourceLineNo">540</span><a id="line.540">    // in the control flow graph to the list of blocks to process (if not already done).</a>
<span class="sourceLineNo">541</span><a id="line.541">    Label listOfProcessedBlocks = EMPTY_LIST;</a>
<span class="sourceLineNo">542</span><a id="line.542">    Label listOfBlocksToProcess = this;</a>
<span class="sourceLineNo">543</span><a id="line.543">    listOfBlocksToProcess.nextListElement = EMPTY_LIST;</a>
<span class="sourceLineNo">544</span><a id="line.544">    while (listOfBlocksToProcess != EMPTY_LIST) {</a>
<span class="sourceLineNo">545</span><a id="line.545">      // Move a basic block from the list of blocks to process to the list of processed blocks.</a>
<span class="sourceLineNo">546</span><a id="line.546">      Label basicBlock = listOfBlocksToProcess;</a>
<span class="sourceLineNo">547</span><a id="line.547">      listOfBlocksToProcess = basicBlock.nextListElement;</a>
<span class="sourceLineNo">548</span><a id="line.548">      basicBlock.nextListElement = listOfProcessedBlocks;</a>
<span class="sourceLineNo">549</span><a id="line.549">      listOfProcessedBlocks = basicBlock;</a>
<span class="sourceLineNo">550</span><a id="line.550"></a>
<span class="sourceLineNo">551</span><a id="line.551">      // Add an edge from this block to the successor of the caller basic block, if this block is</a>
<span class="sourceLineNo">552</span><a id="line.552">      // the end of a subroutine and if this block and subroutineCaller do not belong to the same</a>
<span class="sourceLineNo">553</span><a id="line.553">      // subroutine.</a>
<span class="sourceLineNo">554</span><a id="line.554">      if ((basicBlock.flags &amp; FLAG_SUBROUTINE_END) != 0</a>
<span class="sourceLineNo">555</span><a id="line.555">          &amp;&amp; basicBlock.subroutineId != subroutineCaller.subroutineId) {</a>
<span class="sourceLineNo">556</span><a id="line.556">        basicBlock.outgoingEdges =</a>
<span class="sourceLineNo">557</span><a id="line.557">            new Edge(</a>
<span class="sourceLineNo">558</span><a id="line.558">                basicBlock.outputStackSize,</a>
<span class="sourceLineNo">559</span><a id="line.559">                // By construction, the first outgoing edge of a basic block that ends with a jsr</a>
<span class="sourceLineNo">560</span><a id="line.560">                // instruction leads to the jsr continuation block, i.e. where execution continues</a>
<span class="sourceLineNo">561</span><a id="line.561">                // when ret is called (see {@link #FLAG_SUBROUTINE_CALLER}).</a>
<span class="sourceLineNo">562</span><a id="line.562">                subroutineCaller.outgoingEdges.successor,</a>
<span class="sourceLineNo">563</span><a id="line.563">                basicBlock.outgoingEdges);</a>
<span class="sourceLineNo">564</span><a id="line.564">      }</a>
<span class="sourceLineNo">565</span><a id="line.565">      // Add its successors to the list of blocks to process. Note that {@link #pushSuccessors} does</a>
<span class="sourceLineNo">566</span><a id="line.566">      // not push basic blocks which are already in a list. Here this means either in the list of</a>
<span class="sourceLineNo">567</span><a id="line.567">      // blocks to process, or in the list of already processed blocks. This second list is</a>
<span class="sourceLineNo">568</span><a id="line.568">      // important to make sure we don't reprocess an already processed block.</a>
<span class="sourceLineNo">569</span><a id="line.569">      listOfBlocksToProcess = basicBlock.pushSuccessors(listOfBlocksToProcess);</a>
<span class="sourceLineNo">570</span><a id="line.570">    }</a>
<span class="sourceLineNo">571</span><a id="line.571">    // Reset the {@link #nextListElement} of all the basic blocks that have been processed to null,</a>
<span class="sourceLineNo">572</span><a id="line.572">    // so that this method can be called again with a different subroutine or subroutine caller.</a>
<span class="sourceLineNo">573</span><a id="line.573">    while (listOfProcessedBlocks != EMPTY_LIST) {</a>
<span class="sourceLineNo">574</span><a id="line.574">      Label newListOfProcessedBlocks = listOfProcessedBlocks.nextListElement;</a>
<span class="sourceLineNo">575</span><a id="line.575">      listOfProcessedBlocks.nextListElement = null;</a>
<span class="sourceLineNo">576</span><a id="line.576">      listOfProcessedBlocks = newListOfProcessedBlocks;</a>
<span class="sourceLineNo">577</span><a id="line.577">    }</a>
<span class="sourceLineNo">578</span><a id="line.578">  }</a>
<span class="sourceLineNo">579</span><a id="line.579"></a>
<span class="sourceLineNo">580</span><a id="line.580">  /**</a>
<span class="sourceLineNo">581</span><a id="line.581">   * Adds the successors of this label in the method's control flow graph (except those</a>
<span class="sourceLineNo">582</span><a id="line.582">   * corresponding to a jsr target, and those already in a list of labels) to the given list of</a>
<span class="sourceLineNo">583</span><a id="line.583">   * blocks to process, and returns the new list.</a>
<span class="sourceLineNo">584</span><a id="line.584">   *</a>
<span class="sourceLineNo">585</span><a id="line.585">   * @param listOfLabelsToProcess a list of basic blocks to process, linked together with their</a>
<span class="sourceLineNo">586</span><a id="line.586">   *     {@link #nextListElement} field.</a>
<span class="sourceLineNo">587</span><a id="line.587">   * @return the new list of blocks to process.</a>
<span class="sourceLineNo">588</span><a id="line.588">   */</a>
<span class="sourceLineNo">589</span><a id="line.589">  private Label pushSuccessors(final Label listOfLabelsToProcess) {</a>
<span class="sourceLineNo">590</span><a id="line.590">    Label newListOfLabelsToProcess = listOfLabelsToProcess;</a>
<span class="sourceLineNo">591</span><a id="line.591">    Edge outgoingEdge = outgoingEdges;</a>
<span class="sourceLineNo">592</span><a id="line.592">    while (outgoingEdge != null) {</a>
<span class="sourceLineNo">593</span><a id="line.593">      // By construction, the second outgoing edge of a basic block that ends with a jsr instruction</a>
<span class="sourceLineNo">594</span><a id="line.594">      // leads to the jsr target (see {@link #FLAG_SUBROUTINE_CALLER}).</a>
<span class="sourceLineNo">595</span><a id="line.595">      boolean isJsrTarget =</a>
<span class="sourceLineNo">596</span><a id="line.596">          (flags &amp; Label.FLAG_SUBROUTINE_CALLER) != 0 &amp;&amp; outgoingEdge == outgoingEdges.nextEdge;</a>
<span class="sourceLineNo">597</span><a id="line.597">      if (!isJsrTarget &amp;&amp; outgoingEdge.successor.nextListElement == null) {</a>
<span class="sourceLineNo">598</span><a id="line.598">        // Add this successor to the list of blocks to process, if it does not already belong to a</a>
<span class="sourceLineNo">599</span><a id="line.599">        // list of labels.</a>
<span class="sourceLineNo">600</span><a id="line.600">        outgoingEdge.successor.nextListElement = newListOfLabelsToProcess;</a>
<span class="sourceLineNo">601</span><a id="line.601">        newListOfLabelsToProcess = outgoingEdge.successor;</a>
<span class="sourceLineNo">602</span><a id="line.602">      }</a>
<span class="sourceLineNo">603</span><a id="line.603">      outgoingEdge = outgoingEdge.nextEdge;</a>
<span class="sourceLineNo">604</span><a id="line.604">    }</a>
<span class="sourceLineNo">605</span><a id="line.605">    return newListOfLabelsToProcess;</a>
<span class="sourceLineNo">606</span><a id="line.606">  }</a>
<span class="sourceLineNo">607</span><a id="line.607"></a>
<span class="sourceLineNo">608</span><a id="line.608">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">609</span><a id="line.609">  // Overridden Object methods</a>
<span class="sourceLineNo">610</span><a id="line.610">  // -----------------------------------------------------------------------------------------------</a>
<span class="sourceLineNo">611</span><a id="line.611"></a>
<span class="sourceLineNo">612</span><a id="line.612">  /**</a>
<span class="sourceLineNo">613</span><a id="line.613">   * Returns a string representation of this label.</a>
<span class="sourceLineNo">614</span><a id="line.614">   *</a>
<span class="sourceLineNo">615</span><a id="line.615">   * @return a string representation of this label.</a>
<span class="sourceLineNo">616</span><a id="line.616">   */</a>
<span class="sourceLineNo">617</span><a id="line.617">  @Override</a>
<span class="sourceLineNo">618</span><a id="line.618">  public String toString() {</a>
<span class="sourceLineNo">619</span><a id="line.619">    return "L" + System.identityHashCode(this);</a>
<span class="sourceLineNo">620</span><a id="line.620">  }</a>
<span class="sourceLineNo">621</span><a id="line.621">}</a>




























































</pre>
</div>
</main>
</body>
</html>
